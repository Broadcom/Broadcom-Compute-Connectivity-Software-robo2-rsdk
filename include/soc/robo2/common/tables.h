/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Id: $
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom/Broadcom-Compute-Connectivity-Software-robo2-rsdk/master/Legal/LICENSE file.
 *
 * $Copyright: (c) 2020 Broadcom Inc.
 * All Rights Reserved.$
 *
 * File:	tables.h
 * Purpose:	Robo2 Table declarations
 */

#ifndef _SOC_ROBO2_TABLES_H
#define _SOC_ROBO2_TABLES_H

#include <sal_types.h>
#include <sal_time.h>
#include <sal_console.h>
#include <soc/types.h>
#include <soc/defs.h>
#include <soc/drv.h>
#include <soc/register.h>
#include <soc/error.h>
#include <soc/robo2/common/allenum.h>
#include <soc/robo2/common/regacc.h>
#include <soc/robo2/common/memregs.h>
#include <soc/robo2/common/robo2_types.h>

/*
 * Helper Macros 
 */

/**
 * @def ROBO2_REG_READ_WITH_ID (u, r, p, i, v)
 *    Read register "r" in port "p" or array index "i"
 *    get the value in "v"
 */
#define ROBO2_REG_READ_WITH_ID(u, r, p, i, v) \
    DRV_REG_READ(u, DRV_REG_ADDR(u, r, p, i), v, DRV_REG_LENGTH_GET(u, r))

/**
 * @def ROBO2_REG_WRITE_WITH_ID (u, r, p, i, v)
 *    Write value "v" to register "r" in port "p" or array index "i"
 */
#define ROBO2_REG_WRITE_WITH_ID(u, r, p, i, v) \
    DRV_REG_WRITE(u, DRV_REG_ADDR(u, r, p, i), v, DRV_REG_LENGTH_GET(u, r))

/**
 * @def SOC_REG_FIELD_SET (u, r, rv, f, fv)
 *    In variable \c rv representing register \c r
 *    set the field \c f to value \c fv in unit \c u
 */
#define SOC_REG_FIELD_SET(u, r, rv, f, fv) \
    DRV_REG_FIELD_SET(u, r, rv, f##_ROBO2, fv)
/**
 * @def SOC_REG_FIELD_GET (u, r, rv, f, fv)
 *    Get the value of field \c f into ptr \c fv
 *    from variable \c rv representing register \c r
 *    in unit \c u
 */
#define SOC_REG_FIELD_GET(u, r, rv, f, fv) \
    DRV_REG_FIELD_GET(u, r, rv, f##_ROBO2, fv)

/*
 * Flags to control Table Dump Output formats
 */
#define SOC_ROBO2_TABLE_FORMAT_DEC 0
#define SOC_ROBO2_TABLE_FORMAT_HEX 1
#define SOC_ROBO2_TABLE_FORMAT_NZ  2
 
/**
 * TRAP CONTROL TABLE:
 * 
 * this table is indexed by trap id and returns fields that control
 * the operation of the associated trap.
 * </p><p>
 * trap ids defined by %docenum trap_id_e%
 * </p><p>
 * the fields available per trap are:
 */
typedef struct cb_ipp_tct_s {
    /**
     * If set then a frame that encounters the associated trap is
     * dropped on the normal forwarding path. It may or may not be
     * forwarded to the associated trap group depending on the setting of
     * the trap bit.
     */
    uint8   drop;

    /**
     * If set then a frame that encounters the associated trap is
     * terminated. Further processing of the frame is not done.
     * Generally this field is zero on power up except for the
     * following traps which default to terminal:
     * <UL>
     * <LI>TRAP_MAC_ERROR</LI>
     * <LI>TRAP_BMU_RES_DROP</LI>
     * <LI>TRAP_TLV_INV_LEN</LI>
     * <LI>TRAP_TLV_INV_TYPE</LI>
     * <LI>TRAP_TLV_MAX_NUM</LI>
     * <LI>TRAP_TLV_MAX_LEN</LI>
     * <LI>TRAP_RP_TERMINATE</LI>
     * <LI>TRAP_BMU_METER_DROP</LI>
     * </UL>
     */
    uint8   term;

    /**
     * If non-zero then a frame that encounters the associated trap is
     * forwarded to the trap group ID. <b>NOTE:</b> If a trap
     * has the drop and term bits clear and trap_group=0 then the trap
     * is disabled - this means that even though the trap may be higher
     * priority than some other enabled trap it <b>MUST NOT</b> supress
     * the lower priority trap.
     */
    uint8   trap_group;

} tct_t;

/**
 * RANGE PREDICATE TABLE:
 * 
 * ranges are predicates defined over either a
 * tcp or udp source or destination port or a cvid or svid. this
 * table guides the construction of a 8b vector
 * where each bit corresponds to each predicate described here.
 * the resultant vector is available to the key builder to
 * construct a key.
 */
typedef struct cb_ipp_rpt_s {
    /**
     * Determines the header field over which the range predicate is to
     * be applied.
     * 3 - SVID_RANGE
     *     Selects the VID from an STAG (if present) over which to calculate
     *     a range predicate.
     * 0 - DP_RANGE
     *     Selects the Destination Port from a UDP or TCP header over which
     *     to calculate a range predicate.
     * 1 - SP_RANGE
     *     Selects the Destination Port from a UDP or TCP header over which
     *     to calculate a range predicate.
     * 2 - CVID_RANGE
     *     Selects the VID from a CTAG (if present) over which to calculate
     *     a range predicate.
     */
    uint8   source;

    /**
     * The high value in the closed range [lo, hi].
     */
    uint16  hi;

    /**
     * The low value in the closed range [lo, hi].
     */
    uint16  lo;

} rpt_t;

/**
 * PORT GROUP TABLE:
 * 
 * this table is indexed by the local port group identifier
 * which is obtained from the pp2lpg map.
 */
typedef struct cb_ipp_pgt_s {
    /**
     * Indicates that PPPoE (ETYPE=0x8864) is enabled on this port.
     * If clear and an Ethertype of 0x8864 is encountered, the
     * TAG parser will push the ethertype and payload native types onto the
     * stack and terminate parsing. If set the TAG parser will
     * push the Ethertype and PPPoE header native types onto the parse stack
     * and continue to determine if the PPPoE protocol field represents
     * a header it knows about (IPv4, IPv6 or MPLS as described above).
     */
    uint8   pppoe_en;

    /**
     * Indicates that MAC-in-MAC ITAGs (TPID=itag.tpid) are enabled on this
     * port.
     * If clear and an Ethertype matching that programmed in the itag_config
     * register is encountered, the TAG parser will push the ethertype and
     * payload native types onto the parse stack and terminate parsing.
     * If set the TAG parser will push the ITAG native type
     * <STRONG>and</STRONG> the MAC header native type onto the parse stack
     * and continue parsing at the TPID or EType that follows the MAC header.
     * <BR/>
     * The ITAG TPID is configurable because soft tags are not capable of
     * substituting for it given the nature of how the parse stack is
     * manipulated for ITAG support.
     */
    uint8   itag_en;

    /**
     * Set to enable tag parsing. Clear to disable. When enabled all
     * frames on the corresponding port group must Ethernet or Ethernet
     * over TLV encapsulated.
     */
    uint8   tag_parse_en;

    /**
     * Indicates that IPv4 (ETYPE=0x0800, PPP_PROTOCOL=0x0021) is enabled
     * on this port.
     * If clear and an Ethertype of 0x0800 or PPP_PROTOCOL of 0x0021 is
     * encountered, the TAG parser will push the ethertype and payload native
     * types onto the stack and then terminate parsing. If set the TAG
     * parser will push the IPv4 header native type onto the parse stack
     * and terminate parsing.
     * Note that the PPP_PROTOCOL can only be detected if %fref pppoe_en%
     * is set.
     */
    uint8   ipv4_en;

    /**
     * Source Logical Interface Context (SLIC) Map Enable. Indicates that
     * frames on this port group should be submitted to the SLIC Mapper.
     * Note that if the TAG parser is not enabled then the frame data
     * submitted will be raw frame data and will not include TLV data.
     * When the TAG parser is enabled an Ethernet key is created and it
     * and the frames subsequent payload are submitted to the SLIC
     * TCAM.
     */
    uint8   slic_map_en;

    /**
     * Indicates that CTAGs (TPID=0x8100) are enabled on this port.
     * If clear and and an Ethertype of 0x8100 is encountered, the
     * TAG parser will terminate parsing. If set the TAG parser will
     * push the CTAG native type onto the parse stack.
     */
    uint8   ctag_en;

    /**
     * Indicates which of up to 6 soft tags are enabled on this
     * port. The lsb corresponds to the zeroth soft tag register.
     */
    uint8   soft_tag_en;

    /**
     * Indicates that multicast MPLS (ETYPE=0x8848, PPP_PROTOCOL=0x0283)
     * is enabled on this port.
     * If clear and an Ethertype of 0x8848 or a PPP_PROTOCOL of 0x0283 is
     * encountered, the TAG parser will push the ethertype and payload
     * native types onto the stack and terminate parsing. If set the TAG
     * parser will push the multicast MPLS native type onto the parse stack
     * and terminate parsing.
     */
    uint8   mcmpls_en;

    /**
     * Indicates how many 16B words are in the metadata. Legal values are
     * 0, 1 or 2.
     */
    uint8   metadata_len;

    /**
     * Indicates that the LLC protocol is enabled on this port.
     * If clear and an Ethertype field is encountered with a value
     * less than or equal to llc_config.limit (default 1500), the TAG parser
     * will push the ethertype and payload native types onto the stack and
     * terminate parsing.
     * If set the TAG parser will push the LLC native type onto the parse
     * stack and terminate parsing. The DFP continues parsing of the
     * LLC header.
     */
    uint8   llc_en;

    /**
     * Indicates that PTP over Ethernet parsing is enabled on this port
     * (ETYPE=0x88F7). If clear and an Ethertype of 0x88F7 is encountered, the
     * TAG parser will terminate parsing and push the ethertype and the
     * payload native types onto the parse stack. If set the TAG parser will
     * push the Ethertype native type and the PTP header native type onto the
     * parse stack and terminate parsing.
     */
    uint8   ptp_en;

    /**
     * Indicates that Port Extender ETAGs (TPID=0x893F) are enabled on this
     * port.
     * If clear and an Ethertype of 0x893F is encountered, the
     * TAG parser will push the ethertype and payload native types onto the
     * parse stack and terminate parsing. If set the TAG parser will
     * push the ETAG native type onto the parse stack and continue parsing.
     */
    uint8   etag_en;

    /**
     * Indicates that STAGs (TPID=0x88A8) are enabled on this port.
     * If clear and an Ethertype of 0x88A8 is encountered, the
     * TAG parser will terminate parsing. If set the TAG parser will
     * push the CTAG native type onto the parse stack.
     */
    uint8   stag_en;

    /**
     * Indicates that IPv6 (ETYPE=0x86DD, PPP_PROTOCOL=0x0057)
     * is enabled on this port.
     * If clear and an Ethertype of 0x86DD or a PPP_Protocol of 0x0057 is
     * encountered, the TAG parser will terminate parsing with ethertype and
     * payload native types pushed onto the stack. If set the TAG
     * parser will push the IPv6 header native type onto the parse stack and
     * terminate parsing.
     */
    uint8   ipv6_en;

    /**
     * Set to enable TLV parsing. Clear to disable. When enabled all
     * frames on the corresponding port group must be TLV encapsulated.
     */
    uint8   tlv_parse_en;

    /**
     * Indicates that ARP parsing is enabled on this port (ETYPE=0x0806).
     * If clear and an Ethertype of 0x0806 is encountered, the
     * TAG parser will terminate parsing and push the ethertype and the
     * payload native types onto the parse stack. If set the TAG parser will
     * push the Ethertype native type and the ARP header native type onto the
     * parse stack and terminate parsing.
     */
    uint8   arp_en;

    /**
     * Indicates that unicast MPLS (ETYPE=0x8847, PPP_PROTOCOL=0x0281)
     * is enabled on this port.
     * If clear and an Ethertype of 0x8847 or a PPP_PROTOCOL of 0x0281
     * is encountered, the TAG parser will push the ethertype and payload
     * native types onto the stack and terminate parsing. If set the
     * TAG parser will push the unicast MPLS native type onto the parse
     * stack and terminate parsing.
     */
    uint8   ucmpls_en;

    /**
     * Indicates the number of 16B header words that the IPP will
     * read from the buffer minus 1. This includes the meta-data.
     * NOTE THAT THIS FIELD *MUST* BE SET TO AT LEAST THE SAME VALUE AS
     * metadata_len.
     */
    uint8   hdr_words_m1;

    /**
     * Indicates the length of the base protocol header (we assume a
     * fixed length). This indicates where the next protocol starts.
     */
    uint8   len0;

    /**
     * Indicates a second base protocol used by the port group. This
     * represents the type of the first frame header following proto0 (if
     * any). The hardware automatically appends this to the Parse
     * Descriptor before tag parsing with a location that is determined
     * by the last TLV parsed (if any) plus len0. If zero this is not
     * appended to the PD.
     * 1 - NT_TAG_INVALID
     *     Indicates an invalid tag. Should not appear on the parse stack.
     * 105 - NT_IPV6_FRAG_EH
     *     An IPV6 fragment extension header, 8B in length
     * 87 - NT_BLOB8
     *     Blob header type, 8 bytes in length
     * 99 - NT_BLOB20
     *     Blob header type, 20 bytes in length
     * 101 - NT_DIAG
     *     A 64B diag tag with ether type populated from
     *     config register, DEBUG_TAG_ETHERTYPE
     * 71 - NT_ICMP
     *     V4 or V6 Proto equals 1
     * 2 - NT_ING_TIMESTAMP
     * 0 - NT_NOP
     * 3 - NT_CTAG
     *     Recognized when a TPID is parsed that matches ctpid0 or ctpid1 as
     *     selected per Port Group.
     * 11 - NT_ITAG
     *     Recognized when a TPID is parsed that matches itpid. MAC-in-MAC
     *     Service Identifier Tag. Note that technically the ITAG is deemed to
     *     be 16B and contains the C-DMAC and C-SMAC of the encapsulated
     *     frame. We choose instead to view it as a 6B tag immediately followed
     *     by an implicit MAC header. So when we recognize an ITAG we push
     *     two types onto the stack (NT_ITAG/6, NT_MAC/6).
     * 15 - NT_SNAP
     *     Recognized by the Deep Frame Parser when the last parsed header is LLC
     *     and LLC.DSAP[7:1]=0x55, LLC.SSAP[7:1]=0x55 and LLC.CTRL[1:0]=3.
     * 255 - NT_HWH
     *     Hardware Header.
     * 17 - NT_COE4
     *     4B Broadcom Channel over Ethernet Tag. The COE4 tag needs to be
     *     configured as a soft tag if it is required as it is not supported
     *     natively by the TAG parser. However the Traffic Class and Drop
     *     Precedence translation process does extract PCP/DE fields from the
     *     header that matches this native type. Therefore when configuring
     *     recognition of COE4 the selected soft_tag must have its ntype field
     *     set to NT_COE4 for the TC/DP selection to work properly.
     * 27 - NT_IMP0
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 7 - NT_ETYPE
     *     This is implicitly pushed by the tag parser prior to a terminal
     *     header.
     * 5 - NT_STAG
     *     Recognized when a TPID is parsed that matches stpid0 or stpid1 as
     *     selected per Port Group.
     * 37 - NT_UTAG2
     *     Available for assignment as a soft tag.
     * 39 - NT_UTAG3
     *     Available for assignment as a soft tag.
     * 33 - NT_UTAG0
     *     Available for assignment as a soft tag.
     * 35 - NT_UTAG1
     *     Available for assignment as a soft tag.
     * 13 - NT_LLC
     *     TPID in [0, llc_config.limit]. If the TAG parser observes a
     *     TPID&lt;=llc_config.limit it can recognize an LLC header.
     *     The Deep Frame Parser has an LLC entry point and is capable of
     *     parsing beyond the LLC header.
     * 55 - NT_PPPOE
     *     Recognized by the tag parser when ETYPE=0x8864.
     * 45 - NT_PAYLOAD
     *     Default when the tag parser does not recognize etype/tpid or fails to
     *     recognize the LLC/SNAP header.
     * 253 - NT_RAW
     *     Only used by the key-builder to provide raw access to metadata and header
     *     data.
     * 23 - NT_CP2SW
     *     CB (CP/cascade) tag (CP2SW format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 67 - NT_UDP
     *     V4 or V6 Proto equals 17
     * 9 - NT_ETAG
     *     Recognized when a TPID is parsed that matches etpid.
     * 69 - NT_TCP
     *     V4 or V6 Proto equals 6
     * 89 - NT_BLOB10
     *     Blob header type, 10 bytes in length
     * 95 - NT_BLOB16
     *     Blob header type, 16 bytes in length
     * 93 - NT_BLOB14
     *     Blob header type, 14 bytes in length
     * 49 - NT_IPV6
     *     Recognized by the tag parser when ETYPE=0x86DD. Also recognized by the
     *     deep frame parser when the IP protocol field is 41 or the PPPoE protocol
     *     field is 0x0057.
     * 97 - NT_BLOB18
     *     Blob header type, 18 bytes in length
     * 41 - NT_UTAG4
     *     Available for assignment as a soft tag.
     * 53 - NT_MCMPLS
     *     Recognized by the tag parser when ETYPE=0x8848. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0283.
     * 43 - NT_UTAG5
     *     Available for assignment as a soft tag.
     * 12 - NT_EGR_TIMESTAMP
     * 77 - NT_ARP
     *     Address Resolution Protocol
     * 103 - NT_IPV6_EH
     *     An IPV6 extension header of variable length
     * 73 - NT_IGMP
     *     V4 or V6 Proto equals 2
     * 81 - NT_BLOB2
     *     Blob header type, 2 bytes in length
     * 83 - NT_BLOB4
     *     Blob header type, 4 bytes in length
     * 47 - NT_IPV4
     *     Recognized by the tag parser when ETYPE=0x0800. Also recognized by the
     *     deep frame parser when the IP protocol field is 4 or the PPPoE protocol
     *     field is 0x0021.
     * 85 - NT_BLOB6
     *     Blob header type, 6 bytes in length
     * 51 - NT_UCMPLS
     *     Recognized by the tag parser when ETYPE=0x8847. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0281.
     * 91 - NT_BLOB12
     *     Blob header type, 12 bytes in length
     * 75 - NT_PTP
     *     Precision Time Protocol
     * 21 - NT_SW2CP
     *     CB (CP/cascade) tag (SW2CP format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 31 - NT_MAC
     *     MAC header. This is the 12B header consisting of the DMAC and SMAC.
     * 29 - NT_IMP1
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 19 - NT_COE8
     *     8B Broadcom Channel over Ethernet Tag. Like the COE4 tag, the COE8
     *     tag is not natively supported by the TAG parser and requires a soft
     *     tag if it is to be recognized. Again the TC and DP translation process
     *     does extract priority information from the header marked with this
     *     native type. Accordingly when a soft_tag is configured to recognize
     *     COE8 then its ntype field should be set to NT_COE8.
     * 107 - NT_IPV6_ICMP
     *     IPV6 Internet Control Message.
     * 4 - NT_MIRROR
     * 25 - NT_BRCM
     *     Proto1 can be used to recognize a BRCM header. If proto1 is BRCM
     *     header then this is the NT pushed on to the PD. A specific NT is
     *     required for BRCM header so that it can be recognized and processed
     *     by the FP downstream. If proto0/proto1 are not BRCM header then
     *     NT_IMP0/NT_IMP1 are pushed on to the PD. These are not processed
     *     by the FP.
     */
    uint8   proto1;

    /**
     * Indicates the base protocol used by the port group. This
     * represents the type of the first frame header following the TLVs
     * (if any). The hardware automatically appends this to the Parse
     * Descriptor after TLV parsing and before tag parsing with a
     * location that is determined by the last TLV parsed (zero if none).
     * If zero nothing is appended to the PD.
     * 1 - NT_TAG_INVALID
     *     Indicates an invalid tag. Should not appear on the parse stack.
     * 105 - NT_IPV6_FRAG_EH
     *     An IPV6 fragment extension header, 8B in length
     * 87 - NT_BLOB8
     *     Blob header type, 8 bytes in length
     * 99 - NT_BLOB20
     *     Blob header type, 20 bytes in length
     * 101 - NT_DIAG
     *     A 64B diag tag with ether type populated from
     *     config register, DEBUG_TAG_ETHERTYPE
     * 71 - NT_ICMP
     *     V4 or V6 Proto equals 1
     * 2 - NT_ING_TIMESTAMP
     * 0 - NT_NOP
     * 3 - NT_CTAG
     *     Recognized when a TPID is parsed that matches ctpid0 or ctpid1 as
     *     selected per Port Group.
     * 11 - NT_ITAG
     *     Recognized when a TPID is parsed that matches itpid. MAC-in-MAC
     *     Service Identifier Tag. Note that technically the ITAG is deemed to
     *     be 16B and contains the C-DMAC and C-SMAC of the encapsulated
     *     frame. We choose instead to view it as a 6B tag immediately followed
     *     by an implicit MAC header. So when we recognize an ITAG we push
     *     two types onto the stack (NT_ITAG/6, NT_MAC/6).
     * 15 - NT_SNAP
     *     Recognized by the Deep Frame Parser when the last parsed header is LLC
     *     and LLC.DSAP[7:1]=0x55, LLC.SSAP[7:1]=0x55 and LLC.CTRL[1:0]=3.
     * 255 - NT_HWH
     *     Hardware Header.
     * 17 - NT_COE4
     *     4B Broadcom Channel over Ethernet Tag. The COE4 tag needs to be
     *     configured as a soft tag if it is required as it is not supported
     *     natively by the TAG parser. However the Traffic Class and Drop
     *     Precedence translation process does extract PCP/DE fields from the
     *     header that matches this native type. Therefore when configuring
     *     recognition of COE4 the selected soft_tag must have its ntype field
     *     set to NT_COE4 for the TC/DP selection to work properly.
     * 27 - NT_IMP0
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 7 - NT_ETYPE
     *     This is implicitly pushed by the tag parser prior to a terminal
     *     header.
     * 5 - NT_STAG
     *     Recognized when a TPID is parsed that matches stpid0 or stpid1 as
     *     selected per Port Group.
     * 37 - NT_UTAG2
     *     Available for assignment as a soft tag.
     * 39 - NT_UTAG3
     *     Available for assignment as a soft tag.
     * 33 - NT_UTAG0
     *     Available for assignment as a soft tag.
     * 35 - NT_UTAG1
     *     Available for assignment as a soft tag.
     * 13 - NT_LLC
     *     TPID in [0, llc_config.limit]. If the TAG parser observes a
     *     TPID&lt;=llc_config.limit it can recognize an LLC header.
     *     The Deep Frame Parser has an LLC entry point and is capable of
     *     parsing beyond the LLC header.
     * 55 - NT_PPPOE
     *     Recognized by the tag parser when ETYPE=0x8864.
     * 45 - NT_PAYLOAD
     *     Default when the tag parser does not recognize etype/tpid or fails to
     *     recognize the LLC/SNAP header.
     * 253 - NT_RAW
     *     Only used by the key-builder to provide raw access to metadata and header
     *     data.
     * 23 - NT_CP2SW
     *     CB (CP/cascade) tag (CP2SW format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 67 - NT_UDP
     *     V4 or V6 Proto equals 17
     * 9 - NT_ETAG
     *     Recognized when a TPID is parsed that matches etpid.
     * 69 - NT_TCP
     *     V4 or V6 Proto equals 6
     * 89 - NT_BLOB10
     *     Blob header type, 10 bytes in length
     * 95 - NT_BLOB16
     *     Blob header type, 16 bytes in length
     * 93 - NT_BLOB14
     *     Blob header type, 14 bytes in length
     * 49 - NT_IPV6
     *     Recognized by the tag parser when ETYPE=0x86DD. Also recognized by the
     *     deep frame parser when the IP protocol field is 41 or the PPPoE protocol
     *     field is 0x0057.
     * 97 - NT_BLOB18
     *     Blob header type, 18 bytes in length
     * 41 - NT_UTAG4
     *     Available for assignment as a soft tag.
     * 53 - NT_MCMPLS
     *     Recognized by the tag parser when ETYPE=0x8848. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0283.
     * 43 - NT_UTAG5
     *     Available for assignment as a soft tag.
     * 12 - NT_EGR_TIMESTAMP
     * 77 - NT_ARP
     *     Address Resolution Protocol
     * 103 - NT_IPV6_EH
     *     An IPV6 extension header of variable length
     * 73 - NT_IGMP
     *     V4 or V6 Proto equals 2
     * 81 - NT_BLOB2
     *     Blob header type, 2 bytes in length
     * 83 - NT_BLOB4
     *     Blob header type, 4 bytes in length
     * 47 - NT_IPV4
     *     Recognized by the tag parser when ETYPE=0x0800. Also recognized by the
     *     deep frame parser when the IP protocol field is 4 or the PPPoE protocol
     *     field is 0x0021.
     * 85 - NT_BLOB6
     *     Blob header type, 6 bytes in length
     * 51 - NT_UCMPLS
     *     Recognized by the tag parser when ETYPE=0x8847. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0281.
     * 91 - NT_BLOB12
     *     Blob header type, 12 bytes in length
     * 75 - NT_PTP
     *     Precision Time Protocol
     * 21 - NT_SW2CP
     *     CB (CP/cascade) tag (SW2CP format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 31 - NT_MAC
     *     MAC header. This is the 12B header consisting of the DMAC and SMAC.
     * 29 - NT_IMP1
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 19 - NT_COE8
     *     8B Broadcom Channel over Ethernet Tag. Like the COE4 tag, the COE8
     *     tag is not natively supported by the TAG parser and requires a soft
     *     tag if it is to be recognized. Again the TC and DP translation process
     *     does extract priority information from the header marked with this
     *     native type. Accordingly when a soft_tag is configured to recognize
     *     COE8 then its ntype field should be set to NT_COE8.
     * 107 - NT_IPV6_ICMP
     *     IPV6 Internet Control Message.
     * 4 - NT_MIRROR
     * 25 - NT_BRCM
     *     Proto1 can be used to recognize a BRCM header. If proto1 is BRCM
     *     header then this is the NT pushed on to the PD. A specific NT is
     *     required for BRCM header so that it can be recognized and processed
     *     by the FP downstream. If proto0/proto1 are not BRCM header then
     *     NT_IMP0/NT_IMP1 are pushed on to the PD. These are not processed
     *     by the FP.
     */
    uint8   proto0;

    /**
     * Indicates the length of the base protocol header (we assume a
     * fixed length). This indicates where the next protocol starts.
     */
    uint8   len1;

    /**
     * The source to use when source 2 is available. I know - why, right?
     */
    uint8   arb4;

    /**
     * The source to use when source 0 is available.
     */
    uint8   arb1;

    /**
     * Indicates which source to use for priority mapping when all three are
     * available. Note that values of 0, 1 and 2 correspond to the source
     * as determined by the selection in the srcN fields and the associated
     * pri_baseN to be used. A value of 3 will illicit the use of the
     * default TC and DP.
     */
    uint8   arb7;

    /**
     * The source to use when sources 1 and 0 but not 2 are available.
     */
    uint8   arb3;

    /**
     * Indicates a source for TC/DP mapping.
     * 7 - V4_DSCP
     *     The 6b DSCP field of an IPv4 header (most significant 6b of the TOS
     *     field) is selected.
     * 10 - MPLS_EXP
     *     The 3b EXP field of the first MPLS label is selected.
     * 0 - NONE
     *     No source selected.
     * 3 - ETAG_PCP_DEI
     *     The 3b PCP and 1b DEI fields of the ETAG are selected.
     * 8 - V6_DSCP
     *     The 6b DSCP field of an IPv6 header (most significant 6b of the Traffic
     *     Class field) is selected.
     * 5 - COE4_PRI
     *     The 3b priority field of the 4B Broadcom Channelization over Ethernet
     *     subport tag are selected.
     * 1 - CTAG_PCP_DEI
     *     The 3b PCP and 1b DEI fields of the CTAG are selected if the CTAG is
     *     parsed.
     * 2 - STAG_PCP_DEI
     *     The 3b PCP and 1b DEI fields of the STAG are selected.
     * 6 - COE8_C_PRI
     *     The 2b colour field and the 3b priority field of the 8B Broadcom
     *     Channelization over Ethernet subport tag are selected.
     * 4 - ITAG_PCP_DEI
     *     The 3b PCP 1b and DEI fields of the ITAG are selected.
     * 9 - IP_DSCP
     *     Context aware selection of 6b DSCP. Hardware modifies the selection
     *     wrt V4 versus V6 header parse.
     */
    uint8   src2;

    /**
     * The source to use when source 1 is available.
     */
    uint8   arb2;

    /**
     * Indicates a source for TC/DP mapping.
     * 7 - V4_DSCP
     *     The 6b DSCP field of an IPv4 header (most significant 6b of the TOS
     *     field) is selected.
     * 10 - MPLS_EXP
     *     The 3b EXP field of the first MPLS label is selected.
     * 0 - NONE
     *     No source selected.
     * 3 - ETAG_PCP_DEI
     *     The 3b PCP and 1b DEI fields of the ETAG are selected.
     * 8 - V6_DSCP
     *     The 6b DSCP field of an IPv6 header (most significant 6b of the Traffic
     *     Class field) is selected.
     * 5 - COE4_PRI
     *     The 3b priority field of the 4B Broadcom Channelization over Ethernet
     *     subport tag are selected.
     * 1 - CTAG_PCP_DEI
     *     The 3b PCP and 1b DEI fields of the CTAG are selected if the CTAG is
     *     parsed.
     * 2 - STAG_PCP_DEI
     *     The 3b PCP and 1b DEI fields of the STAG are selected.
     * 6 - COE8_C_PRI
     *     The 2b colour field and the 3b priority field of the 8B Broadcom
     *     Channelization over Ethernet subport tag are selected.
     * 4 - ITAG_PCP_DEI
     *     The 3b PCP 1b and DEI fields of the ITAG are selected.
     * 9 - IP_DSCP
     *     Context aware selection of 6b DSCP. Hardware modifies the selection
     *     wrt V4 versus V6 header parse.
     */
    uint8   src0;

    /**
     * Indicates a source for TC/DP mapping.
     * 7 - V4_DSCP
     *     The 6b DSCP field of an IPv4 header (most significant 6b of the TOS
     *     field) is selected.
     * 10 - MPLS_EXP
     *     The 3b EXP field of the first MPLS label is selected.
     * 0 - NONE
     *     No source selected.
     * 3 - ETAG_PCP_DEI
     *     The 3b PCP and 1b DEI fields of the ETAG are selected.
     * 8 - V6_DSCP
     *     The 6b DSCP field of an IPv6 header (most significant 6b of the Traffic
     *     Class field) is selected.
     * 5 - COE4_PRI
     *     The 3b priority field of the 4B Broadcom Channelization over Ethernet
     *     subport tag are selected.
     * 1 - CTAG_PCP_DEI
     *     The 3b PCP and 1b DEI fields of the CTAG are selected if the CTAG is
     *     parsed.
     * 2 - STAG_PCP_DEI
     *     The 3b PCP and 1b DEI fields of the STAG are selected.
     * 6 - COE8_C_PRI
     *     The 2b colour field and the 3b priority field of the 8B Broadcom
     *     Channelization over Ethernet subport tag are selected.
     * 4 - ITAG_PCP_DEI
     *     The 3b PCP 1b and DEI fields of the ITAG are selected.
     * 9 - IP_DSCP
     *     Context aware selection of 6b DSCP. Hardware modifies the selection
     *     wrt V4 versus V6 header parse.
     */
    uint8   src1;

    /**
     * The source to use when none is available.
     */
    uint8   arb0;

    /**
     * The source to use when sources 2 and 1 but not 0 are available. Note
     * that even though source 0 is not available the logic behaves as if it
     * were and had a value of zero. So selecting 0 as a winner would result
     * in a TC and DP derived from entry zero of the map associated with
     * source 0.
     */
    uint8   arb6;

    /**
     * The source to use when sources 2 and 0 but not 1 are available.
     */
    uint8   arb5;

    /**
     * Similar to pri_base2 and pri_base1 but selected by a value of 0 in
     * the arb array entry and is offset by src0.
     * The default value for pri_base0 is set to accomodate a 64 entry DSCP
     * remapping table positioned after a set of 16 {PCP, DEI}
     * remapping tables within the CPMT.
     */
    uint16  pri_base0;

    /**
     * Default Traffic Class. Selected by a value of 3 in the arb array
     * entry corresponding to the presence of the selected priority
     * information sources.
     */
    uint8   default_tc;

    /**
     * Default Drop Precedence. Selected by a value of 3 in the arb array
     * entry corresponding to the presence of the selected priority
     * information sources.
     * 3 - DROP
     *     Used as a drop indicator.
     * 0 - GREEN
     *     Indicates a packet with low drop precedence.
     * 2 - RED
     *     The highest drop precedence.
     * 1 - YELLOW
     *     Indicates a packet of medium drop precedence.
     */
    uint8   default_dp;

    /**
     * Similar to pri_base2 but selected by a value of 1 in the arb array
     * entry and is offset using the src1 extracted priority information.
     * The default value for pri_base1 is 16 times the index of the PGT
     * entry.
     */
    uint16  pri_base1;

    /**
     * A base index into the Canonical Priority Mapping Table (CPMT) which
     * is selected by a value of 2 in the arb array entry corresponding to
     * the presence of the selected priority information sources. The
     * priority information extracted for src2 is added to this base to
     * determine the canonical TC and DP for the frame.
     */
    uint16  pri_base2;

    /**
     * The Global Flow Control Domain to be used for TC=3.
     */
    uint8   fcd3;

    /**
     * The Global Flow Control Domain to be used for TC=4.
     */
    uint8   fcd4;

    /**
     * The Global Flow Control Domain to be used for TC=2.
     */
    uint8   fcd2;

    /**
     * The Global Flow Control Domain to be used for TC=1.
     */
    uint8   fcd1;

    /**
     * The Global Flow Control Domain to be used for TC=5.
     */
    uint8   fcd5;

    /**
     * The Global Flow Control Domain to be used for TC=6.
     */
    uint8   fcd6;

    /**
     * The Global Flow Control Domain to be used for TC=7.
     */
    uint8   fcd7;

    /**
     * The Global Flow Control Domain to be used for TC=0.
     */
    uint8   fcd0;

    /**
     * Indicates the mirror group to use for this port group. A value of
     * zero indicates no ingress port mirroring.
     */
    uint8   mirror;

    /**
     * Uncommitted bits fed to the SLIC TCAM during SLIC mapping.
     */
    uint16  pepper;

    /**
     * When PV2LI mapping is enabled in the FPSLICT this field
     * indicates which tag (C or S) is to provide the VID for that
     * mapping. If the outermost tag is not the selected tag then the
     * frame is considered untagged and the default_vid is
     * used. Additionally if the selected tag has a VID of 0 then it is
     * also considered untagged and the default_vid is used.
     * 0 - CTAG_VID
     *     If the outermost tag is a CTAG then use the CTAG VID
     *     to determine a PV SLI.
     * 1 - STAG_VID
     *     If the outermost tag is an STAG then use the STAG VID
     *     to determine a PV SLI.
     */
    uint8   vid_src;

    /**
     * Default VLAN Identifier. If a packet arrives without a tag then this
     * value will be used as the packets VID for the purposes of PV2LI
     * mapping. Note that a packet is also considered untagged
     * if it has a valid tag with a VID of zero (i.e. it is priority tagged).
     */
    uint16  default_vid;

    /**
     * Default Source Logical Interface. This is the lowest priority
     * source for an SLIID. This is used only when none of the SLI
     * mapping mechanisms (PV2LI, LI Map 0 or 1) are enabled and the
     * default_sli field in the assigned SLIC is zero.
     * This initializes to a PV-type SLI with PGID=port and VSI=0. This
     * is the appropriate setting for unmanaged mode.
     */
    uint32  default_sli;

    /**
     * Default Source Logical Interface Context Identifier. In the
     * event that SLIC mapping is disabled or in the event that it is
     * enabled but no mapping is found then this value becomes the SLICID
     * associated with the frame.
     * This is also the assigned SLICID when buffer metadata is disabled
     * (usually so for unmanaged mode).
     */
    uint8   default_slicid;

    /**
     * When set the Forwarding Processors Deep Frame Parser is enabled.
     */
    uint8   dfp_en;

    /**
     * Drop on Unicast Lookup Fail. If the destination key is
     * classified as a unicast key and we fail to find it in the
     * forwarding table then if this bit is set we will drop the frame
     * else we will forward it to the default destination group.
     * </P><P>
     * Note that dropping on Unicast Lookup Failure is configurable here
     * (per port), in the VSIT (per VSI) and as a global trap. Whether a
     * particular frame is dropped when encountering this condition is
     * determined by the logical ORing of these three drop configurations.
     */
    uint8   drop_ulf;

    /**
     * When this bit is set the IPP meters set the DP that is forwarded
     * to the PQM otherwise the CFPs result sets the DP.
     * Note that when the IPP meters indicate drop then the CFP result is
     * unconditionally ignored.
     * Note also that the CFPs DP is fed to the IPP meters and may be used
     * in a colour aware configuration of the IPP meters.
     */
    uint8   ipp_meter_sets_dp;

    /**
     * The Source Port Group Identifier is the global name for a port in
     * configurations with two or more devices cascaded together. This
     * initializes to the PGT index - that is, it is n for PGT entry n.
     */
    uint8   spgid;

    /**
     * Drop on Source Lookup Fail. This field controls forwarding
     * behavior in the event of a source key miss. If the source key is
     * not found and this bit is set then we will drop the frame else we
     * will forward as per destination key lookup results.
     * </P><P>
     * drop_slf is configurable per port, per VSI and globally with the
     * final drop condition determined by the OR of all three.
     */
    uint8   drop_slf;

    /**
     * Drop on Multicast Lookup Fail. If the destination key is
     * classified as a multicast key and we fail to find it in the
     * forwarding table then if this bit is set we will drop the frame
     * else we will forward it to the default destination group.
     * </P><P>
     * As with drop_ulf, Multicast Lookup Fail drops are configured per
     * port, per VSI and globally with the final drop condition
     * determined by the OR of all three.
     */
    uint8   drop_mlf;

    /**
     * Drop broadcast frames. Specific to Ethernet switching when this
     * bit is set frames with a DMAC of ff:ff:ff:ff:ff:ff are dropped.
     * </P><P>
     * drop_bcast is configurable per port, per VSI and globally with
     * the final drop condition determined by the OR of all three.
     */
    uint8   drop_bcast;

    /**
     * The IPP Receive Processor (RP) does some initial processing on a
     * packet. By default the RP receives just the first 32B of a packet.
     * This register indicates how many additional words are sent to it.
     * The RP must receive sufficient packet data to parse all TLVs and
     * its Ethernet header (if enabled), however it behooves us from a
     * power point of view to only send it as much data as is necessary
     * and no more. The number of words sent to the RP is rp_extra+2.
     * </P><P>
     * The default value is sufficient for unmanaged mode operation with
     * no TLVs. It will need to be increased for deeper processing.
     * If the RP cannot complete Ethernet tag parsing it will drop the
     * packet.
     * </P><P>
     * This field should *not* be set to a value greater than
     * 14.
     */
    uint8   rp_extra;

} pgt_t;

/**
 * LOGICAL TO PHYSICAL PAGE TABLE:
 * 
 * the pmi page table is indexed by logical page number and
 * returns a physical page number to be used in accessing the cmm. a
 * logical 16b word address consists of a 13b
 * page number and a 4b page offset. this 4608 entry table
 * provides up to 1152kb of logical
 * address space to the pmi. note that a value of zero returned
 * for phypagevld field of the page table means no physical
 * page has been mapped to the logical page.
 */
typedef struct cb_pmi_pmipage_s {
    /**
     * Indicates if the logical to physical page mapping is enabled and valid. 
     * 
     */
    uint8   phypagevld;

    /**
     * Physical Page Number. The 256 byte physical page
     * associated with the Logical Page Number used to index this table.
     */
    uint16  phypage;

} pmipage_t;

/**
 * GLOBAL FLOW CONTROL DOMAIN CONFIGURATION TABLE:
 * 
 * similar to flow control domain configuration described above except
 * applied to a set of 8 global domains.
 */
typedef struct cb_bmu_gfcd_config_s {
    /**
     * The threshold at which packets with RED drop precedence
     * are dropped. Flow control remains asserted.
     */
    uint16  thresh1;

    /**
     * The threshold at which flow control is asserted.
     */
    uint16  thresh0;

    /**
     * The threshold at which all packets from the associated
     * ingress are dropped. Flow control remains asserted.
     */
    uint16  thresh3;

    /**
     * The threshold at which packets with yellow drop precedence
     * are dropped. Flow control remains asserted.
     */
    uint16  thresh2;

    /**
     * GFCD counter enable. If set to 1, enables GFCD page counters.
     */
    uint8   counter_enable;

    /**
     * Global flow control enable. If set to 1, enables GFCD Xoff.
     * This bit is dont care if counter_enable is set to zero.
     */
    uint8   gfc_enable;

    /**
     * The point to which a flow controlled ingress buffer occupancy
     * must fall to before flow control goes from asserted to negated.
     */
    uint16  hysteresis;

    /**
     * This register field defines the traffic class for physical port 3.
     */
    uint8   tc_pp_bmp_3;

    /**
     * This register field defines the traffic class for physical port 2.
     */
    uint8   tc_pp_bmp_2;

    /**
     * This register field defines the traffic class for physical port 1.
     */
    uint8   tc_pp_bmp_1;

    /**
     * This register field defines the traffic class for physical port 0.
     */
    uint8   tc_pp_bmp_0;

    /**
     * This register field defines the traffic class for physical port 5.
     */
    uint8   tc_pp_bmp_5;

    /**
     * This register field defines the traffic class for physical port 7.
     */
    uint8   tc_pp_bmp_7;

    /**
     * This register field defines the traffic class for physical port 4.
     */
    uint8   tc_pp_bmp_4;

    /**
     * This register field defines the traffic class for physical port 6.
     */
    uint8   tc_pp_bmp_6;

    /**
     * This register field defines the traffic class for physical port 9.
     */
    uint8   tc_pp_bmp_9;

    /**
     * This register field defines the traffic class for physical port 8.
     */
    uint8   tc_pp_bmp_8;

    /**
     * This register field defines the traffic class for physical port 10.
     */
    uint8   tc_pp_bmp_10;

    /**
     * This register field defines the traffic class for physical port 11.
     */
    uint8   tc_pp_bmp_11;

    /**
     * This register field defines the traffic class for physical port 14.
     */
    uint8   tc_pp_bmp_14;

    /**
     * This register field defines the traffic class for physical port 15.
     */
    uint8   tc_pp_bmp_15;

    /**
     * This register field defines the traffic class for physical port 13.
     */
    uint8   tc_pp_bmp_13;

    /**
     * This register field defines the traffic class for physical port 12.
     */
    uint8   tc_pp_bmp_12;

} gfcd_config_t;

/**
 * ADMISSION PARAMETER TABLE:
 * 
 * this table is indexed by the concatenation of a frames dp with its
 * queue domain (qd) and selected admission profile (i.e. {dp, qd, ap}).
 * it contains parameters that govern admission of a packet.
 * a frame selects admission parameters from this table based on its drop
 * precedence, queue domain and admission profile.
 */
typedef struct cb_pqm_apt_s {
    /**
     * Drop Threshold beyond which buffer pointers will be dropped. When the
     * instantaneous admission queue domain occupancy (in pages) is greater
     * than this threshold then that frame is dropped otherwise it is accepted.
     * To avoid favoring small packets, PQM will not take the current enqueue
     * length into account while making an admit desicion. If admitted,
     * the instantaneous admission queue domain occupancy is incremented with
     * the length of the current enqueue. So, the drop_thresh should be set
     * to 1 MTU (48 pages) less than the required threshold.
     */
    uint16  drop_thresh;

    /**
     * This represents a slope parameter (m) for WRED. Together with
     * an intercept parameter (c) this defines the drop probability for
     * a WRED eligible frame as min((2**20)-1, max(0, (2**s)*(m*x+c)) where
     * x is the Exponential Weighted Moving Average (EWMA) of the queue
     * domains occupancy and s is a scaling factor (from the WRED Parameter
     * Table - WPT).
     * </P><P>
     * The occupancy EWMA is calculated per queue domain periodically as
     * x[i] = (1-2**-g)*x[i-1] + (2**-g)*o where i is the iteration, o is the
     * instantaneous queue domain occupancy and g is a gain parameter
     * (from WPT above). Since o can be shifted right by up to 7 bits
     * (all that can be represented by WPT.g) then that many fractional
     * bits are required in the EWMA calculation and are thus required in
     * the state variable x relative to o. Since o is maintained in units
     * of buffer pages, x will have 20b resolution.
     * </P><P>
     * The first term in the mx+c calculation for drop probability shall
     * not exceed 28b of resolution as m is constrained to just 8b in this
     * map. The second term (c) is constrained to 21b where the msb is a
     * sign-bit as described below. Thus the result of the entire
     * calculation cannot exceed 29b.
     * </P><P>
     * Note that the default of m=0 and c=0 amounts to WRED being
     * disabled.
     */
    uint8   wred_m;

    /**
     * This represents a WRED intercept parameter (c) which is used
     * with the slope parameter in the manner described above. Note that
     * the intercept parameter is a signed number and must be
     * sign-extended for addition. Note also that the actual intercept
     * used in the linear calculation above shall be this value shifted
     * left by 7 bits.
     */
    uint16  wred_c;

} apt_t;

/**
 * GLOBAL FLOW CONTROL DOMAIN PAGE COUNTER:
 * 
 * page counter per global flow control domain id.
 */
typedef struct cb_bmu_gfcd_cntr_s {
    /**
     * Each entry provides software access to a GFCD page counter
     * indexed by global flow control Domain ID.
     */
    uint16  page_cnt;

} gfcd_cntr_t;

/**
 * 
 * this table remaps source port group to physical ports.
 * note, this field is used by the fcd and meter blocks.
 */
typedef struct cb_bmu_spg_pp_bmp_config_s {
    /**
     * Physical ports corresponding to Source Port Group.
     */
    uint16  spg_pp_bmp;

} spg_pp_bmp_config_t;

/**
 * DESTINATION GROUP TABLE:
 * 
 * this table is indexed by the destination group id (dgid).
 * it contains information used to multicast a frame.
 */
typedef struct cb_pqm_dgt_s {
    /**
     * The lilt_type bit indicates the nature of the structure that the
     * lilt_ndx (below) points to in the Logical Interface Link Table (LILT).
     * lilt_type=0 implies that the lilt_ndx is the base of an array of
     * Destination Local Logical Interface Identifiers (DLLIID).
     * An LLIID is a compact
     * representation of an LIID given that the VSI is known.
     * <BR/>
     * lilt_type=1 implies that the lilt_ndx is the base of an array of
     * linked list elements each of which contain a DLIID and an index
     * to the next element in the list.
     * <BR/>
     * Note that the number of entries in the target array is determined
     * by the number of bits set in the port group fanout vector.
     */
    uint8   lilt_type;

    /**
     * The Logical Interface Link Table Index. This is an offset
     * into the LILT at which an array of DLIs are to be found.
     * <BR/>
     * If lilt_type=0 and lilt_ndx=0 in the DGT entry then there is no LILT
     * entry and were looking at a straightforward L2 multicast group
     * with PV-Type DLIs only. The component DLIIDs are derived using the
     * VSI for that group and DPGs derived from the PGFOV.
     */
    uint16  lilt_ndx;

    /**
     * The number of entries in the target array is determined by the
     * number of ones in the pgfov field. The entries in the array are
     * identified relative to the DPG at which a particular frame is
     * egressing from. It determines how to distribute a frame to
     * multiple egress queues.
     * It is used to enable an efficient representation of the set of
     * Destination Logical Interfaces.
     */
    uint16  pgfov;

} dgt_t;

/**
 * 
 * the gspg2ig is indexed by the global spg and returns the
 * isolation group. isolation groups are used to implement
 * private vlans. there are three types of private vlan ports:
 * <ul>
 * <li>promiscuous ports that can communicate with all ports.
 * these ports are assigned to ig=0.
 * </li>
 * <li>isolated ports which can only communicate with promiscuous
 * ports. these ports are assigned to ig 15.
 * </li>
 * <li>community ports that can only communicate with each other and
 * promiscuous ports. up to 2 community
 * port groups may be defined using ig 1 through
 * 14.
 * </li>
 * </ul>
 */
typedef struct cb_ipp_gspg2ig_s {
    /**
     * Indicates the isolation group to which the port group belongs.
     */
    uint8   ig;

} gspg2ig_t;

/**
 * 
 * calendar and port mapping
 */
typedef struct cb_epp_epp_calendar_s {
    /**
     * Port number to be used for slot 0
     */
    uint8   slot_port;

} epp_calendar_t;

/**
 * GENERIC HASH TABLE:
 * 
 * generic hash tables are configured via the ghtdt. they may be
 * assigned a role in either logical interface mapping or forward
 * mapping. note that ght table 8 is reserved - it
 * has no corresponding ghtdt entry to describe it.
 */
typedef struct cb_itm_ght_s {
    /**
     * Bits 0 thru 31 of the key.
     */
    uint32  key_31_0;

    /**
     * Bits 32 thru 63 of the key.
     */
    uint32  key_63_32;

    /**
     * Bits 64 thru 95 of the key.
     */
    uint32  key_95_64;

    /**
     * Contains the N-field of an N-type SLI or the VSI field of a PV-type
     * SLI. The SPG is assumed available when the SLI is of PV-type.
     */
    uint16  n_or_vsi;

    /**
     * Indicates a valid entry when set. If clear then the entry is considered
     * empty. One can think of the valid bit as being part of the key.
     */
    uint8   valid;

    /**
     * The key can be up to 111b in length. This field always holds the most
     * significant 15b of a key.
     */
    uint32  key_113_96;

    /**
     * Indicates the type of the SLI. Zero indicates N-type, one indicates
     * PV-type.
     */
    uint8   li_type;

} ght_t;

/**
 * LIN TYPE SOURCE LOGICAL INTERFACE TO VIRTUAL SWITCHING INSTANCE MAP:
 * 
 * the lin2vsi table is used when the sli contains a valid n
 * field. it is simply indexed by sli.n and returns the vsi.
 * it also provides a mechanism to assign drop precedence and
 * traffic class to a frame associated with the sli.
 */
typedef struct cb_ipp_lin2vsi_s {
    /**
     * Default Traffic Class. Used as a function of the use_tc field.
     */
    uint8   tc;

    /**
     * Drop Precedence. Used as a function of the use_dp field.
     * 3 - DROP
     *     Used as a drop indicator.
     * 0 - GREEN
     *     Indicates a packet with low drop precedence.
     * 2 - RED
     *     The highest drop precedence.
     * 1 - YELLOW
     *     Indicates a packet of medium drop precedence.
     */
    uint8   dp;

    /**
     * If set then the tc field is assigned as the TC of the
     * frame.
     */
    uint8   use_tc;

    /**
     * If set then the dp field is assigned as the DP of the frame.
     */
    uint8   use_dp;

    /**
     * The Virtual Switch Instance that implements the VLAN represented
     * by SLI.N.
     */
    uint16  vsi;

} lin2vsi_t;

/**
 * 
 * burst size and rate config for committed bucket
 */
typedef struct cb_cfp_profile_s {
    /**
     * committed burst size exponent
     */
    uint8   cbs_exp;

    /**
     * committed burst size mantissa
     */
    uint8   cbs_mantissa;

    /**
     * committed information rate mantissa
     */
    uint16  cir_mantissa;

    /**
     * committed information rate exponent
     */
    uint8   cir_exp;

    /**
     * excess information rate exponent
     */
    uint8   eir_exp;

    /**
     * excess burst size exponent
     */
    uint8   ebs_exp;

    /**
     * excess information rate mantissa
     */
    uint16  eir_mantissa;

    /**
     * excess burst size mantissa
     */
    uint8   ebs_mantissa;

    /**
     * if set, the drop bit will be set if the resulting color is red
     */
    uint8   drop_on_red;

    /**
     * when set, mtr_req_length is ignored, and config_pkt_mode_len is used
     * instead
     */
    uint8   pkt_mode;

    /**
     * if set, a packet conforms to bktc only if the number of tokens is greater
     * than or equal to the packet length; otherwise the packet conforms as long
     * as the token count is non-negative
     */
    uint8   bktc_strict;

    /**
     * if set, a packet conforms to bkte only if the number of tokens is greater
     * than or equal to the packet length; otherwise the packet conforms as long
     * as the token count is non-negative
     */
    uint8   bkte_strict;

    /**
     * coupling flag
     * tokens being added to bktc will be diverted to bkte if bktc is full
     */
    uint8   cf;

    /**
     * if set, both bktc and bkte must have sufficient tokens to color a packet
     * green; otherwise only bktc must have sufficient tokens
     */
    uint8   rfc2698;

    /**
     * if set, meter operates in color-blind mode
     */
    uint8   blind;

    /**
     * reserved for future use
     */
    uint8   avb_mode;

} cfp_profile_t;

/**
 * 
 * contents of meter excess bucket
 */
typedef struct cb_cfp_bucket_s {
    /**
     * excess bucket state
     */
    uint32  bkte;

    /**
     * committed bucket state
     */
    uint32  bktc;

} cfp_bucket_t;

/**
 * 
 * calendar and port mapping
 */
typedef struct cb_pqs_calendar_s {
    /**
     * When sent 4:1 are considered valid
     */
    uint8   slot_port_sel_en;

    /**
     * Port number to be used for slot 0
     */
    uint8   slot_port;

} calendar_t;

/**
 * PORT GROUP TO LOCAL PORT GROUP TABLE:
 * 
 * indexed by port group, this map returns the equivalent (local)
 * port group. all the admission decisions are done based on the
 * local port group, so for cases like the pv dlliid that has the
 * global destination port group, we convert that to the local
 * port group to perform admission decisions.
 */
typedef struct cb_pqm_pg2lpg_s {
    /**
     * Local Port Group the Group Port Group equates to.
     */
    uint8   lpg;

} pg2lpg_t;

/**
 * 
 * this table contains mac associations used for forwarding.
 */
typedef struct cb_itm_arlfm_s {
    /**
     * Bits 31 thru 0 of the 48b Ethernet MAC address.
     */
    uint32  mac_lo;

    /**
     * The Filter Identifier. Used to segregate entries in the ARL.
     */
    uint16  fid;

    /**
     * Indicates actions to take when station movement is detected.
     * When this field is UPDATE then the update actions specified by the
     * PGLCT have priority. When this field is UPDATE_AND_COPY, COPY or
     * DISABLE_UPDATE then the PGLCT update actions are ignored.
     * 2 - COPY
     *     When movement is detected dont update the ARL entry but do copy
     *     the frame to the CPU.
     * 1 - UPDATE_AND_COPY
     *     When movement is detected update the ARL entry and copy to the CPU.
     * 0 - UPDATE
     *     When station movement is detected update the ARL entrys associated
     *     destination data.
     * 3 - DISABLE_UPDATE
     *     Do not allow ARL entry update.
     */
    uint8   upd_ctrl;

    /**
     * Bits 47 thru 32 of the 48b Ethernet MAC address.
     */
    uint16  mac_hi;

    /**
     * Indicates how to forward a frame.
     * 2 - COPY_TO_CPU
     *     Standard forwarding and unconditionally generate an additional
     *     copy for the Control Plane.
     * 1 - DENY_SMAC
     *     If this is returned as the result of an SMAC lookup then the
     *     frame will be discarded. Note that denying DMACs can be accomplished
     *     by setting the dst_type field to DST_IS_INVALID in ARLFM. If this is
     *     returned as the result of a DMAC lookup then the frame will be
     *     forwarded normally.
     * 3 - DENY_SMAC_AND_COPY_TO_CPU
     *     Deny and unconditionally generate an additional
     *     copy for the Control Plane.
     * 0 - PERMIT
     *     Standard forwarding. Allow frame to be forwarded normally.
     */
    uint8   fwd_ctrl;

    /**
     * Indicates the validity of an entry.
     * 2 - VALID
     *     Indicates that this is a valid entry.
     * 3 - STATIC
     *     Indicates that the entry belongs wholly to software, hardware
     *     may not age it. Hardware updates the associated data
     *     when a station move is detected if and only if upd_ctrl is UPDATE
     *     or UPDATE_AND_COPY.
     * 1 - PENDING
     *     Indicates that the hash table entry has been learned by hardware
     *     but not sanctioned by software, eligible for aging. Counts as a miss
     *     for forwarding purposes but suppresses continued notification of
     *     software.
     * 0 - EMPTY
     *     Indicates that the hash table entry is empty.
     */
    uint8   valid;

    /**
     * Destination field. This indicates how to forward a frame. Its precise
     * semantic is determined by the dst_type field.
     */
    uint16  dst;

    /**
     * Indicates the type of the dst field.
     * 3 - DST_IS_DPG
     *     Indicates that the dst field is a Destination Port Group.
     * 0 - DST_IS_INVALID
     *     If this is returned on a DMAC lookup of the ARLFM then the
     *     causal frame will be dropped.
     * 2 - DST_IS_N
     *     Indicates that the dst field is the N field of an N-type LI.
     * 1 - DST_IS_MULTICAST
     *     Indicates that the dst field is a Destination Group Identifier.
     */
    uint8   dst_type;

    /**
     * Set by hardware when a lookup hits this entry. Cleared periodically
     * by the aging process. If the aging process encounters a valid
     * non-static entry that has the hit bit clear then it marks the entry
     * as invalid (aging it out).
     */
    uint8   hit;

} arlfm_t;

/**
 * ADDRESS RESOLUTION LOGIC FORWARDING MAP 0:
 * 
 * the arl fm is broken into two parts, one of which is maintained
 * in the arlfm1_ght_h0 and h1 and the other is maintained in the arlfm0.
 */
typedef struct cb_itm_arlfm0_s {
    /**
     * Indicates the validity of an entry.
     * 2 - VALID
     *     Indicates that this is a valid entry.
     * 3 - STATIC
     *     Indicates that the entry belongs wholly to software, hardware
     *     may not age it. Hardware updates the associated data
     *     when a station move is detected if and only if fwd_ctrl is PERMIT.
     *     Hardware will not update the associated data in any other case.
     * 1 - PENDING
     *     Indicates the the hash table entry has been learned by hardware
     *     but not sanctioned by software, eligible for aging. Counts as a miss
     *     for forwarding purposes but suppresses continued notification of
     *     software.
     * 0 - EMPTY
     *     Indicates that the hash table entry is empty.
     */
    uint8   valid;

    /**
     * Destination field. This indicates how to forward a frame. Its precise
     * semantic is determined by the dst_type field.
     */
    uint16  dst;

    /**
     * Indicates the type of the dst field.
     * 3 - DST_IS_DPG
     *     Indicates that the dst field is a Destination Port Group.
     * 0 - DST_IS_INVALID
     *     If this is returned on a DMAC lookup of the ARLFM then the
     *     causal frame will be dropped.
     * 2 - DST_IS_N
     *     Indicates that the dst field is the N field of an N-type LI.
     * 1 - DST_IS_MULTICAST
     *     Indicates that the dst field is a Destination Group Identifier.
     */
    uint8   dst_type;

    /**
     * Set by hardware when a lookup hits this entry. Cleared periodically
     * by the aging process. If the aging process encounters a valid
     * non-static entry that has the hit bit clear then it marks the entry
     * as invalid (aging it out).
     */
    uint8   hit;

} arlfm0_t;

/**
 * 
 * contents of meter excess bucket
 */
typedef struct cb_ipp_bucket_s {
    /**
     * excess bucket state
     */
    uint32  bkte;

    /**
     * committed bucket state
     */
    uint32  bktc;

} ipp_bucket_t;

/**
 * FLOW CONTROL DOMAIN CONFIGURATION TABLE:
 * 
 * arriving frames are assigned to a flow control domain by
 * the ipp. the domain id identifies a domain counter (dc) to which each
 * page used to buffer the frame should be debited. the domain id also
 * identifies a set of thresholds which are used to effect flow
 * control and a flow-control hysteresis threshold.
 * <ul>
 * <li>dc == hysteresis - set(xon_enable)</li>
 * <li>dc < thresh0 && xon_enable - xon</li>
 * <li>dc >= thresh0 && dc < thresh1 - xoff, clear(xon_enable)</li>
 * <li>dc >= thresh1 && dc < thresh2 - xoff, discard red</li>
 * <li>dc >= thresh2 && dc < thresh3 - xoff, discard yellow</li>
 * <li>dc >= thresh3 - xoff, discard all</li>
 * </ul>
 * the domain counter is credited when the buffer associated with
 * the frame is finally freed. when we transmit something to an
 * egress mirror we need to consider what domain counter should be
 * debited. it should be the domain counter assigned to the original
 * frame. so we need to get the domain counter through the egress mirror
 * port. a tlv shall be assigned for this purpose and egress mirror frames
 * shall nominate their own flow control domain accordingly.
 * </p><p>
 * note that the domain counter must be incremented for each page
 * used as a frame arrives and decremented as each page is freed.
 */
typedef struct cb_bmu_fcd_config_s {
    /**
     * The threshold at which packets with RED drop precedence
     * are dropped. Flow control remains asserted.
     */
    uint16  thresh1;

    /**
     * The threshold at which flow control is asserted.
     */
    uint16  thresh0;

    /**
     * The threshold at which all packets from the associated
     * ingress are dropped. Flow control remains asserted.
     */
    uint16  thresh3;

    /**
     * The threshold at which packets with yellow drop precedence
     * are dropped. Flow control remains asserted.
     */
    uint16  thresh2;

    /**
     * FCD counter enable. If set to 1, enables FCD page counters. This enables the drops. 
     * 
     */
    uint8   counter_enable;

    /**
     * A bitmap of the traffic classes which map to this Flow Control
     * domain.
     */
    uint8   tc_bmp;

    /**
     * Flow control enable. If set to 1, enables FCD Xoff (Ingress pause).
     * This bit is dont care if counter_enable is set to zero.
     */
    uint8   fc_enable;

    /**
     * The point to which a flow controlled ingress buffer occupancy
     * must fall to before flow control goes from asserted to negated.
     */
    uint16  hysteresis;

} fcd_config_t;

/**
 * STATISTICS RAM:
 * 
 * stat ram read data register 0
 * if count_mode = 2bx0, then stat ram will store the 38 bit byte counter
 * and 32 bit packet coutner
 * if count_mode = 2bx1, then stat ram will store the 38 bit inprofile
 * packet counter and 32 bit outprofile packet counter
 */
typedef struct cb_cfp_stat_s {
    /**
     * If count_mode = 2bx0, packet_counter[31:0]
     * If count_mode = 2bx1, outprofile_counter[31:0]
     */
    uint32  stat_counter0_lo;

    /**
     * If count_mode = 2bx0, packet_counter[63:32]
     * If count_mode = 2bx1, outprofile_counter[63:32]
     */
    uint32  stat_counter0_hi;

    /**
     * If count_mode = 2bx0, byte_counter[31:0]
     * If count_mode = 2bx1, inprofile_counter[31:0]
     */
    uint32  stat_counter1_lo;

    /**
     * If count_mode = 2bx0, byte_counter[63:32]
     * If count_mode = 2bx1, inprofile_counter[63::32]
     */
    uint32  stat_counter1_hi;

} stat_t;

/**
 * 
 * each port group has a configurable threshold that will be used to
 * determine if the port has to be in the low power mode. it also has
 * a configurable timer that determines how often the refresh cycle is.
 */
typedef struct cb_pqm_eeecfg_s {
    /**
     * EEE threshold for the Port
     */
    uint16  eee_thresh;

    /**
     * A 15 bit sleep timer value that has a 1 micro sec granularity
     */
    uint16  eee_timer;

    /**
     * EEE enabled if set to 1, disabled otherwise
     */
    uint8   eee_en;

} eeecfg_t;

/**
 * HEADER DECAPSULATION TABLE:
 * 
 * the header decapsulation table describes up to sixteen
 * decapsulation methods. each entry amounts to a set of headers
 * that are to be removed from the parse descriptor and when they
 * are to be removed.
 * <p>decapsulation is performed after the sli has been determined.
 * the nature of the decapsulation performed is a function of
 * precisely how the sli has been determined.</p>
 * <p>a header instance to be removed is defined in terms of its
 * type and its position relative to other headers of the same type
 * (e.g. ipv4.1 references the first ipv4 header, mpls.3 references
 * the third mpls header).</p>
 * <p>note that entry zero of this table must be set to all zeroes.
 * </p>
 */
typedef struct cb_ipp_hdt_s {
    /**
     * The type of the header to be decapsulated.
     * 1 - NT_TAG_INVALID
     *     Indicates an invalid tag. Should not appear on the parse stack.
     * 105 - NT_IPV6_FRAG_EH
     *     An IPV6 fragment extension header, 8B in length
     * 87 - NT_BLOB8
     *     Blob header type, 8 bytes in length
     * 99 - NT_BLOB20
     *     Blob header type, 20 bytes in length
     * 101 - NT_DIAG
     *     A 64B diag tag with ether type populated from
     *     config register, DEBUG_TAG_ETHERTYPE
     * 71 - NT_ICMP
     *     V4 or V6 Proto equals 1
     * 2 - NT_ING_TIMESTAMP
     * 0 - NT_NOP
     * 3 - NT_CTAG
     *     Recognized when a TPID is parsed that matches ctpid0 or ctpid1 as
     *     selected per Port Group.
     * 11 - NT_ITAG
     *     Recognized when a TPID is parsed that matches itpid. MAC-in-MAC
     *     Service Identifier Tag. Note that technically the ITAG is deemed to
     *     be 16B and contains the C-DMAC and C-SMAC of the encapsulated
     *     frame. We choose instead to view it as a 6B tag immediately followed
     *     by an implicit MAC header. So when we recognize an ITAG we push
     *     two types onto the stack (NT_ITAG/6, NT_MAC/6).
     * 15 - NT_SNAP
     *     Recognized by the Deep Frame Parser when the last parsed header is LLC
     *     and LLC.DSAP[7:1]=0x55, LLC.SSAP[7:1]=0x55 and LLC.CTRL[1:0]=3.
     * 255 - NT_HWH
     *     Hardware Header.
     * 17 - NT_COE4
     *     4B Broadcom Channel over Ethernet Tag. The COE4 tag needs to be
     *     configured as a soft tag if it is required as it is not supported
     *     natively by the TAG parser. However the Traffic Class and Drop
     *     Precedence translation process does extract PCP/DE fields from the
     *     header that matches this native type. Therefore when configuring
     *     recognition of COE4 the selected soft_tag must have its ntype field
     *     set to NT_COE4 for the TC/DP selection to work properly.
     * 27 - NT_IMP0
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 7 - NT_ETYPE
     *     This is implicitly pushed by the tag parser prior to a terminal
     *     header.
     * 5 - NT_STAG
     *     Recognized when a TPID is parsed that matches stpid0 or stpid1 as
     *     selected per Port Group.
     * 37 - NT_UTAG2
     *     Available for assignment as a soft tag.
     * 39 - NT_UTAG3
     *     Available for assignment as a soft tag.
     * 33 - NT_UTAG0
     *     Available for assignment as a soft tag.
     * 35 - NT_UTAG1
     *     Available for assignment as a soft tag.
     * 13 - NT_LLC
     *     TPID in [0, llc_config.limit]. If the TAG parser observes a
     *     TPID&lt;=llc_config.limit it can recognize an LLC header.
     *     The Deep Frame Parser has an LLC entry point and is capable of
     *     parsing beyond the LLC header.
     * 55 - NT_PPPOE
     *     Recognized by the tag parser when ETYPE=0x8864.
     * 45 - NT_PAYLOAD
     *     Default when the tag parser does not recognize etype/tpid or fails to
     *     recognize the LLC/SNAP header.
     * 253 - NT_RAW
     *     Only used by the key-builder to provide raw access to metadata and header
     *     data.
     * 23 - NT_CP2SW
     *     CB (CP/cascade) tag (CP2SW format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 67 - NT_UDP
     *     V4 or V6 Proto equals 17
     * 9 - NT_ETAG
     *     Recognized when a TPID is parsed that matches etpid.
     * 69 - NT_TCP
     *     V4 or V6 Proto equals 6
     * 89 - NT_BLOB10
     *     Blob header type, 10 bytes in length
     * 95 - NT_BLOB16
     *     Blob header type, 16 bytes in length
     * 93 - NT_BLOB14
     *     Blob header type, 14 bytes in length
     * 49 - NT_IPV6
     *     Recognized by the tag parser when ETYPE=0x86DD. Also recognized by the
     *     deep frame parser when the IP protocol field is 41 or the PPPoE protocol
     *     field is 0x0057.
     * 97 - NT_BLOB18
     *     Blob header type, 18 bytes in length
     * 41 - NT_UTAG4
     *     Available for assignment as a soft tag.
     * 53 - NT_MCMPLS
     *     Recognized by the tag parser when ETYPE=0x8848. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0283.
     * 43 - NT_UTAG5
     *     Available for assignment as a soft tag.
     * 12 - NT_EGR_TIMESTAMP
     * 77 - NT_ARP
     *     Address Resolution Protocol
     * 103 - NT_IPV6_EH
     *     An IPV6 extension header of variable length
     * 73 - NT_IGMP
     *     V4 or V6 Proto equals 2
     * 81 - NT_BLOB2
     *     Blob header type, 2 bytes in length
     * 83 - NT_BLOB4
     *     Blob header type, 4 bytes in length
     * 47 - NT_IPV4
     *     Recognized by the tag parser when ETYPE=0x0800. Also recognized by the
     *     deep frame parser when the IP protocol field is 4 or the PPPoE protocol
     *     field is 0x0021.
     * 85 - NT_BLOB6
     *     Blob header type, 6 bytes in length
     * 51 - NT_UCMPLS
     *     Recognized by the tag parser when ETYPE=0x8847. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0281.
     * 91 - NT_BLOB12
     *     Blob header type, 12 bytes in length
     * 75 - NT_PTP
     *     Precision Time Protocol
     * 21 - NT_SW2CP
     *     CB (CP/cascade) tag (SW2CP format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 31 - NT_MAC
     *     MAC header. This is the 12B header consisting of the DMAC and SMAC.
     * 29 - NT_IMP1
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 19 - NT_COE8
     *     8B Broadcom Channel over Ethernet Tag. Like the COE4 tag, the COE8
     *     tag is not natively supported by the TAG parser and requires a soft
     *     tag if it is to be recognized. Again the TC and DP translation process
     *     does extract priority information from the header marked with this
     *     native type. Accordingly when a soft_tag is configured to recognize
     *     COE8 then its ntype field should be set to NT_COE8.
     * 107 - NT_IPV6_ICMP
     *     IPV6 Internet Control Message.
     * 4 - NT_MIRROR
     * 25 - NT_BRCM
     *     Proto1 can be used to recognize a BRCM header. If proto1 is BRCM
     *     header then this is the NT pushed on to the PD. A specific NT is
     *     required for BRCM header so that it can be recognized and processed
     *     by the FP downstream. If proto0/proto1 are not BRCM header then
     *     NT_IMP0/NT_IMP1 are pushed on to the PD. These are not processed
     *     by the FP.
     */
    uint8   type0;

    /**
     * Which of possibly several instances of the indicated type to
     * decap where 0 indicates no decap.
     */
    uint8   which0;

    /**
     * If this bit is set then all headers up till header indicated by
     * type0 are deleted
     */
    uint8   uptill0;

    /**
     * The type of the header to be decapsulated.
     * 1 - NT_TAG_INVALID
     *     Indicates an invalid tag. Should not appear on the parse stack.
     * 105 - NT_IPV6_FRAG_EH
     *     An IPV6 fragment extension header, 8B in length
     * 87 - NT_BLOB8
     *     Blob header type, 8 bytes in length
     * 99 - NT_BLOB20
     *     Blob header type, 20 bytes in length
     * 101 - NT_DIAG
     *     A 64B diag tag with ether type populated from
     *     config register, DEBUG_TAG_ETHERTYPE
     * 71 - NT_ICMP
     *     V4 or V6 Proto equals 1
     * 2 - NT_ING_TIMESTAMP
     * 0 - NT_NOP
     * 3 - NT_CTAG
     *     Recognized when a TPID is parsed that matches ctpid0 or ctpid1 as
     *     selected per Port Group.
     * 11 - NT_ITAG
     *     Recognized when a TPID is parsed that matches itpid. MAC-in-MAC
     *     Service Identifier Tag. Note that technically the ITAG is deemed to
     *     be 16B and contains the C-DMAC and C-SMAC of the encapsulated
     *     frame. We choose instead to view it as a 6B tag immediately followed
     *     by an implicit MAC header. So when we recognize an ITAG we push
     *     two types onto the stack (NT_ITAG/6, NT_MAC/6).
     * 15 - NT_SNAP
     *     Recognized by the Deep Frame Parser when the last parsed header is LLC
     *     and LLC.DSAP[7:1]=0x55, LLC.SSAP[7:1]=0x55 and LLC.CTRL[1:0]=3.
     * 255 - NT_HWH
     *     Hardware Header.
     * 17 - NT_COE4
     *     4B Broadcom Channel over Ethernet Tag. The COE4 tag needs to be
     *     configured as a soft tag if it is required as it is not supported
     *     natively by the TAG parser. However the Traffic Class and Drop
     *     Precedence translation process does extract PCP/DE fields from the
     *     header that matches this native type. Therefore when configuring
     *     recognition of COE4 the selected soft_tag must have its ntype field
     *     set to NT_COE4 for the TC/DP selection to work properly.
     * 27 - NT_IMP0
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 7 - NT_ETYPE
     *     This is implicitly pushed by the tag parser prior to a terminal
     *     header.
     * 5 - NT_STAG
     *     Recognized when a TPID is parsed that matches stpid0 or stpid1 as
     *     selected per Port Group.
     * 37 - NT_UTAG2
     *     Available for assignment as a soft tag.
     * 39 - NT_UTAG3
     *     Available for assignment as a soft tag.
     * 33 - NT_UTAG0
     *     Available for assignment as a soft tag.
     * 35 - NT_UTAG1
     *     Available for assignment as a soft tag.
     * 13 - NT_LLC
     *     TPID in [0, llc_config.limit]. If the TAG parser observes a
     *     TPID&lt;=llc_config.limit it can recognize an LLC header.
     *     The Deep Frame Parser has an LLC entry point and is capable of
     *     parsing beyond the LLC header.
     * 55 - NT_PPPOE
     *     Recognized by the tag parser when ETYPE=0x8864.
     * 45 - NT_PAYLOAD
     *     Default when the tag parser does not recognize etype/tpid or fails to
     *     recognize the LLC/SNAP header.
     * 253 - NT_RAW
     *     Only used by the key-builder to provide raw access to metadata and header
     *     data.
     * 23 - NT_CP2SW
     *     CB (CP/cascade) tag (CP2SW format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 67 - NT_UDP
     *     V4 or V6 Proto equals 17
     * 9 - NT_ETAG
     *     Recognized when a TPID is parsed that matches etpid.
     * 69 - NT_TCP
     *     V4 or V6 Proto equals 6
     * 89 - NT_BLOB10
     *     Blob header type, 10 bytes in length
     * 95 - NT_BLOB16
     *     Blob header type, 16 bytes in length
     * 93 - NT_BLOB14
     *     Blob header type, 14 bytes in length
     * 49 - NT_IPV6
     *     Recognized by the tag parser when ETYPE=0x86DD. Also recognized by the
     *     deep frame parser when the IP protocol field is 41 or the PPPoE protocol
     *     field is 0x0057.
     * 97 - NT_BLOB18
     *     Blob header type, 18 bytes in length
     * 41 - NT_UTAG4
     *     Available for assignment as a soft tag.
     * 53 - NT_MCMPLS
     *     Recognized by the tag parser when ETYPE=0x8848. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0283.
     * 43 - NT_UTAG5
     *     Available for assignment as a soft tag.
     * 12 - NT_EGR_TIMESTAMP
     * 77 - NT_ARP
     *     Address Resolution Protocol
     * 103 - NT_IPV6_EH
     *     An IPV6 extension header of variable length
     * 73 - NT_IGMP
     *     V4 or V6 Proto equals 2
     * 81 - NT_BLOB2
     *     Blob header type, 2 bytes in length
     * 83 - NT_BLOB4
     *     Blob header type, 4 bytes in length
     * 47 - NT_IPV4
     *     Recognized by the tag parser when ETYPE=0x0800. Also recognized by the
     *     deep frame parser when the IP protocol field is 4 or the PPPoE protocol
     *     field is 0x0021.
     * 85 - NT_BLOB6
     *     Blob header type, 6 bytes in length
     * 51 - NT_UCMPLS
     *     Recognized by the tag parser when ETYPE=0x8847. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0281.
     * 91 - NT_BLOB12
     *     Blob header type, 12 bytes in length
     * 75 - NT_PTP
     *     Precision Time Protocol
     * 21 - NT_SW2CP
     *     CB (CP/cascade) tag (SW2CP format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 31 - NT_MAC
     *     MAC header. This is the 12B header consisting of the DMAC and SMAC.
     * 29 - NT_IMP1
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 19 - NT_COE8
     *     8B Broadcom Channel over Ethernet Tag. Like the COE4 tag, the COE8
     *     tag is not natively supported by the TAG parser and requires a soft
     *     tag if it is to be recognized. Again the TC and DP translation process
     *     does extract priority information from the header marked with this
     *     native type. Accordingly when a soft_tag is configured to recognize
     *     COE8 then its ntype field should be set to NT_COE8.
     * 107 - NT_IPV6_ICMP
     *     IPV6 Internet Control Message.
     * 4 - NT_MIRROR
     * 25 - NT_BRCM
     *     Proto1 can be used to recognize a BRCM header. If proto1 is BRCM
     *     header then this is the NT pushed on to the PD. A specific NT is
     *     required for BRCM header so that it can be recognized and processed
     *     by the FP downstream. If proto0/proto1 are not BRCM header then
     *     NT_IMP0/NT_IMP1 are pushed on to the PD. These are not processed
     *     by the FP.
     */
    uint8   type1;

    /**
     * Which of possibly several instances of the indicated type to
     * decap where 0 indicates no decap.
     */
    uint8   which1;

    /**
     * If this bit is set then all headers up till header indicated by
     * type1 are deleted
     */
    uint8   uptill1;

    /**
     * The type of the header to be decapsulated.
     * 1 - NT_TAG_INVALID
     *     Indicates an invalid tag. Should not appear on the parse stack.
     * 105 - NT_IPV6_FRAG_EH
     *     An IPV6 fragment extension header, 8B in length
     * 87 - NT_BLOB8
     *     Blob header type, 8 bytes in length
     * 99 - NT_BLOB20
     *     Blob header type, 20 bytes in length
     * 101 - NT_DIAG
     *     A 64B diag tag with ether type populated from
     *     config register, DEBUG_TAG_ETHERTYPE
     * 71 - NT_ICMP
     *     V4 or V6 Proto equals 1
     * 2 - NT_ING_TIMESTAMP
     * 0 - NT_NOP
     * 3 - NT_CTAG
     *     Recognized when a TPID is parsed that matches ctpid0 or ctpid1 as
     *     selected per Port Group.
     * 11 - NT_ITAG
     *     Recognized when a TPID is parsed that matches itpid. MAC-in-MAC
     *     Service Identifier Tag. Note that technically the ITAG is deemed to
     *     be 16B and contains the C-DMAC and C-SMAC of the encapsulated
     *     frame. We choose instead to view it as a 6B tag immediately followed
     *     by an implicit MAC header. So when we recognize an ITAG we push
     *     two types onto the stack (NT_ITAG/6, NT_MAC/6).
     * 15 - NT_SNAP
     *     Recognized by the Deep Frame Parser when the last parsed header is LLC
     *     and LLC.DSAP[7:1]=0x55, LLC.SSAP[7:1]=0x55 and LLC.CTRL[1:0]=3.
     * 255 - NT_HWH
     *     Hardware Header.
     * 17 - NT_COE4
     *     4B Broadcom Channel over Ethernet Tag. The COE4 tag needs to be
     *     configured as a soft tag if it is required as it is not supported
     *     natively by the TAG parser. However the Traffic Class and Drop
     *     Precedence translation process does extract PCP/DE fields from the
     *     header that matches this native type. Therefore when configuring
     *     recognition of COE4 the selected soft_tag must have its ntype field
     *     set to NT_COE4 for the TC/DP selection to work properly.
     * 27 - NT_IMP0
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 7 - NT_ETYPE
     *     This is implicitly pushed by the tag parser prior to a terminal
     *     header.
     * 5 - NT_STAG
     *     Recognized when a TPID is parsed that matches stpid0 or stpid1 as
     *     selected per Port Group.
     * 37 - NT_UTAG2
     *     Available for assignment as a soft tag.
     * 39 - NT_UTAG3
     *     Available for assignment as a soft tag.
     * 33 - NT_UTAG0
     *     Available for assignment as a soft tag.
     * 35 - NT_UTAG1
     *     Available for assignment as a soft tag.
     * 13 - NT_LLC
     *     TPID in [0, llc_config.limit]. If the TAG parser observes a
     *     TPID&lt;=llc_config.limit it can recognize an LLC header.
     *     The Deep Frame Parser has an LLC entry point and is capable of
     *     parsing beyond the LLC header.
     * 55 - NT_PPPOE
     *     Recognized by the tag parser when ETYPE=0x8864.
     * 45 - NT_PAYLOAD
     *     Default when the tag parser does not recognize etype/tpid or fails to
     *     recognize the LLC/SNAP header.
     * 253 - NT_RAW
     *     Only used by the key-builder to provide raw access to metadata and header
     *     data.
     * 23 - NT_CP2SW
     *     CB (CP/cascade) tag (CP2SW format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 67 - NT_UDP
     *     V4 or V6 Proto equals 17
     * 9 - NT_ETAG
     *     Recognized when a TPID is parsed that matches etpid.
     * 69 - NT_TCP
     *     V4 or V6 Proto equals 6
     * 89 - NT_BLOB10
     *     Blob header type, 10 bytes in length
     * 95 - NT_BLOB16
     *     Blob header type, 16 bytes in length
     * 93 - NT_BLOB14
     *     Blob header type, 14 bytes in length
     * 49 - NT_IPV6
     *     Recognized by the tag parser when ETYPE=0x86DD. Also recognized by the
     *     deep frame parser when the IP protocol field is 41 or the PPPoE protocol
     *     field is 0x0057.
     * 97 - NT_BLOB18
     *     Blob header type, 18 bytes in length
     * 41 - NT_UTAG4
     *     Available for assignment as a soft tag.
     * 53 - NT_MCMPLS
     *     Recognized by the tag parser when ETYPE=0x8848. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0283.
     * 43 - NT_UTAG5
     *     Available for assignment as a soft tag.
     * 12 - NT_EGR_TIMESTAMP
     * 77 - NT_ARP
     *     Address Resolution Protocol
     * 103 - NT_IPV6_EH
     *     An IPV6 extension header of variable length
     * 73 - NT_IGMP
     *     V4 or V6 Proto equals 2
     * 81 - NT_BLOB2
     *     Blob header type, 2 bytes in length
     * 83 - NT_BLOB4
     *     Blob header type, 4 bytes in length
     * 47 - NT_IPV4
     *     Recognized by the tag parser when ETYPE=0x0800. Also recognized by the
     *     deep frame parser when the IP protocol field is 4 or the PPPoE protocol
     *     field is 0x0021.
     * 85 - NT_BLOB6
     *     Blob header type, 6 bytes in length
     * 51 - NT_UCMPLS
     *     Recognized by the tag parser when ETYPE=0x8847. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0281.
     * 91 - NT_BLOB12
     *     Blob header type, 12 bytes in length
     * 75 - NT_PTP
     *     Precision Time Protocol
     * 21 - NT_SW2CP
     *     CB (CP/cascade) tag (SW2CP format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 31 - NT_MAC
     *     MAC header. This is the 12B header consisting of the DMAC and SMAC.
     * 29 - NT_IMP1
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 19 - NT_COE8
     *     8B Broadcom Channel over Ethernet Tag. Like the COE4 tag, the COE8
     *     tag is not natively supported by the TAG parser and requires a soft
     *     tag if it is to be recognized. Again the TC and DP translation process
     *     does extract priority information from the header marked with this
     *     native type. Accordingly when a soft_tag is configured to recognize
     *     COE8 then its ntype field should be set to NT_COE8.
     * 107 - NT_IPV6_ICMP
     *     IPV6 Internet Control Message.
     * 4 - NT_MIRROR
     * 25 - NT_BRCM
     *     Proto1 can be used to recognize a BRCM header. If proto1 is BRCM
     *     header then this is the NT pushed on to the PD. A specific NT is
     *     required for BRCM header so that it can be recognized and processed
     *     by the FP downstream. If proto0/proto1 are not BRCM header then
     *     NT_IMP0/NT_IMP1 are pushed on to the PD. These are not processed
     *     by the FP.
     */
    uint8   type2;

    /**
     * If this bit is set then all headers up till header indicated by
     * type2 are deleted
     */
    uint8   uptill2;

    /**
     * If this bit is set then all headers up till header indicated by
     * type3 are deleted
     */
    uint8   uptill3;

    /**
     * Which of possibly several instances of the indicated type to
     * decap where 0 indicates no decap.
     */
    uint8   which2;

    /**
     * Which of possibly several instances of the indicated type to
     * decap where 0 indicates no decap.
     */
    uint8   which3;

    /**
     * The type of the header to be decapsulated.
     * 1 - NT_TAG_INVALID
     *     Indicates an invalid tag. Should not appear on the parse stack.
     * 105 - NT_IPV6_FRAG_EH
     *     An IPV6 fragment extension header, 8B in length
     * 87 - NT_BLOB8
     *     Blob header type, 8 bytes in length
     * 99 - NT_BLOB20
     *     Blob header type, 20 bytes in length
     * 101 - NT_DIAG
     *     A 64B diag tag with ether type populated from
     *     config register, DEBUG_TAG_ETHERTYPE
     * 71 - NT_ICMP
     *     V4 or V6 Proto equals 1
     * 2 - NT_ING_TIMESTAMP
     * 0 - NT_NOP
     * 3 - NT_CTAG
     *     Recognized when a TPID is parsed that matches ctpid0 or ctpid1 as
     *     selected per Port Group.
     * 11 - NT_ITAG
     *     Recognized when a TPID is parsed that matches itpid. MAC-in-MAC
     *     Service Identifier Tag. Note that technically the ITAG is deemed to
     *     be 16B and contains the C-DMAC and C-SMAC of the encapsulated
     *     frame. We choose instead to view it as a 6B tag immediately followed
     *     by an implicit MAC header. So when we recognize an ITAG we push
     *     two types onto the stack (NT_ITAG/6, NT_MAC/6).
     * 15 - NT_SNAP
     *     Recognized by the Deep Frame Parser when the last parsed header is LLC
     *     and LLC.DSAP[7:1]=0x55, LLC.SSAP[7:1]=0x55 and LLC.CTRL[1:0]=3.
     * 255 - NT_HWH
     *     Hardware Header.
     * 17 - NT_COE4
     *     4B Broadcom Channel over Ethernet Tag. The COE4 tag needs to be
     *     configured as a soft tag if it is required as it is not supported
     *     natively by the TAG parser. However the Traffic Class and Drop
     *     Precedence translation process does extract PCP/DE fields from the
     *     header that matches this native type. Therefore when configuring
     *     recognition of COE4 the selected soft_tag must have its ntype field
     *     set to NT_COE4 for the TC/DP selection to work properly.
     * 27 - NT_IMP0
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 7 - NT_ETYPE
     *     This is implicitly pushed by the tag parser prior to a terminal
     *     header.
     * 5 - NT_STAG
     *     Recognized when a TPID is parsed that matches stpid0 or stpid1 as
     *     selected per Port Group.
     * 37 - NT_UTAG2
     *     Available for assignment as a soft tag.
     * 39 - NT_UTAG3
     *     Available for assignment as a soft tag.
     * 33 - NT_UTAG0
     *     Available for assignment as a soft tag.
     * 35 - NT_UTAG1
     *     Available for assignment as a soft tag.
     * 13 - NT_LLC
     *     TPID in [0, llc_config.limit]. If the TAG parser observes a
     *     TPID&lt;=llc_config.limit it can recognize an LLC header.
     *     The Deep Frame Parser has an LLC entry point and is capable of
     *     parsing beyond the LLC header.
     * 55 - NT_PPPOE
     *     Recognized by the tag parser when ETYPE=0x8864.
     * 45 - NT_PAYLOAD
     *     Default when the tag parser does not recognize etype/tpid or fails to
     *     recognize the LLC/SNAP header.
     * 253 - NT_RAW
     *     Only used by the key-builder to provide raw access to metadata and header
     *     data.
     * 23 - NT_CP2SW
     *     CB (CP/cascade) tag (CP2SW format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 67 - NT_UDP
     *     V4 or V6 Proto equals 17
     * 9 - NT_ETAG
     *     Recognized when a TPID is parsed that matches etpid.
     * 69 - NT_TCP
     *     V4 or V6 Proto equals 6
     * 89 - NT_BLOB10
     *     Blob header type, 10 bytes in length
     * 95 - NT_BLOB16
     *     Blob header type, 16 bytes in length
     * 93 - NT_BLOB14
     *     Blob header type, 14 bytes in length
     * 49 - NT_IPV6
     *     Recognized by the tag parser when ETYPE=0x86DD. Also recognized by the
     *     deep frame parser when the IP protocol field is 41 or the PPPoE protocol
     *     field is 0x0057.
     * 97 - NT_BLOB18
     *     Blob header type, 18 bytes in length
     * 41 - NT_UTAG4
     *     Available for assignment as a soft tag.
     * 53 - NT_MCMPLS
     *     Recognized by the tag parser when ETYPE=0x8848. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0283.
     * 43 - NT_UTAG5
     *     Available for assignment as a soft tag.
     * 12 - NT_EGR_TIMESTAMP
     * 77 - NT_ARP
     *     Address Resolution Protocol
     * 103 - NT_IPV6_EH
     *     An IPV6 extension header of variable length
     * 73 - NT_IGMP
     *     V4 or V6 Proto equals 2
     * 81 - NT_BLOB2
     *     Blob header type, 2 bytes in length
     * 83 - NT_BLOB4
     *     Blob header type, 4 bytes in length
     * 47 - NT_IPV4
     *     Recognized by the tag parser when ETYPE=0x0800. Also recognized by the
     *     deep frame parser when the IP protocol field is 4 or the PPPoE protocol
     *     field is 0x0021.
     * 85 - NT_BLOB6
     *     Blob header type, 6 bytes in length
     * 51 - NT_UCMPLS
     *     Recognized by the tag parser when ETYPE=0x8847. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0281.
     * 91 - NT_BLOB12
     *     Blob header type, 12 bytes in length
     * 75 - NT_PTP
     *     Precision Time Protocol
     * 21 - NT_SW2CP
     *     CB (CP/cascade) tag (SW2CP format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 31 - NT_MAC
     *     MAC header. This is the 12B header consisting of the DMAC and SMAC.
     * 29 - NT_IMP1
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 19 - NT_COE8
     *     8B Broadcom Channel over Ethernet Tag. Like the COE4 tag, the COE8
     *     tag is not natively supported by the TAG parser and requires a soft
     *     tag if it is to be recognized. Again the TC and DP translation process
     *     does extract priority information from the header marked with this
     *     native type. Accordingly when a soft_tag is configured to recognize
     *     COE8 then its ntype field should be set to NT_COE8.
     * 107 - NT_IPV6_ICMP
     *     IPV6 Internet Control Message.
     * 4 - NT_MIRROR
     * 25 - NT_BRCM
     *     Proto1 can be used to recognize a BRCM header. If proto1 is BRCM
     *     header then this is the NT pushed on to the PD. A specific NT is
     *     required for BRCM header so that it can be recognized and processed
     *     by the FP downstream. If proto0/proto1 are not BRCM header then
     *     NT_IMP0/NT_IMP1 are pushed on to the PD. These are not processed
     *     by the FP.
     */
    uint8   type3;

} hdt_t;

/**
 * EGRESS SPANNING TREE GROUP ENABLE TABLE:
 * 
 * the estget is indexed by a spanning tree group identifier (stgid) which
 * is derived from the vsit. the table returns a port group bit map which
 * is used to control transmission on a particular port group. note that
 * the bitmap applies to <b>global</b> port groups.
 */
typedef struct cb_pqm_estget_s {
    /**
     * Bit map to control transmission on a given PG.
     */
    uint16  tx_ena;

} estget_t;

/**
 * SOFT TAG TABLE:
 * 
 * soft tags provide a mechanism to extend or modify the behaviour of the
 * tag parser. note that for ingress tag parsing we require these
 * registers to be used for broadcom coe tags and for alternate tpids
 * for ctags and stags.
 */
typedef struct cb_ipp_stt_s {
    /**
     * The Ethertype which we wish to recognize. Note that soft tags will be
     * allowed priority over hard tags so one can change the Ethertype
     * that gets you to a native tag. Soft tags *must* be used to recognize
     * the Broadcom coe4 and coe8 native types.
     */
    uint16  etype;

    /**
     * The native type we wish to place on the parse stack. A value of
     * zero indicates that this soft tag is not valid.
     * 1 - NT_TAG_INVALID
     *     Indicates an invalid tag. Should not appear on the parse stack.
     * 105 - NT_IPV6_FRAG_EH
     *     An IPV6 fragment extension header, 8B in length
     * 87 - NT_BLOB8
     *     Blob header type, 8 bytes in length
     * 99 - NT_BLOB20
     *     Blob header type, 20 bytes in length
     * 101 - NT_DIAG
     *     A 64B diag tag with ether type populated from
     *     config register, DEBUG_TAG_ETHERTYPE
     * 71 - NT_ICMP
     *     V4 or V6 Proto equals 1
     * 2 - NT_ING_TIMESTAMP
     * 0 - NT_NOP
     * 3 - NT_CTAG
     *     Recognized when a TPID is parsed that matches ctpid0 or ctpid1 as
     *     selected per Port Group.
     * 11 - NT_ITAG
     *     Recognized when a TPID is parsed that matches itpid. MAC-in-MAC
     *     Service Identifier Tag. Note that technically the ITAG is deemed to
     *     be 16B and contains the C-DMAC and C-SMAC of the encapsulated
     *     frame. We choose instead to view it as a 6B tag immediately followed
     *     by an implicit MAC header. So when we recognize an ITAG we push
     *     two types onto the stack (NT_ITAG/6, NT_MAC/6).
     * 15 - NT_SNAP
     *     Recognized by the Deep Frame Parser when the last parsed header is LLC
     *     and LLC.DSAP[7:1]=0x55, LLC.SSAP[7:1]=0x55 and LLC.CTRL[1:0]=3.
     * 255 - NT_HWH
     *     Hardware Header.
     * 17 - NT_COE4
     *     4B Broadcom Channel over Ethernet Tag. The COE4 tag needs to be
     *     configured as a soft tag if it is required as it is not supported
     *     natively by the TAG parser. However the Traffic Class and Drop
     *     Precedence translation process does extract PCP/DE fields from the
     *     header that matches this native type. Therefore when configuring
     *     recognition of COE4 the selected soft_tag must have its ntype field
     *     set to NT_COE4 for the TC/DP selection to work properly.
     * 27 - NT_IMP0
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 7 - NT_ETYPE
     *     This is implicitly pushed by the tag parser prior to a terminal
     *     header.
     * 5 - NT_STAG
     *     Recognized when a TPID is parsed that matches stpid0 or stpid1 as
     *     selected per Port Group.
     * 37 - NT_UTAG2
     *     Available for assignment as a soft tag.
     * 39 - NT_UTAG3
     *     Available for assignment as a soft tag.
     * 33 - NT_UTAG0
     *     Available for assignment as a soft tag.
     * 35 - NT_UTAG1
     *     Available for assignment as a soft tag.
     * 13 - NT_LLC
     *     TPID in [0, llc_config.limit]. If the TAG parser observes a
     *     TPID&lt;=llc_config.limit it can recognize an LLC header.
     *     The Deep Frame Parser has an LLC entry point and is capable of
     *     parsing beyond the LLC header.
     * 55 - NT_PPPOE
     *     Recognized by the tag parser when ETYPE=0x8864.
     * 45 - NT_PAYLOAD
     *     Default when the tag parser does not recognize etype/tpid or fails to
     *     recognize the LLC/SNAP header.
     * 253 - NT_RAW
     *     Only used by the key-builder to provide raw access to metadata and header
     *     data.
     * 23 - NT_CP2SW
     *     CB (CP/cascade) tag (CP2SW format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 67 - NT_UDP
     *     V4 or V6 Proto equals 17
     * 9 - NT_ETAG
     *     Recognized when a TPID is parsed that matches etpid.
     * 69 - NT_TCP
     *     V4 or V6 Proto equals 6
     * 89 - NT_BLOB10
     *     Blob header type, 10 bytes in length
     * 95 - NT_BLOB16
     *     Blob header type, 16 bytes in length
     * 93 - NT_BLOB14
     *     Blob header type, 14 bytes in length
     * 49 - NT_IPV6
     *     Recognized by the tag parser when ETYPE=0x86DD. Also recognized by the
     *     deep frame parser when the IP protocol field is 41 or the PPPoE protocol
     *     field is 0x0057.
     * 97 - NT_BLOB18
     *     Blob header type, 18 bytes in length
     * 41 - NT_UTAG4
     *     Available for assignment as a soft tag.
     * 53 - NT_MCMPLS
     *     Recognized by the tag parser when ETYPE=0x8848. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0283.
     * 43 - NT_UTAG5
     *     Available for assignment as a soft tag.
     * 12 - NT_EGR_TIMESTAMP
     * 77 - NT_ARP
     *     Address Resolution Protocol
     * 103 - NT_IPV6_EH
     *     An IPV6 extension header of variable length
     * 73 - NT_IGMP
     *     V4 or V6 Proto equals 2
     * 81 - NT_BLOB2
     *     Blob header type, 2 bytes in length
     * 83 - NT_BLOB4
     *     Blob header type, 4 bytes in length
     * 47 - NT_IPV4
     *     Recognized by the tag parser when ETYPE=0x0800. Also recognized by the
     *     deep frame parser when the IP protocol field is 4 or the PPPoE protocol
     *     field is 0x0021.
     * 85 - NT_BLOB6
     *     Blob header type, 6 bytes in length
     * 51 - NT_UCMPLS
     *     Recognized by the tag parser when ETYPE=0x8847. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0281.
     * 91 - NT_BLOB12
     *     Blob header type, 12 bytes in length
     * 75 - NT_PTP
     *     Precision Time Protocol
     * 21 - NT_SW2CP
     *     CB (CP/cascade) tag (SW2CP format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 31 - NT_MAC
     *     MAC header. This is the 12B header consisting of the DMAC and SMAC.
     * 29 - NT_IMP1
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 19 - NT_COE8
     *     8B Broadcom Channel over Ethernet Tag. Like the COE4 tag, the COE8
     *     tag is not natively supported by the TAG parser and requires a soft
     *     tag if it is to be recognized. Again the TC and DP translation process
     *     does extract priority information from the header marked with this
     *     native type. Accordingly when a soft_tag is configured to recognize
     *     COE8 then its ntype field should be set to NT_COE8.
     * 107 - NT_IPV6_ICMP
     *     IPV6 Internet Control Message.
     * 4 - NT_MIRROR
     * 25 - NT_BRCM
     *     Proto1 can be used to recognize a BRCM header. If proto1 is BRCM
     *     header then this is the NT pushed on to the PD. A specific NT is
     *     required for BRCM header so that it can be recognized and processed
     *     by the FP downstream. If proto0/proto1 are not BRCM header then
     *     NT_IMP0/NT_IMP1 are pushed on to the PD. These are not processed
     *     by the FP.
     */
    uint8   ntype;

    /**
     * When constructing the Ethernet Key for SLIC mapping use this 4b
     * summary for TPID if length (below) is non-zero or for Ethertype if
     * length is zero.
     */
    uint8   ekey_type;

    /**
     * The length of the parsed header in 2B words. Note that if this is
     * zero the header is considered terminal and an Ethertype header
     * will be pushed onto the parse stack prior to the ntype field.
     * When non-zero this must be equivalent to 4B or more - a value of
     * one is illegal.
     */
    uint8   length;

    /**
     * Indicates which (if any) of the Ethernet Keys 6 TCI fields should
     * receive this tags TCI. The indicated field receives the first two
     * bytes of the TCI followed by subsequent bytes (if any) as determined
     * by the length field. Values of 6 and 7 result in no transfer to the
     * Ethernet Key. If the length field is zero or one then no data is
     * transferred to the key.
     */
    uint8   tci;

} stt_t;

/**
 * PORT ENCAPSULATION TABLE:
 * 
 * the pet is used to determine how
 * to encapsulate a frame on a given dpp. it is indexed by local destination
 * physical port group (ldpg).
 * </p><p>
 * the encap field is a byte array of directives. logic determines
 * how many bytes are valid in this array by examining it from the last
 * byte (encap[7]) down to the first byte (encap[0]).
 * if the full bit is set then the number of valid bytes is 8 otherwise
 * if there exists a byte encap[n] where n&lt;8 such that
 * encap[n]==eor and encap[n+i]==0 for all n+i&lt;8 then the
 * number of valid bytes is n otherwise it is 0. note that the eor byte
 * is not transferred from here to the final directives list to the epp.
 */
typedef struct cb_etm_pet_s {
    /**
     * The fifth byte of encap data.
     */
    uint8   encap4;

    /**
     * The sixth byte of encap data.
     */
    uint8   encap5;

    /**
     * The eight byte of encap data.
     */
    uint8   encap7;

    /**
     * The seventh byte of encap data.
     */
    uint8   encap6;

    /**
     * The third byte of encap data.
     */
    uint8   encap2;

    /**
     * The fourth byte of encap data.
     */
    uint8   encap3;

    /**
     * The first byte of encap data.
     */
    uint8   encap0;

    /**
     * The second byte of encap data.
     */
    uint8   encap1;

    /**
     * Indicates that all encap bytes in the record are valid and there is
     * no trailing EOR byte.
     */
    uint8   full;

} pet_t;

/**
 * INGRESS SPANNING TREE GROUP ENABLE TABLE:
 * 
 * the istget is indexed by a spanning tree group identifier (stgid)
 * which is derived from the vsit. it returns a 16b
 * port group map which determines if the corresponding port is
 * enabled for receive.
 */
typedef struct cb_ipp_istget_s {
    /**
     * Bit map to control transmission on a given PG.
     */
    uint16  rx_ena;

} istget_t;

/**
 * 
 * each queue domain within a port can either belong to the strict priority
 * or the round robin scheduler group.
 */
typedef struct cb_pqm_qdschcfg_s {
    /**
     * A value of 1 indicates SP, 0 indicates RR
     */
    uint8   sp_rr_sch;

} qdschcfg_t;

/**
 * 
 * meter refresh scale
 */
typedef struct cb_pqm_rscale_s {
    /**
     * determines how many significant bits above bit 17
     * are used to determine refresh interval for each meter
     * a setting of 4b111x disables refresh for the meter
     */
    uint8   scale;

} pqm_rscale_t;

/**
 * 
 * this table returns the traffic clas bit map for a given meter id.
 */
typedef struct cb_bmu_mtr2tcb_s {
    /**
     * Traffic class bitmap used for meter shaping.
     */
    uint8   tc_bmp;

    /**
     * shaping enable
     */
    uint8   shp_en;

} mtr2tcb_t;

/**
 * DESTINATION LOGICAL INTERFACE TO LOCAL DESTINATION PORT GROUP:
 * 
 * this has the destination port group ids for unicast packets.
 * when a frame is destined to a single destination logical interface
 * (dli) we need to be able to translate the dli into a destination
 * local port group (dpg) so that we may queue the frame to the appropriate
 * output port(s). in the case of a pv-type dli the dpg is derived
 * directly from dliid.pg. in the case of an n-type dli we need to
 * translate dliid.n to a ldpg. this table enables this
 * translation. it is indexed by dliid.n and returns a ldpgid.
 */
typedef struct cb_pqm_dli2ldpg_s {
    /**
     * Local Destination Port Group Identifier.
     */
    uint8   ldpgid;

} dli2ldpg_t;

/**
 * GLOBAL TRAFFIC CLASS TO QUEUE DOMAIN MAP:
 * 
 * 8 traffic classes are supported.
 * in the pqm. 8 queue domains will be supported. this map
 * defines the mapping of the traffic class to a queue domain. multiple
 * tcs may be mapped to a single qd.
 */
typedef struct cb_pqm_tc2qd_s {
    /**
     * Queue domain for TC. The default will be a 1:1 mapping of the queue
     * domain and tc.
     */
    uint8   qd;

} tc2qd_t;

/**
 * 
 * this table is maintained in the epp. it contains 16 x 16b entries,
 * which hold a compensation factor of ingress link delay in case of peer to peer transparent clock.
 * this is used along with ptp correction field update directive.
 * the content of this table will be added to the correction field.
 */
typedef struct cb_epp_spldt_s {
    /**
     * Delay to be added in PTP correction field.
     */
    uint16  link_delay;

} spldt_t;

/**
 * 
 * meter refresh scale
 */
typedef struct cb_cfp_rscale_s {
    /**
     * determines how many significant bits above bit 17
     * are used to determine refresh interval for each meter
     * a setting of 4b111x disables refresh for the meter
     */
    uint8   scale;

} cfp_rscale_t;

/**
 * GENERIC HASH TABLE DESCRIPTOR TABLE:
 * 
 * the generic hash table descriptor table is used to describe hash tables
 * implemented by the itm. </p>
 * <p>arlfms implement ethernet forwarding databases. they are specifically
 * tuned to this role. they support keys consisting of a 12b filter id and
 * a 48b mac address. they support learning, automatic aging, pattern
 * controlled content scan and pattern controlled deletion. we support only
 * one arlfm and it is configured by the arl_config register (not this
 * table). </p>
 * <p>ghts implement logical interface maps.
 */
typedef struct cb_itm_ghtdt_s {
    /**
     * Indicates the offset within the Generic Hash Seed Table where the hash
     * one seed is maintained.
     */
    uint8   seed1;

    /**
     * The base address of the hash table. Note that the available address space
     * is 10240 words.
     */
    uint16  base;

    /**
     * The number of entries in a table is 2^num_entries. The maximum number
     * of entries for a GHT is 10240. A value of zero indicates that
     * the table is disabled and any search will return a miss.
     */
    uint8   num_entries;

    /**
     * Indicates the offset within the Generic Hash Seed Table where the hash
     * zero seed is maintained.
     */
    uint8   seed0;

} ghtdt_t;

/**
 * 
 * contents of meter excess bucket
 */
typedef struct cb_bmu_bucket_s {
    /**
     * excess bucket state
     */
    uint32  bkte;

    /**
     * committed bucket state
     */
    uint32  bktc;

} bmu_bucket_t;

/**
 * LOGICAL INTERFACE LINK TABLE:
 * 
 * this is the logical interface lookup table. the dliids to be forwarded
 * to the epp are stored in this table for multicast groups.
 */
typedef struct cb_pqm_lilt_s {
    /**
     * A Type I entry is indicated by the DGT lilt_type bit being zero and
     * it packs two DLIIDs into a single LILT entry. Bits 16 thru 31 are
     * dliid0 and bits 0 thru 15 are dliid1.
     * </BR>A Type II entry is indicated by the DGT lilt_type bit being
     * one and packs a dliid and a lilt_ndx into a single LILT entry.
     * Bits 15 thru 31 are the dliid and bits 0 thru 14 are the lilt_ndx.
     */
    uint32  lilt_entry;

} lilt_t;

/**
 * SQUELCH VECTOR TABLE:
 * 
 * the squelch vector table will be looked up with the load balance hash
 * from the ipp. the table will return a port bitmap in which only one
 * port will be enabled for all the ports that belong to a lag.
 */
typedef struct cb_pqm_svt_s {
    /**
     * Squelch Vector mask for a particular Load Balance Hash
     */
    uint16  svt_mask;

} svt_t;

/**
 * SOURCE LOGICAL INTERFACE CONTEXT MAP:
 * for even address this is key0[31:0].
 * for odd address this is key1[31:0].
 */
typedef struct cb_ipp_slicmap_s {
    /**
     * Valid if valid[5] is set.
     */
    uint16  tci5;

    /**
     * Valid if valid[4] is set.
     */
    uint16  tci4;

    /**
     * Valid if valid[2] is set.
     */
    uint16  tci2;

    /**
     * Valid if valid[3] is set.
     */
    uint16  tci3;

    /**
     * Valid if valid[1] is set.
     */
    uint16  tci1;

    /**
     * Valid if valid[0] is set.
     */
    uint16  tci0;

    /**
     * Indicates the validity of the tciN fields in the remainder of the
     * key.
     */
    uint8   valid;

    /**
     * Encoding of frames first TPID, zero if NA. Note several encodings are
     * available for use when defining soft tags via the STT.
     * 7 - USER_TPID7
     * 2 - CTAG
     * 14 - USER_TPID14
     * 12 - USER_TPID12
     * 4 - ITAG
     * 9 - USER_TPID9
     * 8 - USER_TPID8
     * 1 - STAG
     * 3 - ETAG
     * 6 - SNAP
     * 15 - USER_TPID15
     * 0 - NULL
     *     Indicates that there is no TPID.
     * 13 - USER_TPID13
     * 5 - PPPOE
     * 11 - USER_TPID11
     * 10 - USER_TPID10
     */
    uint8   tpid0;

    /**
     * Encoding of frames second TPID, zero if NA.
     * 7 - USER_TPID7
     * 2 - CTAG
     * 14 - USER_TPID14
     * 12 - USER_TPID12
     * 4 - ITAG
     * 9 - USER_TPID9
     * 8 - USER_TPID8
     * 1 - STAG
     * 3 - ETAG
     * 6 - SNAP
     * 15 - USER_TPID15
     * 0 - NULL
     *     Indicates that there is no TPID.
     * 13 - USER_TPID13
     * 5 - PPPOE
     * 11 - USER_TPID11
     * 10 - USER_TPID10
     */
    uint8   tpid1;

    /**
     * This portion of the key is currently unused.
     */
    uint8   unusedb;

    /**
     * Encoding of frames third TPID, zero if NA.
     * 7 - USER_TPID7
     * 2 - CTAG
     * 14 - USER_TPID14
     * 12 - USER_TPID12
     * 4 - ITAG
     * 9 - USER_TPID9
     * 8 - USER_TPID8
     * 1 - STAG
     * 3 - ETAG
     * 6 - SNAP
     * 15 - USER_TPID15
     * 0 - NULL
     *     Indicates that there is no TPID.
     * 13 - USER_TPID13
     * 5 - PPPOE
     * 11 - USER_TPID11
     * 10 - USER_TPID10
     */
    uint8   tpid2;

    /**
     * Encoding of frames fifth TPID, zero if NA.
     * 7 - USER_TPID7
     * 2 - CTAG
     * 14 - USER_TPID14
     * 12 - USER_TPID12
     * 4 - ITAG
     * 9 - USER_TPID9
     * 8 - USER_TPID8
     * 1 - STAG
     * 3 - ETAG
     * 6 - SNAP
     * 15 - USER_TPID15
     * 0 - NULL
     *     Indicates that there is no TPID.
     * 13 - USER_TPID13
     * 5 - PPPOE
     * 11 - USER_TPID11
     * 10 - USER_TPID10
     */
    uint8   tpid4;

    /**
     * Encoding of frames Ethertype. Note that several encodings are
     * available for use when defining soft tags via the STT.
     * 7 - ARP
     * 12 - USER_ETYPE12
     * 4 - UCMPLS
     * 11 - USER_ETYPE11
     * 14 - USER_ETYPE14
     * 13 - USER_ETYPE13
     * 8 - USER_ETYPE8
     * 9 - USER_ETYPE9
     * 5 - MCMPLS
     * 15 - USER_ETYPE15
     * 10 - USER_ETYPE10
     * 2 - IPV4
     * 3 - IPV6
     * 1 - LLC
     * 0 - PAYLOAD
     * 6 - PTP
     */
    uint8   etype;

    /**
     * Encoding of frames fourth TPID, zero if NA.
     * 7 - USER_TPID7
     * 2 - CTAG
     * 14 - USER_TPID14
     * 12 - USER_TPID12
     * 4 - ITAG
     * 9 - USER_TPID9
     * 8 - USER_TPID8
     * 1 - STAG
     * 3 - ETAG
     * 6 - SNAP
     * 15 - USER_TPID15
     * 0 - NULL
     *     Indicates that there is no TPID.
     * 13 - USER_TPID13
     * 5 - PPPOE
     * 11 - USER_TPID11
     * 10 - USER_TPID10
     */
    uint8   tpid3;

    /**
     * Bits 31 through 0 of the frames SMAC.
     */
    uint32  smac_lo32;

    /**
     * Bits 47 through 32 of the frames SMAC.
     */
    uint16  smac_hi16;

    /**
     * Bits 15 through 0 of the frames DMAC.
     */
    uint16  dmac_lo16;

    /**
     * Bits 47 through 16 of the frames DMAC.
     */
    uint32  dmac_hi32;

    /**
     * This part of the key is sourced from the PGT entry corresponding
     * to the port of arrival of the frame.
     */
    uint16  pepper;

    /**
     * When the ethernet key is constructed a one-hot encoding of the
     * local port group is generated. The purpose of the one-hot
     * encoding is that a TCAM rule may be associated with a set of port
     * groups. When configuring the TCAM entry to signal a set of ports
     * the ports that are within the set should have their corresponding
     * TCAM match configured to dont care while the ports that are not
     * in the set should have their corresponding TCAM match configured
     * to match-zero.
     */
    uint16  pg_map;

    /**
     * This portion of the key is currently unused.
     */
    uint8   unuseda;

    /**
     * 2 valid bits of the TCAM entry (not present for odd addresses)
     */
    uint8   valid_key0;

} slicmap_t;

/**
 * MAPID TO TABLE/KEY MAP:
 * 
 * the map id to table and key id table associates a map id
 * with a table id (in the itm) and a key id (described by the
 * ikft). this table is indexed by the map ids defined in
 * fpslict (li_map0, li_map1) to determine logical interface mapping.
 */
typedef struct cb_ipp_m2tk_s {
    /**
     * One of up to 8 tables described in the ITMs Generic
     * Hash Table Descriptor Table.
     */
    uint8   table_id;

    /**
     * One of up to 16 keys described in the Ingress Key
     * Field Table.
     */
    uint8   key_id;

} m2tk_t;

/**
 * ACTION REDIRECTION TABLE:
 * 
 * each tcam entry corresponds to an entry in this redirection table.
 */
typedef struct cb_cfp_art_s {
    /**
     * Index to ACTION RAM.
     */
    uint16  ndx;

} art_t;

/**
 * LOCAL PORT GROUP TO ISOLATION GROUP:
 * 
 * indexed by the local port group id this returns a 2b isolation group id.
 */
typedef struct cb_pqm_lpg2ig_s {
    /**
     * Isolation group corresponding to the Local Port Group.
     */
    uint8   ig;

} lpg2ig_t;

/**
 * 
 * burst size and rate config for committed bucket
 */
typedef struct cb_ipp_profile_s {
    /**
     * committed burst size exponent
     */
    uint8   cbs_exp;

    /**
     * committed burst size mantissa
     */
    uint8   cbs_mantissa;

    /**
     * committed information rate mantissa
     */
    uint16  cir_mantissa;

    /**
     * committed information rate exponent
     */
    uint8   cir_exp;

    /**
     * excess information rate exponent
     */
    uint8   eir_exp;

    /**
     * excess burst size exponent
     */
    uint8   ebs_exp;

    /**
     * excess information rate mantissa
     */
    uint16  eir_mantissa;

    /**
     * excess burst size mantissa
     */
    uint8   ebs_mantissa;

    /**
     * if set, the drop bit will be set if the resulting color is red
     */
    uint8   drop_on_red;

    /**
     * when set, mtr_req_length is ignored, and config_pkt_mode_len is used
     * instead
     */
    uint8   pkt_mode;

    /**
     * if set, a packet conforms to bktc only if the number of tokens is greater
     * than or equal to the packet length; otherwise the packet conforms as long
     * as the token count is non-negative
     */
    uint8   bktc_strict;

    /**
     * if set, a packet conforms to bkte only if the number of tokens is greater
     * than or equal to the packet length; otherwise the packet conforms as long
     * as the token count is non-negative
     */
    uint8   bkte_strict;

    /**
     * coupling flag
     * tokens being added to bktc will be diverted to bkte if bktc is full
     */
    uint8   cf;

    /**
     * if set, both bktc and bkte must have sufficient tokens to color a packet
     * green; otherwise only bktc must have sufficient tokens
     */
    uint8   rfc2698;

    /**
     * if set, meter operates in color-blind mode
     */
    uint8   blind;

    /**
     * reserved for future use
     */
    uint8   avb_mode;

} ipp_profile_t;

/**
 * QUEUE FIFO CACHE QUEUE DOMAIN ADDRESS TABLE:
 * 
 * for all the physical ports supported in the design, this table will
 * have the base address of the space in the queue fifo cache. this table
 * has to be configured fully and the qfc_mem_init register set to
 * configure the space further for all the queue domains.
 */
typedef struct cb_pqm_qfcqdaddr_s {
    /**
     * QFC address for port/qd.
     */
    uint16  qfc_addr;

} qfcqdaddr_t;

/**
 * MIRROR AND TRAP GROUP TABLE:
 * 
 * this table is indexed by mirror group id (mgid) and/or
 * trap group id (tgid) + 64. it contains information
 * used to forward mirrored and trapped frames.
 */
typedef struct cb_pqm_mtgt_s {
    /**
     * Mirror/Trap Group Traffic Class. The traffic class to be applied to a
     * frame mirrored/trapped with respect to the associated ID.
     */
    uint8   tc;

    /**
     * Mirror/Trap Group Drop Precedence. The drop precedence to be applied
     * to a frame mirrored/trapped with respect to the associated ID.
     * 3 - DROP
     *     Used as a drop indicator.
     * 0 - GREEN
     *     Indicates a packet with low drop precedence.
     * 2 - RED
     *     The highest drop precedence.
     * 1 - YELLOW
     *     Indicates a packet of medium drop precedence.
     */
    uint8   dp;

    /**
     * Mirror/Trap groups can only be unicast and they use N-type Logical
     * Interfaces to effect the appropriate encapsulation. A value of zero
     * indicates that the mirror or trap group is disabled.
     */
    uint16  dli_n;

    /**
     * When set, the EPP will truncate a frame being mirrored/trapped with
     * respect to the associated ID.
     */
    uint8   truncate;

    /**
     * This field controls the probability of dropping a frame.
     * When this field is zero, mirror and trap group frames are always
     * forwarded. When non-zero this field controls the probability of
     * dropping this frame. The drop probability is calculated as
     * drop_prob*2^-17. Based on the value in the drop_prob field,
     * the resultant probability varies between 1:128 (0.8%) down
     * to 1:128K (0.0008%)). The default is set 0, which is always
     * forward.
     */
    uint16  drop_prob;

} mtgt_t;

/**
 * 
 * selects a profile from the profile table for each meter
 */
typedef struct cb_ipp_pptr_s {
    /**
     * profile pointer
     */
    uint8   pointer;

} ipp_pptr_t;

/**
 * SOURCE ENCAPSULATION TABLE:
 * smac_lsb: least significant 32b of an smac address.
 */
typedef struct cb_epp_set_s {
    /**
     * Least significant 32b of an SMAC address.
     */
    uint32  smac_lsb;

    /**
     * Most significant 16b of an SMAC address.
     */
    uint16  smac_msb;

} set_t;

/**
 * SLICTCAM RESULT TABLE:
 * 
 * the slic tcam returns a tcam index which needs to be mapped
 * to slicid.
 */
typedef struct cb_ipp_srt_s {
    /**
     * The SLICID of the frame.
     */
    uint8   slicid;

    /**
     * The TRAP_GROUP associated with the SLICID.
     */
    uint8   trap_group;

} srt_t;

/**
 * 
 * low order data bits for 64b pmon register
 */
typedef struct cb_ipp_pmon_s {
    /**
     * 32 lsbs of count register
     */
    uint32  count_lsbs;

    /**
     * 32 msbs of count register
     */
    uint32  count_msbs;

} ipp_pmon_t;

/**
 * VSI TAG CONTROL TABLE:
 * 
 * it is used to control vlan
 * tagging on egress. etm only uses this table when dliid.t is set
 * indicating that dliid.vsi and dliid.pg are valid. etm indexes the
 * table using dliid.vsi. the legal range is [0, 4095]
 */
typedef struct cb_etm_vtct_s {
    /**
     * the VLAN ID to insert in a VLAN tag
     */
    uint16  vid;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca1;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca2;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca13;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca4;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca5;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca8;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca9;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca3;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca14;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca12;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca0;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca10;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca7;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca6;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca11;

    /**
     * 2 - TCA_ADD_PRI_TAG
     *     Add a priority VLAN tag (VID=0).
     * 0 - TCA_NO_TAG
     *     Do not add a VLAN tag.
     * 1 - TCA_ADD_TAG
     *     Add a VLAN tag using the VID field provided above.
     */
    uint8   tca15;

} vtct_t;

/**
 * CFP TERNARY CONTENT ADDRESSABLE MEMORY:
 * 
 * this 1024 entry tcam is the repository for cfp rules.
 * there are 2048 physical address locations.
 * even entries contain the x bits and valid bits.
 * odd entires contain the y bits. for bit n, x[n]=0/y[n]=0 indicates match any,
 * x[n]=0/y[n]=1 indicates match 0, and x[n]=1/y[n]=0 indicates match 1.
 */
typedef struct cb_cfp_cfpcam_s {
    /**
     * If addr is even, X[31:0]
     * If addr is odd, Y[31:0]
     * If COMPARE op, SearchKey[31:0] / {SearchResultMatch, PriorityEncodedMatchoutIndex[9:0]}
     */
    uint32  tcam_data0;

    /**
     * If addr is even, X[63:32]
     * If addr is odd, Y[63:32]
     * If COMPARE op, SearchKey[63:32]
     */
    uint32  tcam_data1;

    /**
     * If addr is even, X[95:64]
     * If addr is odd, Y[95:64]
     * If COMPARE op, SearchKey[95:64]
     */
    uint32  tcam_data2;

    /**
     * If addr is even, X[127:96]
     * If addr is odd, Y[127:96]
     * If COMPARE op, SearchKey[127:96]
     */
    uint32  tcam_data3;

    /**
     * If addr is even, X[159:128]
     * If addr is odd, Y[159:128]
     * If COMPARE op, SearchKey[159:128]
     */
    uint32  tcam_data4;

    /**
     * If addr is even, X[191:160]
     * If addr is odd, Y[191:160]
     * If COMPARE op, SearchKey[191:160]
     */
    uint32  tcam_data5;

    /**
     * 2 valid bits of the TCAM entry (not present for odd addresses)
     * If COMPARE op, this is dont care
     */
    uint8   tcam_valid;

} cfpcam_t;

/**
 * FLOW CONTROL DOMAIN PAGE COUNTER:
 * 
 * page count per flow control domain id. flow control domain id is derived as (spgid,gfcdid)
 */
typedef struct cb_bmu_fcd_cntr_s {
    /**
     * Each entry provides software access to a FCD page counter
     * indexed by flow control Domain ID.
     */
    uint16  page_cnt;

} fcd_cntr_t;

/**
 * FORWARDING PROCESSOR SOURCE LOGICAL INTERFACE CONTEXT TABLE:
 * 
 * the fpslict maintains per slic properties for the forwarding
 * processor. it is indexed by a slicid determined by the slic
 * mapping function.
 */
typedef struct cb_ipp_fpslict_s {
    /**
     * The destination key to be sent to the ITM for Forward Mapping.
     * 3 - FID_MPLS
     *     Build a key consisting of the VSIs Filter ID and the outer MPLS
     *     PDUs label.
     * 5 - FID_MIM
     *     Build a key consisting of the VSIs Filter ID and the Inner Ethernet
     *     PDUs DMAC if building a destination key, SMAC if building a
     *     source key.
     * 0 - NO_KEY
     *     No ARL Key is required and no ARL lookup is executed.
     * 2 - FID_IPA
     *     Build a key consisting of the VSIs Filter ID and the IPv4
     *     PDUs DA if building a destination key, SA if building a
     *     source key.
     * 1 - FID_MAC
     *     Build a key consisting of the VSIs Filter ID and the Ethernet
     *     PDUs DMAC if building a destination key, SMAC if building a
     *     source key.
     * 4 - FID_GRP_ECID
     *     Key consists of the Filter ID, and the E-Tags Group and Channel ID.
     */
    uint8   dst_key;

    /**
     * Indicates the CFP keys and LBH key to be used when the L3
     * header is IPv6. Used to index KST to determine which keys
     * are to be constructed. This is applied when the first Ethertype
     * header reflects an IPv6 payload.
     */
    uint8   ipv6_keyset;

    /**
     * Indicates the CFP keys and LBH key to be used when the L3
     * header is IPv4. This is used to index the KST to determine
     * which keys are to be constructed. This is applied when the
     * first Ethertype header reflects an IPv4 payload.
     */
    uint8   ipv4_keyset;

    /**
     * Indicates the CFP keys and LBH key to be used when the L3
     * header is not available or is not one of IPv4 or IPv6. Used to index
     * the KST to determine which keys are to be constructed. This is
     * applied when the first Ethertype header reflects neither IPv4 nor
     * IPv6.
     */
    uint8   other_keyset;

    /**
     * The source key to be sent to the ITM for Learning or Access Control
     * (typically).
     * 3 - FID_MPLS
     *     Build a key consisting of the VSIs Filter ID and the outer MPLS
     *     PDUs label.
     * 5 - FID_MIM
     *     Build a key consisting of the VSIs Filter ID and the Inner Ethernet
     *     PDUs DMAC if building a destination key, SMAC if building a
     *     source key.
     * 0 - NO_KEY
     *     No ARL Key is required and no ARL lookup is executed.
     * 2 - FID_IPA
     *     Build a key consisting of the VSIs Filter ID and the IPv4
     *     PDUs DA if building a destination key, SA if building a
     *     source key.
     * 1 - FID_MAC
     *     Build a key consisting of the VSIs Filter ID and the Ethernet
     *     PDUs DMAC if building a destination key, SMAC if building a
     *     source key.
     * 4 - FID_GRP_ECID
     *     Key consists of the Filter ID, and the E-Tags Group and Channel ID.
     */
    uint8   src_key;

    /**
     * A sad and lonely reserved bit.
     */
    uint8   rsvd;

    /**
     * Enable PV2LI mapping.
     */
    uint8   pv2li_map_en;

    /**
     * Default Source Logical Interface. This is used when any one
     * or more of the LI mapping mechanisms (PV2LI, LI Map 0 and LI Map
     * 1) fail to assign an SLI. That is it is the default result for
     * a failure to map an SLI within this context.
     * It is also used if none of the LI mapping mechanisms are enabled and
     * this field is non-zero.
     * If default_sli.T is set then the SPG for the frame is
     * substituted into the default_sli.PG. Thus a single SLIC may be used to
     * map multiple SPGs to a single VSI. If default_sli.T is clear then the
     * current SLIC may only default to a single SPG independent SLI.
     * If no LI mapping is enabled and this field is zero then the PGT
     * provided default is used.
     */
    uint32  default_sli;

    /**
     * Logical Interface Map Zero. Indicates a first LI lookup
     * table. The corresponding key is determined by indexing the Table
     * to Key (M2TK) map described below. The resultant key ID is used to
     * build the corresponding key as described in the Key Field Table
     * (KFT).
     */
    uint8   li_map0;

    /**
     * Enable LI mapping using li_map0.
     */
    uint8   li_map0_en;

    /**
     * Enable LI mapping using li_map1. Note that if only one LI mapping
     * is specified then it *must* be li_map0. So one *must not* set
     * li_map1_en unless li_map0_en is set.
     */
    uint8   li_map1_en;

    /**
     * An index to the Header Decapsulation Table that indicates the
     * headers to remove if the SLI source was LI Map 0.
     */
    uint8   li_map0_decap;

    /**
     * An index to the Header Decapsulation Table that indicates the
     * headers to remove if the SLI source was LI Map 1.
     */
    uint8   li_map1_decap;

    /**
     * An index to the Header Decapsulation Table that indicates the
     * headers to remove if the SLI source was the SLIC.
     */
    uint8   slic_decap;

    /**
     * An index to the Header Decapsulation Table that indicates the
     * headers to remove if the SLI source was the PV SLI.
     */
    uint8   pv_decap;

    /**
     * Logical Interface Map One. Indicates a second LI lookup
     * table. The corresponding key is determined by indexing the Table
     * to Key (M2TK) map described below. The resultant key ID is used to
     * build the corresponding key as described in the Key Field Table
     * (KFT). A match in this table has lower priority than a match in
     * li_map0.
     */
    uint8   li_map1;

} fpslict_t;

/**
 * KEYSET TABLE:
 * 
 * the keyset table is indexed by a keyset identifier that
 * originates from the fpslict. the fields ipv4_keyset, ipv6_keyset
 * and other_keyset identify which keyset is to be constructed for a
 * packet of the indicated type relative to the packets assigned
 * slic.
 */
typedef struct cb_ipp_kst_s {
    /**
     * An index to one of 16 keys which is used to determine a
     * Load Balance Hash (LBH); an LBH is calculated on a key as
     * constructed by a key builder under control of the KFT.
     */
    uint8   lbh_key;

    /**
     * Indicates that the LBH calculator is to be enabled with the
     * key described by lbh_key.
     */
    uint8   lbh_en;

    /**
     * Indicates which of the 4 CFP keys described by cfp_keyN are
     * to be enabled.
     */
    uint8   cfp_key_en;

    /**
     * This field is always prepended to key3 for the CFP. It is used to
     * limit search in the CFP to patterns that include a match on this
     * value.
     */
    uint8   dbid3;

    /**
     * This field is always prepended to key0 for the CFP.
     */
    uint8   dbid0;

    /**
     * Indicates which of up to 16 keys (as defined by the KFT
     * below) is to be supplied to the CFP as slice3.
     */
    uint8   cfp_key3;

    /**
     * Indicates which of up to 16 keys is to be supplied to the
     * CFP as slice2.
     */
    uint8   cfp_key2;

    /**
     * Indicates which of up to 16 keys is to be supplied to the
     * CFP as slice1.
     */
    uint8   cfp_key1;

    /**
     * This field is always prepended to key2 for the CFP.
     */
    uint8   dbid2;

    /**
     * Indicates which of up to 16 keys is to be supplied to the
     * CFP as slice0.
     */
    uint8   cfp_key0;

    /**
     * This field is always prepended to key1 for the CFP.
     */
    uint8   dbid1;

} kst_t;

/**
 * 
 * contents of meter excess bucket
 */
typedef struct cb_pqm_bucket_s {
    /**
     * excess bucket state
     */
    uint32  bkte;

    /**
     * committed bucket state
     */
    uint32  bktc;

} pqm_bucket_t;

/**
 * GENERIC HASH SEED TABLE:
 * 
 * the generic hash seed table is used to maintain seeds for multiple
 * ghts. it is important to provide the ability to rehash a ght without
 * affecting other ghts hence there needs to be enough space to describe
 * multiple seeds for multiple ghts. the ghst is a pooled and therefore
 * allocated resource where hash seeds can be stored by software and
 * accessed by the hardware for lookup.
 */
typedef struct cb_itm_ghst_s {
    /**
     * Bits 0 thru 31 of a seed.
     */
    uint32  seed_31_0;

    /**
     * Bits 32 thru 63 of a seed.
     */
    uint32  seed_63_32;

    /**
     * Bits 64 thru 95 of a seed.
     */
    uint32  seed_95_64;

    /**
     * Bits 96 thru 113 of a seed.
     */
    uint32  seed_113_96;

} ghst_t;

/**
 * LOCAL PORT GROUP TO GLOBAL PORT GROUP TABLE:
 * 
 * indexed by local port group, this map returns the equivalent (global)
 * port group. note that to map physical ports to port groups one needs
 * to map first to local port group via the pp2lpg map and from there
 * to port group via this lpg2pg map.
 */
typedef struct cb_pqm_lpg2pg_s {
    /**
     * Global Port Group the Local Port Group equates to.
     */
    uint8   pg;

} lpg2pg_t;

/**
 * EGRESS PORT GROUP TABLE:
 * 
 * the epgt is maintained in the epp. it is indexed by local destination
 * port group and used to determine the mtu for a given port and whether
 * or not to mirror on that port.
 */
typedef struct cb_epp_epgt_s {
    /**
     * Mirror Traffic Class. The traffic class to be applied to an
     * egress mirrored frame on this port group.
     */
    uint8   mirror_tc;

    /**
     * Indicates the mirror group to use for this port group. A value of
     * zero indicates no ingress port mirroring.
     */
    uint8   mirror;

    /**
     * When non-zero this field controls the probability of mirroring this
     * frame on egress; zero indicates no sampling (i.e. always forward).
     * Non-zero indicates probability of sample*2**-17 (resultant probability
     * is from about 1:128 (0.8%) down to 1:128K (0.0008%)).
     */
    uint16  sample;

    /**
     * Mirror Drop Precedence. The drop precedence to be applied
     * to an egress mirrored frame on this port group.
     * 3 - DROP
     *     Used as a drop indicator.
     * 0 - GREEN
     *     Indicates a packet with low drop precedence.
     * 2 - RED
     *     The highest drop precedence.
     * 1 - YELLOW
     *     Indicates a packet of medium drop precedence.
     */
    uint8   mirror_dp;

    /**
     * Indicates the Maximum Transmission Unit for a port group. The EPP
     * drops frames whose length exceed this. Set to zero to disable MTU
     * checking.
     */
    uint16  mtu;

} epgt_t;

/**
 * 
 * meter refresh scale
 */
typedef struct cb_bmu_rscale_s {
    /**
     * determines how many significant bits above bit 17
     * are used to determine refresh interval for each meter
     * a setting of 4b111x disables refresh for the meter
     */
    uint8   scale;

} bmu_rscale_t;

/**
 * LOCAL PORT GROUP TO PHYSICAL PORT FANOUT VECTOR TABLE:
 * 
 * given a port group, this table returns a physical port fan-out vector.
 */
typedef struct cb_pqm_lpg2ppfov_s {
    /**
     * Physical Port Fan-Out Vector.
     */
    uint16  ppfov;

} lpg2ppfov_t;

/**
 * VIRTUAL SWITCHING INSTANCE TABLE:
 * 
 * the vsit maintains properties per vsi.
 */
typedef struct cb_ipp_vsit_s {
    /**
     * Drop on Unicast Lookup Fail. If the destination key is
     * classified as a unicast key and we fail to find it in the
     * forwarding table then if this bit is set we will drop the frame
     * else we will forward it to the default destination group.
     * </P><P>
     * See also the description of drop_ulf in the PGT.
     */
    uint8   drop_ulf;

    /**
     * This field controls learning behavior.
     * 2 - COPY_TO_CP_AND_PEND
     *     If source key miss then learn (skey, sli), mark pending and copy to
     *     the control plane.
     * 3 - LEARN
     *     If source key miss then learn (skey, sli) and mark ready.
     * 0 - DO_NOT_LEARN
     *     Do not learn the source key on a miss.
     * 1 - COPY_TO_CP
     *     If source key miss then copy to control plane.
     */
    uint8   learn;

    /**
     * This field is reserved.
     */
    uint8   rsvd0;

    /**
     * Drop on Source Lookup Fail. This field controls forwarding
     * behavior in the event of a source key miss. If the source key is
     * not found and this bit is set then we will drop the frame else we
     * will forward as per destination key lookup results.
     * </P><P>
     * See also the description of drop_slf in the PGT.
     */
    uint8   drop_slf;

    /**
     * *** NOT IMPLEMENTED - HAS NO EFFECT ***
     * If this bit is set the IPP will instruct the ITM to update the
     * ARL entrys hit bit for an SMAC lookup when the DMAC address is
     * a multicast address.
     */
    uint8   hit_smac_if_dmac_mcast;

    /**
     * Drop on Multicast Lookup Fail. If the destination key is
     * classified as a multicast key and we fail to find it in the
     * forwarding table then if this bit is set we will drop the frame
     * else we will forward it to the default destination group.
     * </P><P>
     * See also the description of drop_mlf in the PGT.
     */
    uint8   drop_mlf;

    /**
     * This field is reserved.
     */
    uint8   rsvd1;

    /**
     * Spanning Tree Group Identifier. Used to select a vector to
     * enable/disable port group reception and transmission for MSTP.
     * The transmit enable vectors are maintained in the ESTGET in the
     * PQM and the receive enable vectors are maintained in the ISTGET in
     * the IPP.
     */
    uint8   stgid;

    /**
     * Drop broadcast frames. Specific to Ethernet switching when this
     * bit is set frames with a DMAC of ff:ff:ff:ff:ff:ff are dropped.
     * </P><P>
     * See also the description of drop_bcast in the PGT.
     */
    uint8   drop_bcast;

    /**
     * Port Group Map. This bitmap is used by the PQM to filter DPGs when
     * DGID or DLIID is valid. It is used as a VLAN broadcast domain when
     * multicast is indicated and DGID is zero.
     */
    uint16  pg_map;

    /**
     * When default_is_multicast is clear then this field is a
     * Destination Local Logical Interface Identifier (DLLIID).
     * When default_is_multicast is set then this field is a
     * Destination Group Identifier (DGID).
     */
    uint16  dlliid_dgid;

    /**
     * When set frames bearing TCP packets will be marked eligible for
     * Weighted Random Early Drop (WRED).
     */
    uint8   wred_ena;

    /**
     * A bit that indicates that the default destination is
     * multicast and hence that the dlliid_dgid field is to be
     * interpreted as a DGID.
     */
    uint8   default_is_multicast;

    /**
     * Enable SLI loopback for this VSI.
     */
    uint8   sli_lpbk_ena;

    /**
     * Isolation Map. Port Groups are assigned to isolation groups
     * of which there are 4. Let the SPGs Isolation Groups be called the
     * Source Isolation Group (SIG) and the DPGs Isolation Group be
     * called the Destination Isolation Group (DIG) then when
     * iso_map[SIG] is set and SIG==DIG, a frame from the corresponding
     * SPG to the DPG shall be dropped. The PQM effects the drop.
     * <BR/>
     * Note that the port groups are mapped to isolation groups in the PQM
     * using the Port Group to Isolation Group Map (PG2IG).
     * This feature enables (for instance) a service provider to
     * provision a VLAN in such a manner that none of its customers can
     * inter-communicate with each other but all can inter-communicate
     * with the service providers network.
     */
    uint8   iso_map;

    /**
     * Filter ID. A datum that is included in key
     * construction. A filter is a subset of table entries. This is
     * nominally used to effect Shared VLAN Learning.
     */
    uint16  fid;

} vsit_t;

/**
 * QFC CREDIT TABLE:
 * 
 * for all the physical ports supported in the design, this table will
 * have the credits allocated for each queue.
 * the queue is port/queue domain.
 */
typedef struct cb_pqm_qfccredit_s {
    /**
     * QFC credit for queue.
     */
    uint16  qfc_credit;

} qfccredit_t;

/**
 * 
 * this table is maintained in the epp. it contains 8 x 16b
 * entries. each entry holds a 16b tpid to be used as part of any tags
 * inserted by the epp. a directive that instructs the epp to insert a
 * tag will contain (as part of the directive) an index into this table
 * to retreive the given tpid for the associated tag insertion.
 */
typedef struct cb_epp_tet_s {
    /**
     * TPID value.
     */
    uint16  tag;

} tet_t;

/**
 * PHYSICAL PORT TO LOCAL PORT GROUP MAP:
 * 
 * the pp2pg map is indexed by ppid and returns the corresponding
 * local pgid. we distinguish between local and global port groups
 * because the namespace for local port groups is smaller than that
 * for global port groups and this is used to benefit in the sizing
 * of certain tables.
 * note that several pps can map to a single pg. note that
 * the legal pgid range is [0, 15] - there
 * cannot be more local port groups than there are ports.
 */
typedef struct cb_ipp_pp2lpg_s {
    /**
     * Indicates the local port group to which this physical port belongs.
     * This field initializes to its PP2LPG index.
     */
    uint8   pgid;

} ipp_pp2lpg_t;

/**
 * 
 * selects a profile from the profile table for each meter
 */
typedef struct cb_pqm_pptr_s {
    /**
     * profile pointer
     */
    uint8   pointer;

} pqm_pptr_t;

/**
 * 
 * low order data bits for 64b pmon register
 */
typedef struct cb_bmu_pmon_s {
    /**
     * 32 lsbs of count register
     */
    uint32  count_lsbs;

    /**
     * 32 msbs of count register
     */
    uint32  count_msbs;

} bmu_pmon_t;

/**
 * EGRESS TAG CONTROL TABLE:
 * 
 * the etct is used to complete simple single vlan tagging on egress.
 * the etct is indexed using the local dpg derived from dliid.pg.
 * the etm constructs an encapsulation recird with a single insert
 * vlan tag directive using the information in this table.
 */
typedef struct cb_etm_etct_s {
    /**
     * An index to a priority map table. The table contains multiple
     * priority maps with 32 4b or 8b entries. In this context the priority
     * map selected can only have 4b entries. The selected map is indexed by
     * the canonical (DP, TC) to determine the values to write in the PCP
     * and DEI fields of the (single) VLAN tag.
     */
    uint8   primap_ndx;

    /**
     * Priority Code Point. This field is written to the VLAN tag insertion
     * directive when primap_ndx (below) is zero.
     */
    uint8   pcp;

    /**
     * Drop Eligibility Indicator. Used separately or in conjunction with
     * PCP to indicate frames eligible to be dropped in the presence of
     * congestion. This field is written to the VLAN tag insertion directive
     * when primap_ndx (below) is zero.
     */
    uint8   dei;

    /**
     * An indicator of which VLAN tag insertion directive to apply.
     * 1 - INSERT_CTPID1
     *     Selects the directive to insert a VLAN tag using the TPID from the
     *     TET memory index 1 in EPP.
     * 0 - INSERT_CTPID0
     *     Selects the directive to insert a VLAN tag using the TPID from the
     *     TET memory index 0 in EPP.
     * 3 - INSERT_STPID1
     *     Selects the directive to insert a VLAN tag using the TPID from the
     *     TET memory index 3 in EPP.
     * 2 - INSERT_STPID0
     *     Selects the directive to insert a VLAN tag using the TPID from the
     *     TET memory index 2 in EPP.
     */
    uint8   opcode;

} etct_t;

/**
 * 
 * this address space is shared b/b arlfm1 and ght
 * in arlfm1 address space this holds the arlfm key
 * in ght address space holds ght key + associated data. ght may be
 * assigned a role in either logical interface mapping or forward
 * mapping.
 * arlfm0 format- {2-bit updt_ctl, 2-bit fwd_ctl, 16-bit fid, 48-bit mac_lo/hi}
 * arlfm0 format- has 2 entries in a row of 128-bit memory
 * ght format - {1-valid, 1-li_type 12-n_vsi,114-bit key}
 * ght format - has 1 entries in a row of 128-bit memory
 */
typedef struct cb_itm_arlfm1_ght_h0_s {
    /**
     * Bits 0 thru 31 of the GHT key or 32-bits of ARLFM1 mac_lo.
     */
    uint32  ght_key_31_0_arlfm1_mac_lo;

    /**
     * Bits 47 thru 32 of the GHT Key or 16-bits of ARLFM1 mac_hi.
     */
    uint16  ght_key_47_32_arlfm1_mac_hi_15_0;

    /**
     * Bits 59 thru 48 of the GHT Key or 12-bits of ARLFM1 fid.
     */
    uint16  ght_key_59_48_arlfm1_fid_11_0;

    /**
     * Bits 63 thru 60 of the GHT Key or 2-bits of ARLFM1 UPD_CTRL.
     */
    uint8   ght_key_63_62_arlfm1_upd_ctrl_1_0;

    /**
     * Bits 61 thru 60 of the GHT Key or 2-bits of ARLFM1 FWD_CTRL.
     */
    uint8   ght_key_61_60_arlfm1_fwd_ctrl_1_0;

    /**
     * Bits 64 thru 95 of the GHT key or 32-bits of ARLFM1 mac_lo.
     */
    uint32  ght_key_95_64_arlfm1_mac_lo;

    /**
     * Bits 111 thru 96 of GHT key or 16-bits of ARLFM1 mac_hi
     * and 16-bit of ARLFM1 mac- hi.
     */
    uint16  ght_key_111_96_arlfm1_mac_hi;

    /**
     * bits GHT : upper 2-bits of n_vsi
     * bits ARLFM1 : fwd_ctrl
     */
    uint8   ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0;

    /**
     * bits GHT : [27:18] - lower 10-bits of n_vsi
     * bits GHT : [17:16] - 113 thru 112 upper Key bits
     * bits ARLFM1 : [27:0] - 12-bits of FID
     */
    uint16  ght_n_vsi_9_0_key_113_112_arlfm1_fid;

    /**
     * bits GHT : [31] : Valid
     * bits GHT : [30] : LI_TYPE
     * bits ARLFM1 : upd_ctrl
     */
    uint8   ght_valid_litype_arlfm1_upd_ctrl_1_0;

} arlfm1_ght_h0_t;

/**
 * 
 * low order data bits for 64b pmon register
 */
typedef struct cb_cfp_pmon_s {
    /**
     * 32 lsbs of count register
     */
    uint32  count_lsbs;

    /**
     * 32 msbs of count register
     */
    uint32  count_msbs;

} cfp_pmon_t;

/**
 * max_tx_bytes: threshold for number of bytes in the epp pipeline
 * used by pqs to back pressure the pqm if this threshold is exceeded
 * 
 * max_tx_pkts: threshold for number of outstanding buffers per port
 * credit counter is decremented on a dequeue request from the pqs
 * credit counter is incrementes on a eop notification from epp to pqs
 * dequeues shall not happen if the counter decremented to zero
 */
typedef struct cb_pqs_max_config_s {
    /**
     * Threshold for number of bytes in the EPP pipeline
     * Used by pqs to back pressure the PQM if this threshold is exceeded
     */
    uint16  max_tx_bytes;

    /**
     * Threshold for number of outstanding buffers per port
     * credit counter is decremented on a dequeue request from the PQS
     * credit counter is incrementes on a EOP notification from EPP to PQS
     * Dequeues shall not happen if the counter decremented to zero
     */
    uint16  max_tx_pkts;

} max_config_t;

/**
 * 
 * burst size and rate config for committed bucket
 */
typedef struct cb_bmu_profile_s {
    /**
     * committed burst size exponent
     */
    uint8   cbs_exp;

    /**
     * committed burst size mantissa
     */
    uint8   cbs_mantissa;

    /**
     * committed information rate mantissa
     */
    uint16  cir_mantissa;

    /**
     * committed information rate exponent
     */
    uint8   cir_exp;

    /**
     * excess information rate exponent
     */
    uint8   eir_exp;

    /**
     * excess burst size exponent
     */
    uint8   ebs_exp;

    /**
     * excess information rate mantissa
     */
    uint16  eir_mantissa;

    /**
     * excess burst size mantissa
     */
    uint8   ebs_mantissa;

    /**
     * if set, the drop bit will be set if the resulting color is red
     */
    uint8   drop_on_red;

    /**
     * when set, mtr_req_length is ignored, and config_pkt_mode_len is used
     * instead
     */
    uint8   pkt_mode;

    /**
     * if set, a packet conforms to bktc only if the number of tokens is greater
     * than or equal to the packet length; otherwise the packet conforms as long
     * as the token count is non-negative
     */
    uint8   bktc_strict;

    /**
     * if set, a packet conforms to bkte only if the number of tokens is greater
     * than or equal to the packet length; otherwise the packet conforms as long
     * as the token count is non-negative
     */
    uint8   bkte_strict;

    /**
     * coupling flag
     * tokens being added to bktc will be diverted to bkte if bktc is full
     */
    uint8   cf;

    /**
     * if set, both bktc and bkte must have sufficient tokens to color a packet
     * green; otherwise only bktc must have sufficient tokens
     */
    uint8   rfc2698;

    /**
     * if set, meter operates in color-blind mode
     */
    uint8   blind;

    /**
     * reserved for future use
     */
    uint8   avb_mode;

} bmu_profile_t;

/**
 * PORT/VID TO LOGICAL INTERFACE MAP:
 * 
 * the pv2li table is used when the slic properties demand it. a
 * frames outer vid is used to index one of 4k entries in this
 * table. the frames local source port group (lspg) is then used
 * to index the retrieved port group map (pg_map).
 * if pg_map[lspg] is set then the resultant sli is
 * {1, spg[4:0], vsi[11:0]} otherwise an sli of zero is returned.
 */
typedef struct cb_ipp_pv2li_s {
    /**
     * A Port Group Map which indicates if the Local SPG for the frame is
     * valid with respect to the VID.
     */
    uint16  pg_map;

    /**
     * The Virtual Switch Instance that implements the VLAN represented
     * by VID.
     */
    uint16  vsi;

} pv2li_t;

/**
 * 
 * meter refresh scale
 */
typedef struct cb_ipp_rscale_s {
    /**
     * determines how many significant bits above bit 17
     * are used to determine refresh interval for each meter
     * a setting of 4b111x disables refresh for the meter
     */
    uint8   scale;

} ipp_rscale_t;

/**
 * 
 * low order data bits for 64b pmon register
 */
typedef struct cb_pqm_pmon_s {
    /**
     * 32 lsbs of count register
     */
    uint32  count_lsbs;

    /**
     * 32 msbs of count register
     */
    uint32  count_msbs;

} pqm_pmon_t;

/**
 * INGRESS KEY FIELD TABLE:
 * 
 * the ingress key field table describes up to 32
 * key fields for up to 16 keys.
 */
typedef struct cb_ipp_ikft_s {
    /**
     * The header type from which to extract a field; a zero value here
     * indicates that the offset (below) is an offset from the beginning
     * of the buffer which offers access to the meta-data fields. A value
     * of 0xFF selects the Hardware Header (shown below).
     * 1 - NT_TAG_INVALID
     *     Indicates an invalid tag. Should not appear on the parse stack.
     * 105 - NT_IPV6_FRAG_EH
     *     An IPV6 fragment extension header, 8B in length
     * 87 - NT_BLOB8
     *     Blob header type, 8 bytes in length
     * 99 - NT_BLOB20
     *     Blob header type, 20 bytes in length
     * 101 - NT_DIAG
     *     A 64B diag tag with ether type populated from
     *     config register, DEBUG_TAG_ETHERTYPE
     * 71 - NT_ICMP
     *     V4 or V6 Proto equals 1
     * 2 - NT_ING_TIMESTAMP
     * 0 - NT_NOP
     * 3 - NT_CTAG
     *     Recognized when a TPID is parsed that matches ctpid0 or ctpid1 as
     *     selected per Port Group.
     * 11 - NT_ITAG
     *     Recognized when a TPID is parsed that matches itpid. MAC-in-MAC
     *     Service Identifier Tag. Note that technically the ITAG is deemed to
     *     be 16B and contains the C-DMAC and C-SMAC of the encapsulated
     *     frame. We choose instead to view it as a 6B tag immediately followed
     *     by an implicit MAC header. So when we recognize an ITAG we push
     *     two types onto the stack (NT_ITAG/6, NT_MAC/6).
     * 15 - NT_SNAP
     *     Recognized by the Deep Frame Parser when the last parsed header is LLC
     *     and LLC.DSAP[7:1]=0x55, LLC.SSAP[7:1]=0x55 and LLC.CTRL[1:0]=3.
     * 255 - NT_HWH
     *     Hardware Header.
     * 17 - NT_COE4
     *     4B Broadcom Channel over Ethernet Tag. The COE4 tag needs to be
     *     configured as a soft tag if it is required as it is not supported
     *     natively by the TAG parser. However the Traffic Class and Drop
     *     Precedence translation process does extract PCP/DE fields from the
     *     header that matches this native type. Therefore when configuring
     *     recognition of COE4 the selected soft_tag must have its ntype field
     *     set to NT_COE4 for the TC/DP selection to work properly.
     * 27 - NT_IMP0
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 7 - NT_ETYPE
     *     This is implicitly pushed by the tag parser prior to a terminal
     *     header.
     * 5 - NT_STAG
     *     Recognized when a TPID is parsed that matches stpid0 or stpid1 as
     *     selected per Port Group.
     * 37 - NT_UTAG2
     *     Available for assignment as a soft tag.
     * 39 - NT_UTAG3
     *     Available for assignment as a soft tag.
     * 33 - NT_UTAG0
     *     Available for assignment as a soft tag.
     * 35 - NT_UTAG1
     *     Available for assignment as a soft tag.
     * 13 - NT_LLC
     *     TPID in [0, llc_config.limit]. If the TAG parser observes a
     *     TPID&lt;=llc_config.limit it can recognize an LLC header.
     *     The Deep Frame Parser has an LLC entry point and is capable of
     *     parsing beyond the LLC header.
     * 55 - NT_PPPOE
     *     Recognized by the tag parser when ETYPE=0x8864.
     * 45 - NT_PAYLOAD
     *     Default when the tag parser does not recognize etype/tpid or fails to
     *     recognize the LLC/SNAP header.
     * 253 - NT_RAW
     *     Only used by the key-builder to provide raw access to metadata and header
     *     data.
     * 23 - NT_CP2SW
     *     CB (CP/cascade) tag (CP2SW format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 67 - NT_UDP
     *     V4 or V6 Proto equals 17
     * 9 - NT_ETAG
     *     Recognized when a TPID is parsed that matches etpid.
     * 69 - NT_TCP
     *     V4 or V6 Proto equals 6
     * 89 - NT_BLOB10
     *     Blob header type, 10 bytes in length
     * 95 - NT_BLOB16
     *     Blob header type, 16 bytes in length
     * 93 - NT_BLOB14
     *     Blob header type, 14 bytes in length
     * 49 - NT_IPV6
     *     Recognized by the tag parser when ETYPE=0x86DD. Also recognized by the
     *     deep frame parser when the IP protocol field is 41 or the PPPoE protocol
     *     field is 0x0057.
     * 97 - NT_BLOB18
     *     Blob header type, 18 bytes in length
     * 41 - NT_UTAG4
     *     Available for assignment as a soft tag.
     * 53 - NT_MCMPLS
     *     Recognized by the tag parser when ETYPE=0x8848. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0283.
     * 43 - NT_UTAG5
     *     Available for assignment as a soft tag.
     * 12 - NT_EGR_TIMESTAMP
     * 77 - NT_ARP
     *     Address Resolution Protocol
     * 103 - NT_IPV6_EH
     *     An IPV6 extension header of variable length
     * 73 - NT_IGMP
     *     V4 or V6 Proto equals 2
     * 81 - NT_BLOB2
     *     Blob header type, 2 bytes in length
     * 83 - NT_BLOB4
     *     Blob header type, 4 bytes in length
     * 47 - NT_IPV4
     *     Recognized by the tag parser when ETYPE=0x0800. Also recognized by the
     *     deep frame parser when the IP protocol field is 4 or the PPPoE protocol
     *     field is 0x0021.
     * 85 - NT_BLOB6
     *     Blob header type, 6 bytes in length
     * 51 - NT_UCMPLS
     *     Recognized by the tag parser when ETYPE=0x8847. Also recognized by the
     *     deep frame parser when the MPLS S-bit is clear or the PPPoE protocol
     *     field is 0x0281.
     * 91 - NT_BLOB12
     *     Blob header type, 12 bytes in length
     * 75 - NT_PTP
     *     Precision Time Protocol
     * 21 - NT_SW2CP
     *     CB (CP/cascade) tag (SW2CP format) can be recognized by TAGP using
     *     soft tags. This header is recognized and processed by the FP.
     * 31 - NT_MAC
     *     MAC header. This is the 12B header consisting of the DMAC and SMAC.
     * 29 - NT_IMP1
     *     Per port group we can push a MAC header and an additional
     *     implicit tag header of an arbitrary length to the Parse
     *     Descriptor. This tag type is reserved for this implicit tag. The
     *     primary purpose of this is to accommodate (non-standard) implicit
     *     informational tags that do not bear the burden of a TPID (e.g. the
     *     Broadcom header). This is not recognized natively by the TAG parser.
     * 19 - NT_COE8
     *     8B Broadcom Channel over Ethernet Tag. Like the COE4 tag, the COE8
     *     tag is not natively supported by the TAG parser and requires a soft
     *     tag if it is to be recognized. Again the TC and DP translation process
     *     does extract priority information from the header marked with this
     *     native type. Accordingly when a soft_tag is configured to recognize
     *     COE8 then its ntype field should be set to NT_COE8.
     * 107 - NT_IPV6_ICMP
     *     IPV6 Internet Control Message.
     * 4 - NT_MIRROR
     * 25 - NT_BRCM
     *     Proto1 can be used to recognize a BRCM header. If proto1 is BRCM
     *     header then this is the NT pushed on to the PD. A specific NT is
     *     required for BRCM header so that it can be recognized and processed
     *     by the FP downstream. If proto0/proto1 are not BRCM header then
     *     NT_IMP0/NT_IMP1 are pushed on to the PD. These are not processed
     *     by the FP.
     */
    uint8   htype;

    /**
     * The header ordinal from which to extract a field - i.e. the first,
     * second, third or fourth occurrence of the header of the given htype.
     */
    uint8   hposn;

    /**
     * A bit offset into the header which describes the start of the field
     * to be extracted (max. 256B reach)
     */
    uint16  offset;

    /**
     * the length of the field to be extracted; the maximum that may be
     * extracted is 64b which means that values greater than 64 are invalid
     * lengths; note that if the header does not exist then an appropriate
     * number of zero bits are pushed to the stack; a length of zero is
     * meaningful and can be used to push only the exists bit onto the
     * stack
     */
    uint8   length;

    /**
     * Which of up to 16 keys should receive the field value.
     * If all bits are clear here then the key field is not used.
     */
    uint16  key;

    /**
     * Which of up to 16 keys should receive the exists bit for
     * the header; use this to ensure that there is only one exists bit for
     * a given header in a given key. Bit n of this vector is only valid when
     * bit n of the key vector is set.
     */
    uint16  exists;

} ikft_t;

/**
 * 
 * this address space is shared b/b arlfm1 and ght
 * in arlfm1 address space this holds the arlfm key
 * in ght address space holds ght key + associated data. ght may be
 * assigned a role in either logical interface mapping or forward
 * mapping.
 * arlfm0 format- {2-bit updt_ctl, 2-bit fwd_ctl, 16-bit fid, 48-bit mac_lo/hi}
 * arlfm0 format- has 2 entries in a row of 128-bit memory
 * ght format - {1-valid, 1-li_type 12-n_vsi,114-bit key}
 * ght format - has 1 entries in a row of 128-bit memory
 */
typedef struct cb_itm_arlfm1_ght_h1_s {
    /**
     * Bits 0 thru 31 of the GHT key or 32-bits of ARLFM1 mac_lo.
     */
    uint32  ght_key_31_0_arlfm1_mac_lo;

    /**
     * Bits 47 thru 32 of the GHT Key or 16-bits of ARLFM1 mac_hi.
     */
    uint16  ght_key_47_32_arlfm1_mac_hi_15_0;

    /**
     * Bits 59 thru 48 of the GHT Key or 12-bits of ARLFM1 fid.
     */
    uint16  ght_key_59_48_arlfm1_fid_11_0;

    /**
     * Bits 63 thru 60 of the GHT Key or 2-bits of ARLFM1 UPD_CTRL.
     */
    uint8   ght_key_63_62_arlfm1_upd_ctrl_1_0;

    /**
     * Bits 61 thru 60 of the GHT Key or 2-bits of ARLFM1 FWD_CTRL.
     */
    uint8   ght_key_61_60_arlfm1_fwd_ctrl_1_0;

    /**
     * Bits 64 thru 95 of the GHT key or 32-bits of ARLFM1 mac_lo.
     */
    uint32  ght_key_95_64_arlfm1_mac_lo;

    /**
     * Bits 111 thru 96 of GHT key or 16-bits of ARLFM1 mac_hi
     * and 16-bit of ARLFM1 mac- hi.
     */
    uint16  ght_key_111_96_arlfm1_mac_hi;

    /**
     * bits GHT : upper 2-bits of n_vsi
     * bits ARLFM1 : fwd_ctrl
     */
    uint8   ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0;

    /**
     * bits GHT : [27:18] - lower 10-bits of n_vsi
     * bits GHT : [17:16] - 113 thru 112 upper Key bits
     * bits ARLFM1 : [27:0] - 12-bits of FID
     */
    uint16  ght_n_vsi_9_0_key_113_112_arlfm1_fid;

    /**
     * bits GHT : [31] : Valid
     * bits GHT : [30] : LI_TYPE
     * bits ARLFM1 : upd_ctrl
     */
    uint8   ght_valid_litype_arlfm1_upd_ctrl_1_0;

} arlfm1_ght_h1_t;

/**
 * EGRESS PRIORITY MAP TABLE:
 * 
 * the priority map table contains entries used to map the drop
 * precedence (dp[1:0]) and traffic class (tc[1:0]) of the packet
 * being edited to some corresponding field in the final edited
 * header as directed by an encap record directive.
 */
typedef struct cb_epp_epmt_s {
    /**
     * 32 bits of unformatted pri map data
     */
    uint32  pmt_data;

} epmt_t;

/**
 * 
 * per port control which limit the max out standing request over epp bmu tx reorder fifo interface
 * the max value allowed on port 0-7 and port 14-15 is 16 (default value is 16)
 * the max value allowed on port 8-11 is 16 (default value is 16)
 * the max value allowed on port 12-13 is 32 (default value is 16)
 */
typedef struct cb_epp_epp_bmu_tx_reorder_req_lmt_s {
    /**
     * number to be used for Port 0
     */
    uint8   per_port_req_limit;

} epp_bmu_tx_reorder_req_lmt_t;

/**
 * 
 * selects a profile from the profile table for each meter
 */
typedef struct cb_bmu_pptr_s {
    /**
     * profile pointer
     */
    uint8   pointer;

} bmu_pptr_t;

/**
 * ENCAPSULATION RECORD TABLE:
 * 
 * if the dliet indicates that an encapsulation record is
 * to be applied the etm pre-fetches that record for the epp.
 * encapsulation records have variable length and consist
 * of variable length directives.
 * </p><p>
 * the encap field is a byte array of directives. logic determines
 * how many bytes are valid in this array by examining it from the last
 * byte (encap[11]) down to the first byte (encap[0]).
 * if the full bit is set then the number of valid bytes is 12 otherwise
 * if there exists a byte encap[n] where n&lt;12 such that
 * encap[n]==eor and encap[n+i]==0 for all n+i&lt;12 then the
 * number of valid bytes is n otherwise it is 0. note that the eor byte
 * is not transferred from here to the final directives list to the epp.
 * </p><p>
 * note that we have the ability to concatanate two entries from this
 * table to form up to 24b of directives. however please note that if the
 * application demands precisely 12b of directives then we have to use
 * two entries in the ert and the second entry must contain eor at
 * encap[0] and 0 in all encap[1] thru encap[11].
 */
typedef struct cb_etm_ert_s {
    /**
     * The eleventh byte of encap data.
     */
    uint8   encap10;

    /**
     * The tenth byte of encap data.
     */
    uint8   encap9;

    /**
     * The twelfth byte of encap data.
     */
    uint8   encap11;

    /**
     * The ninth byte of encap data.
     */
    uint8   encap8;

    /**
     * The fifth byte of encap data.
     */
    uint8   encap4;

    /**
     * The sixth byte of encap data.
     */
    uint8   encap5;

    /**
     * The eight byte of encap data.
     */
    uint8   encap7;

    /**
     * The seventh byte of encap data.
     */
    uint8   encap6;

    /**
     * The third byte of encap data.
     */
    uint8   encap2;

    /**
     * The fourth byte of encap data.
     */
    uint8   encap3;

    /**
     * The first byte of encap data.
     */
    uint8   encap0;

    /**
     * The second byte of encap data.
     */
    uint8   encap1;

    /**
     * Indicates that all encap bytes in the record are valid and there is
     * no trailing EOR byte.
     */
    uint8   full;

} ert_t;

/**
 * ACTION TABLE:
 * 
 * in-profile actions:
 */
typedef struct cb_cfp_action_s {
    /**
     * If set, and frame is in-profile, then disable learning for this frame. 
     * 
     */
    uint8   ipf_learn_disable;

    /**
     * If non-zero, and the frame is in-profile, this selects one of 15 {destination, TC}
     * configurations which define where the frame is to be forwarded.
     */
    uint8   ipf_trap_offset;

    /**
     * If non-zero, and the frame is in-profile then ingress mirror the frame to this
     * mirror destination
     */
    uint8   ipf_mirror;

    /**
     * If set, and the frame is in-profile, change the TC of the output frame to TC value
     * in action
     */
    uint8   ipf_change_tc;

    /**
     * If the frame is in-profile, this is the TC used when ipf_change_tc is 1. 
     * 
     */
    uint8   ipf_tc;

    /**
     * DLIID, DGID, or SLIID used for in-profile destination override.
     */
    uint32  ipf_dliid_dgid_sliid;

    /**
     * Forward action (if any) when the frame is in-profile.
     * 0 - CF_NOP
     *     Do not change the destination.
     * 4 - CF_SLI_OVERRIDE
     *     Set SLIID (override IP results).
     * 6 - CF_DONT_DROP
     *     Dont drop frame.
     * 2 - CF_FWD_TO_DLIID
     *     Forward to DLIID (i.e. dliid_dgid_sliid is a DLIID).
     * 3 - CF_FWD_TO_DGID
     *     Forward to DGID (i.e. dliid_dgid_sliid is a DGID).
     * 5 - CF_DROP
     *     Drop frame.
     */
    uint8   ipf_change_fwd;

    /**
     * Pointer to entry in HDT for decap if frame is in-profile and Forward action is SLI override. 
     * 
     */
    uint8   ipf_cfp_decap;

    /**
     * If the frame is out-profile, this is the TC used when opf_change_tc is 1. 
     * 
     */
    uint8   opf_tc;

    /**
     * If non-zero, and the frame is out-profile, this selects one of 15 {destination, TC}
     * configurations which define where the frame is to be forwarded.
     */
    uint8   opf_trap_offset;

    /**
     * If set, and frame is out-profile, then disable learning for this frame. 
     * 
     */
    uint8   opf_learn_disable;

    /**
     * If set, and the frame is out-profile, change the TC of the output frame to TC value
     * in action
     */
    uint8   opf_change_tc;

    /**
     * If non-zero, and the frame is out-profile then ingress mirror the frame to this
     * mirror destination
     */
    uint8   opf_mirror;

    /**
     * Forward action (if any) when the frame is out-profile.
     * 0 - CF_NOP
     *     Do not change the destination.
     * 4 - CF_SLI_OVERRIDE
     *     Set SLIID (override IP results).
     * 6 - CF_DONT_DROP
     *     Dont drop frame.
     * 2 - CF_FWD_TO_DLIID
     *     Forward to DLIID (i.e. dliid_dgid_sliid is a DLIID).
     * 3 - CF_FWD_TO_DGID
     *     Forward to DGID (i.e. dliid_dgid_sliid is a DGID).
     * 5 - CF_DROP
     *     Drop frame.
     */
    uint8   opf_change_fwd;

    /**
     * DLIID, DGID, or SLIID used for out-profile destination override.
     */
    uint32  opf_dliid_dgid_sliid;

    /**
     * Pointer to entry in HDT for decap if frame is out-profile and Forward action is SLI override. 
     * 
     */
    uint8   opf_cfp_decap;

    /**
     * DP to be overridden if change_dp is set.
     * 3 - DROP
     *     Used as a drop indicator.
     * 0 - GREEN
     *     Indicates a packet with low drop precedence.
     * 2 - RED
     *     The highest drop precedence.
     * 1 - YELLOW
     *     Indicates a packet of medium drop precedence.
     */
    uint8   dp;

    /**
     * If counter_mode[0]=0, then the associated counters are a byte/packet pair.
     * If counter_mode[0]=1, then the associated counters are an in-profile/out-profile
     * pair. If counter_mode[1]=0, then the counter pair is only updated if there is
     * an active primary policy (including override). If counter_mode[1]=1, then the
     * counter pair is ALWAYS updated.
     */
    uint8   counter_mode;

    /**
     * Select one of 8:0 meters; A value of zero indicates
     * no metering.
     */
    uint16  meter;

    /**
     * When set, Actions of lower priority lookups should be ignored
     * and not merged into the final result.
     */
    uint8   override;

    /**
     * If set, then override the DP used in metering with this DP
     * (if meter = 0, then override output DP).
     */
    uint8   change_dp;

    /**
     * If set, and Change Forard policy is active, then allow frame to be sent back to the
     * port on which is arrived
     */
    uint8   sli_lpbk_ena;

    /**
     * If set, and if dst FM lookup fails, override drop_ulf & drop_mlf (dont drop) 
     * 
     */
    uint8   dlf_override;

} action_t;

/**
 * RECEIVE PROCESSOR SOURCE LOGICAL INTERFACE CONTEXT TABLE:
 * 
 * the rpslict maintains per slic properties. it is indexed by a
 * slicid determined by the slic mapping function.
 */
typedef struct cb_ipp_rpslict_s {
    /**
     * Early Acknowledge. An indication to the BMU to acknowledge a buffer
     * after qualification but potentially before EOP. This is used for
     * cut-through operation.
     */
    uint8   early_ack;

    /**
     * Indicates how to use the default_tc field:
     * 2 - OVERRIDE
     *     Use the SLIC default TC as the TC for the frame.
     * 1 - PG_OVERRIDE
     *     Use the SLIC default TC to override the Port Group default TC only if
     *     the tag parser failed to assign a TC.
     * 0 - DONT_USE
     *     Dont use the SLIC default TC.
     */
    uint8   use_tc;

    /**
     * Indicates how to use the default_dp field:
     * 2 - OVERRIDE
     *     Use the SLIC default TC as the TC for the frame.
     * 1 - PG_OVERRIDE
     *     Use the SLIC default TC to override the Port Group default TC only if
     *     the tag parser failed to assign a TC.
     * 0 - DONT_USE
     *     Dont use the SLIC default TC.
     */
    uint8   use_dp;

    /**
     * Default Traffic Class. Used as a function of the use_tc field.
     */
    uint8   default_tc;

    /**
     * Default Drop Precedence. Used as a function of the use_dp field.
     * 3 - DROP
     *     Used as a drop indicator.
     * 0 - GREEN
     *     Indicates a packet with low drop precedence.
     * 2 - RED
     *     The highest drop precedence.
     * 1 - YELLOW
     *     Indicates a packet of medium drop precedence.
     */
    uint8   default_dp;

} rpslict_t;

/**
 * 
 * each entry holds the ecc of a corresponding tcam word.
 */
typedef struct cb_ipp_slictecc_s {
    /**
     * ECC data of each SLICMAP entry
     */
    uint16  ecc;

} slictecc_t;

/**
 * LOGICAL INTERFACE TRANSMIT ENABLE TABLE:
 * 
 * this table is indexed by dliid.n and returns a single bit
 * indicating that transmits are enabled on the dli.
 */
typedef struct cb_pqm_litet_s {
    /**
     * If set, transmit is enabled for the corresponding N-type DLIID.
     * If clear and a frame is assigned to the corresponding DLI then
     * the PQM will drop that frame.
     */
    uint8   tx_ena;

} litet_t;

/**
 * 
 * each entry holds the ecc of a corresponding tcam word.
 */
typedef struct cb_cfp_tecc_s {
    /**
     * Index to TCAM ECC Memory.
     */
    uint16  ecc;

} tecc_t;

/**
 * 
 * selects a profile from the profile table for each meter
 */
typedef struct cb_cfp_pptr_s {
    /**
     * profile pointer
     */
    uint8   pointer;

} cfp_pptr_t;

/**
 * WIDE RULE TABLE:
 * 
 * wide rule table
 * cfp supports combining an even/odd pair of consecutive rules into a
 * wide rule. this is implemented using the
 * wrt(wide rule table). wrt is a 1024x1b table. if an
 * entry n is 0, it means that rules n*2 and n*2+1 are 2 narrow rules.
 * if entry n is 1, it means the rules n*2 and n*2+1 are combined to form
 * a wide rule.
 */
typedef struct cb_cfp_wrt_s {
    /**
     * 0 - The associated rule pair is not width expanded
     * 1 - The associated rule pair is width expanded.
     */
    uint8   wide_rule_entry;

} wrt_t;

/**
 * WRED PARAMETER TABLE:
 * 
 * this table is index by queue domain/admission profile.
 * </p><p>
 * we implement wred using five basic parameters:
 * <ul>
 * <li>m - a slope parameter</li>
 * <li>c - an intercept parameter</li>
 * <li>t - a threshold</li>
 * <li>s - a probability scale factor</li>
 * <li>g - an ewma gain parameter</li>
 * </ul>
 * </p><p>
 * we calculate a 20b drop probability as:
 * <br/>p=min(2**20-1, max(0, (2**-s)*(m*x+c)))
 * <br/>where x is the exponential weighted moving average
 * (ewma) of a queue domains occupancy.
 * </p><p>
 * the occupancy ewma is calculated per queue domain periodically as
 * <br/>x[i] = (1-2**-g)*x[i-1] + (2**-g)*o
 * <br/>where i is an iteration index, o is the instantaneous queue domain
 * occupancy and g is a gain parameter. note that o can be shifted
 * right by several bits and thus fractional bits are required in the
 * ewma calculation and are also required in the state variable x
 * relative to o.
 * </p><p>
 * a free-running 20b lfsr generates a pseudo-random sequence in the
 * range [1, 2**20-1]. the condition (lfsr<=p) is true with probability
 * p/(2**20-1). note that when p is equal to zero, the condition is
 * never true and when p is equal to 2**20-1 the condition is always
 * true.
 * </p><p>
 * this table maintains the scale and gain parameters, the apt maintains
 * the rest.
 */
typedef struct cb_pqm_wpt_s {
    /**
     * EWMA Gain for Admission Queuing Domain.
     */
    uint8   gain;

    /**
     * Scale for Admission Queuing Domain.
     */
    uint8   scale;

} wpt_t;

/**
 * DESTINATION LOGICAL INTERFACE ENCAPSULATION TABLE:
 * 
 * the dliet is used to determine how
 * to encapsulate a frame on a given dli. it is indexed by dliid.n
 * when that field is valid. it is intended that for vid translation
 * nothing other than the dliet need be accessed assuring high
 * performance for these operations.
 * </p><p>
 * the encap field is a byte array of directives. logic determines
 * how many bytes are valid in this array by examining it from the last
 * byte (encap[7]) down to the first byte (encap[0]).
 * if the full bit is set then the number of valid bytes is 8 otherwise
 * if there exists a byte in encap[n] where n&lt;8 such that
 * encap[n]==eor and encap[n+i]==0 for all n+i&lt;8 then the
 * number of valid bytes is n otherwise it is 0. note that the eor byte
 * is not transferred from here to the final directives list to the epp.
 */
typedef struct cb_etm_dliet_s {
    /**
     * The fifth byte of encap data.
     */
    uint8   encap4;

    /**
     * The sixth byte of encap data.
     */
    uint8   encap5;

    /**
     * The eight byte of encap data.
     */
    uint8   encap7;

    /**
     * The seventh byte of encap data.
     */
    uint8   encap6;

    /**
     * The third byte of encap data.
     */
    uint8   encap2;

    /**
     * The fourth byte of encap data.
     */
    uint8   encap3;

    /**
     * The first byte of encap data.
     */
    uint8   encap0;

    /**
     * The second byte of encap data.
     */
    uint8   encap1;

    /**
     * Unicast Packet Encapsulation pointer to the ERT Table. A value
     * greater than or equal to 255 indicates no data.
     */
    uint8   uc_encap_ptr;

    /**
     * Multicast Packet Encapsulation pointer to the ERT Table. A value
     * greater than or equal to 255 indicates no data.
     */
    uint8   mc_encap_ptr;

    /**
     * Indicates that all encap bytes in the record are valid and there is
     * no trailing EOR byte.
     */
    uint8   full;

} dliet_t;

/**
 * PORT GROUP LEARNING CONTROL TABLE:
 * 
 * this table controls aspects of mac address learning and updating.
 * it is indexed by the low order bits of the slliid presented on the fm
 * interface during a source mac search.
 * these low order bits are the source port group in the case of a pv-type
 * slliid or the low order bits of the n field in an n-type slliid.
 * <p> for an n-type slliid the values from this table only apply if the
 * valid_for_n_type field in the entry is set otherwise the
 * n_type_learn_config register governs the learning and update behaviour.
 */
typedef struct cb_itm_pglct_s {
    /**
     * When this bit is set and the ARL entry is static then the ARL entry
     * will not be updated when station movement is detected. If the upd_ctrl
     * field is not UPDATE then update is controlled by the
     * upd_ctrl field and this bit has no effect.
     */
    uint8   disable_update_static;

    /**
     * When an SMAC doesnt match any Valid/Pending ARL entry and this bit is
     * set then the frame is copied to the CPU.
     */
    uint8   copy_unknown_smac;

    /**
     * When set the validity of a newly learned entry is modified from EMPTY
     * to PENDING and the frame is copied to the CPU.
     * When PENDING a DMAC lookup is considered a miss. The
     * transition from PENDING to VALID is effected by software. When clear
     * the validity is modified from EMPTY to VALID if disable_learn is not
     * set.
     */
    uint8   pend_learn;

    /**
     * When station movement is effected and this bit is set then the causal
     * frame will be copied to the CPU if and only if the fwd_ctrl field for
     * the ARL entry is PERMIT and the entry is in the VALID state.
     */
    uint8   copy_update;

    /**
     * When this bit is set and the ARL entry is pending then the ARL entry
     * will not be updated when station movement is detected. If the upd_ctrl
     * field is not UPDATE then update is controlled by the
     * upd_ctrl field and this bit has no effect.
     */
    uint8   disable_update_pending;

    /**
     * When station movement is effected and this bit is set and the ARL
     * entry is STATIC then the causal frame will be copied to the CPU
     * if and only if the fwd_ctrl field for the ARL entry is PERMIT.
     */
    uint8   copy_update_static;

    /**
     * When the dynamic ARL entry count exceeds the learn limit and the SMAC
     * is unknown and this bit is set then copy the packet to the CPU.
     */
    uint8   copy_overlimit;

    /**
     * Hardware detects station movement when an SMAC matches a VALID ARL entry
     * but the associated PG is different from the port of arrival for the
     * SMAC. If the ARL entrys upd_ctrl field is UPDATE and if this bit is set
     * then the hardware will not update the associated data of non-empty
     * unicast entries (VALID, PENDING and STATIC). If the upd_ctrl field is
     * not UPDATE then update is controlled by the upd_ctrl
     * field and this bit has no effect.
     */
    uint8   disable_update;

    /**
     * Set to disable learning on this port group. Clear (default) to enable. 
     * 
     */
    uint8   disable_learn;

    /**
     * Indicates the maximum number of learn events allowed for this
     * port group. Note that if a station move is detected and the hardware
     * is configured to update the ARL entry and such an update would lead
     * to a port group exceeding its limit then the entry will be
     * marked invalid.
     */
    uint16  learn_limit;

    /**
     * This bit indicates that this PGLCT entry is also valid for
     * N-type SLIs. Note that the entry is always considered valid for
     * PV-type SLIs.
     */
    uint8   valid_for_n_type;

    /**
     * When the number of dynamic ARL entries associated with the
     * corresponding SPG exceeds the learn_limit and the SMAC is unknown
     * and this bit is set then drop the packet. Note that if this bit is
     * clear and the entry count exceeds the limit then the packet is forwarded
     * but the SMAC is not learned.
     */
    uint8   drop_overlimit;

    /**
     * When station movement is effected and this bit is set and the ARL
     * entry is PENDING then the causal frame will be copied to the CPU
     * if and only if the fwd_ctrl field for the ARL entry is PERMIT.
     */
    uint8   copy_update_pending;

} pglct_t;

/**
 * LOCAL PORT GROUP TO ADMISSION PROFILE:
 * 
 * this table is indexed by the local destination port group and returns
 * a 2b per port group admission profile selector. it is used to select a
 * ports egress admission control profile.
 */
typedef struct cb_pqm_lpg2ap_s {
    /**
     * Admission Profile. Selects one of 4 profiles.
     */
    uint8   adm_profile;

} lpg2ap_t;

/**
 * 
 * burst size and rate config for committed bucket
 */
typedef struct cb_pqm_profile_s {
    /**
     * committed burst size exponent
     */
    uint8   cbs_exp;

    /**
     * committed burst size mantissa
     */
    uint8   cbs_mantissa;

    /**
     * committed information rate mantissa
     */
    uint16  cir_mantissa;

    /**
     * committed information rate exponent
     */
    uint8   cir_exp;

    /**
     * excess information rate exponent
     */
    uint8   eir_exp;

    /**
     * excess burst size exponent
     */
    uint8   ebs_exp;

    /**
     * excess information rate mantissa
     */
    uint16  eir_mantissa;

    /**
     * excess burst size mantissa
     */
    uint8   ebs_mantissa;

    /**
     * if set, the drop bit will be set if the resulting color is red
     */
    uint8   drop_on_red;

    /**
     * when set, mtr_req_length is ignored, and config_pkt_mode_len is used
     * instead
     */
    uint8   pkt_mode;

    /**
     * if set, a packet conforms to bktc only if the number of tokens is greater
     * than or equal to the packet length; otherwise the packet conforms as long
     * as the token count is non-negative
     */
    uint8   bktc_strict;

    /**
     * if set, a packet conforms to bkte only if the number of tokens is greater
     * than or equal to the packet length; otherwise the packet conforms as long
     * as the token count is non-negative
     */
    uint8   bkte_strict;

    /**
     * coupling flag
     * tokens being added to bktc will be diverted to bkte if bktc is full
     */
    uint8   cf;

    /**
     * if set, both bktc and bkte must have sufficient tokens to color a packet
     * green; otherwise only bktc must have sufficient tokens
     */
    uint8   rfc2698;

    /**
     * if set, meter operates in color-blind mode
     */
    uint8   blind;

    /**
     * reserved for future use
     */
    uint8   avb_mode;

} pqm_profile_t;

/**
 * CANONICAL PRIORITY MAPPING TABLE:
 * 
 * the cpmt consists of 384 entries where each entry
 * contains a canonical {tc, dp}. this table is indexed by a winning cos
 * field extracted from a frame as determined by the srcn fields in the
 * pgt offset from a corresponding pri_basen field (also in the
 * pgt). the cpmt provides for up to 48 8-entry
 * maps, 24 16-entry maps,
 * 12 32-entry maps or
 * 6 64-entry maps or any combination of
 * these that does not exceed 384 entries
 * in total.</p>
 * <p>the default arrangement of the cpmt contains 16
 * {pcp, dei} maps (one per physical port) that map pcp directly to
 * tc and dei of zero to dp of green, dei of one to dp of yellow. the map
 * for port n is located at offset n*16 in the cpmt. </p>
 * <p>additionally (by default) the cpmt contains two 64 entry dscp
 * maps at offsets 256 and
 * 320. these maps are defaulted such that all
 * dscp values map to dp of green and all dscp values map to tc of zero
 * except for the following:
 * <ul>
 * <li>dscp=10 maps to tc=2</li>
 * <li>dscp=18 maps to tc=1</li>
 * <li>dscp=26 maps to tc=3</li>
 * <li>dscp=34 maps to tc=4</li>
 * <li>dscp=46 maps to tc=5</li>
 * <li>dscp=48 maps to tc=6</li>
 * <li>dscp=56 maps to tc=7</li>
 * </ul>
 */
typedef struct cb_ipp_cpmt_s {
    /**
     * Traffic Class. A canonical notion of traffic class used by the
     * device. 0 is notionally the lowest priority while 7 is notionally
     * the highest.
     */
    uint8   tc;

    /**
     * Drop Precedence. A canonical notion of drop precedence used by the
     * device. A value of zero represents low drop precedence and is
     * referred to as green.
     * 3 - DROP
     *     Used as a drop indicator.
     * 0 - GREEN
     *     Indicates a packet with low drop precedence.
     * 2 - RED
     *     The highest drop precedence.
     * 1 - YELLOW
     *     Indicates a packet of medium drop precedence.
     */
    uint8   dp;

} cpmt_t;

/**
 * PHYSICAL PORT TO LOCAL PORT GROUP MAP:
 * 
 * the pp2lpg map is indexed by ppid and returns the corresponding
 * local pgid. we distinguish between local and global port groups
 * because the namespace for local port groups is smaller than that
 * for global port groups and this is used to benefit in the sizing
 * of certain tables.
 * note that several pps can map to a single pg. note that
 * the legal pgid range is [0, 15] - there
 * cannot be more local port groups than there are ports.
 */
typedef struct cb_pqm_pp2lpg_s {
    /**
     * Indicates the local port group to which this physical port belongs.
     * This field initializes to its PP2LPG index.
     */
    uint8   pgid;

} pqm_pp2lpg_t;

/**
 * 
 * this table contains mac associations used for forwarding.
 */
typedef struct cb_itm_ofarlfm_s {
    /**
     * Bits 31 thru 0 of the 48b Ethernet MAC address.
     */
    uint32  mac_lo;

    /**
     * The Filter Identifier. Used to segregate entries in the ARL.
     */
    uint16  fid;

    /**
     * Indicates actions to take when station movement is detected.
     * When this field is UPDATE then the update actions specified by the
     * PGLCT have priority. When this field is UPDATE_AND_COPY, COPY or
     * DISABLE_UPDATE then the PGLCT update actions are ignored.
     * 2 - COPY
     *     When movement is detected dont update the ARL entry but do copy
     *     the frame to the CPU.
     * 1 - UPDATE_AND_COPY
     *     When movement is detected update the ARL entry and copy to the CPU.
     * 0 - UPDATE
     *     When station movement is detected update the ARL entrys associated
     *     destination data.
     * 3 - DISABLE_UPDATE
     *     Do not allow ARL entry update.
     */
    uint8   upd_ctrl;

    /**
     * Bits 47 thru 32 of the 48b Ethernet MAC address.
     */
    uint16  mac_hi;

    /**
     * Indicates how to forward a frame.
     * 2 - COPY_TO_CPU
     *     Standard forwarding and unconditionally generate an additional
     *     copy for the Control Plane.
     * 1 - DENY_SMAC
     *     If this is returned as the result of an SMAC lookup then the
     *     frame will be discarded. Note that denying DMACs can be accomplished
     *     by setting the dst_type field to DST_IS_INVALID in ARLFM. If this is
     *     returned as the result of a DMAC lookup then the frame will be
     *     forwarded normally.
     * 3 - DENY_SMAC_AND_COPY_TO_CPU
     *     Deny and unconditionally generate an additional
     *     copy for the Control Plane.
     * 0 - PERMIT
     *     Standard forwarding. Allow frame to be forwarded normally.
     */
    uint8   fwd_ctrl;

    /**
     * Indicates the validity of an entry.
     * 2 - VALID
     *     Indicates that this is a valid entry.
     * 3 - STATIC
     *     Indicates that the entry belongs wholly to software, hardware
     *     may not age it. Hardware updates the associated data
     *     when a station move is detected if and only if upd_ctrl is UPDATE
     *     or UPDATE_AND_COPY.
     * 1 - PENDING
     *     Indicates that the hash table entry has been learned by hardware
     *     but not sanctioned by software, eligible for aging. Counts as a miss
     *     for forwarding purposes but suppresses continued notification of
     *     software.
     * 0 - EMPTY
     *     Indicates that the hash table entry is empty.
     */
    uint8   valid;

    /**
     * Destination field. This indicates how to forward a frame. Its precise
     * semantic is determined by the dst_type field.
     */
    uint16  dst;

    /**
     * Indicates the type of the dst field.
     * 3 - DST_IS_DPG
     *     Indicates that the dst field is a Destination Port Group.
     * 0 - DST_IS_INVALID
     *     If this is returned on a DMAC lookup of the ARLFM then the
     *     causal frame will be dropped.
     * 2 - DST_IS_N
     *     Indicates that the dst field is the N field of an N-type LI.
     * 1 - DST_IS_MULTICAST
     *     Indicates that the dst field is a Destination Group Identifier.
     */
    uint8   dst_type;

    /**
     * Set by hardware when a lookup hits this entry. Cleared periodically
     * by the aging process. If the aging process encounters a valid
     * non-static entry that has the hit bit clear then it marks the entry
     * as invalid (aging it out).
     */
    uint8   hit;

} ofarlfm_t;

/**
 * Table ids
 */
typedef enum {
    ROBO2_TABLE_TCT_ID                  = 0,
    ROBO2_TABLE_RPT_ID                  = 1,
    ROBO2_TABLE_PGT_ID                  = 2,
    ROBO2_TABLE_PMIPAGE_ID              = 3,
    ROBO2_TABLE_GFCD_CONFIG_ID          = 4,
    ROBO2_TABLE_APT_ID                  = 5,
    ROBO2_TABLE_GFCD_CNTR_ID            = 6,
    ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID    = 7,
    ROBO2_TABLE_DGT_ID                  = 8,
    ROBO2_TABLE_GSPG2IG_ID              = 9,
    ROBO2_TABLE_EPP_CALENDAR_ID         = 10,
    ROBO2_TABLE_GHT_ID                  = 11,
    ROBO2_TABLE_LIN2VSI_ID              = 12,
    ROBO2_TABLE_CFP_PROFILE_ID          = 13,
    ROBO2_TABLE_CFP_BUCKET_ID           = 14,
    ROBO2_TABLE_CALENDAR_ID             = 15,
    ROBO2_TABLE_PG2LPG_ID               = 16,
    ROBO2_TABLE_ARLFM_ID                = 17,
    ROBO2_TABLE_ARLFM0_ID               = 18,
    ROBO2_TABLE_IPP_BUCKET_ID           = 19,
    ROBO2_TABLE_FCD_CONFIG_ID           = 20,
    ROBO2_TABLE_STAT_ID                 = 21,
    ROBO2_TABLE_EEECFG_ID               = 22,
    ROBO2_TABLE_HDT_ID                  = 23,
    ROBO2_TABLE_ESTGET_ID               = 24,
    ROBO2_TABLE_STT_ID                  = 25,
    ROBO2_TABLE_PET_ID                  = 26,
    ROBO2_TABLE_ISTGET_ID               = 27,
    ROBO2_TABLE_QDSCHCFG_ID             = 28,
    ROBO2_TABLE_PQM_RSCALE_ID           = 29,
    ROBO2_TABLE_MTR2TCB_ID              = 30,
    ROBO2_TABLE_DLI2LDPG_ID             = 31,
    ROBO2_TABLE_TC2QD_ID                = 32,
    ROBO2_TABLE_SPLDT_ID                = 33,
    ROBO2_TABLE_CFP_RSCALE_ID           = 34,
    ROBO2_TABLE_GHTDT_ID                = 35,
    ROBO2_TABLE_BMU_BUCKET_ID           = 36,
    ROBO2_TABLE_LILT_ID                 = 37,
    ROBO2_TABLE_SVT_ID                  = 38,
    ROBO2_TABLE_SLICMAP_ID              = 39,
    ROBO2_TABLE_M2TK_ID                 = 40,
    ROBO2_TABLE_ART_ID                  = 41,
    ROBO2_TABLE_LPG2IG_ID               = 42,
    ROBO2_TABLE_IPP_PROFILE_ID          = 43,
    ROBO2_TABLE_QFCQDADDR_ID            = 44,
    ROBO2_TABLE_MTGT_ID                 = 45,
    ROBO2_TABLE_IPP_PPTR_ID             = 46,
    ROBO2_TABLE_SET_ID                  = 47,
    ROBO2_TABLE_SRT_ID                  = 48,
    ROBO2_TABLE_IPP_PMON_ID             = 49,
    ROBO2_TABLE_VTCT_ID                 = 50,
    ROBO2_TABLE_CFPCAM_ID               = 51,
    ROBO2_TABLE_FCD_CNTR_ID             = 52,
    ROBO2_TABLE_FPSLICT_ID              = 53,
    ROBO2_TABLE_KST_ID                  = 54,
    ROBO2_TABLE_PQM_BUCKET_ID           = 55,
    ROBO2_TABLE_GHST_ID                 = 56,
    ROBO2_TABLE_LPG2PG_ID               = 57,
    ROBO2_TABLE_EPGT_ID                 = 58,
    ROBO2_TABLE_BMU_RSCALE_ID           = 59,
    ROBO2_TABLE_LPG2PPFOV_ID            = 60,
    ROBO2_TABLE_VSIT_ID                 = 61,
    ROBO2_TABLE_QFCCREDIT_ID            = 62,
    ROBO2_TABLE_TET_ID                  = 63,
    ROBO2_TABLE_IPP_PP2LPG_ID           = 64,
    ROBO2_TABLE_PQM_PPTR_ID             = 65,
    ROBO2_TABLE_BMU_PMON_ID             = 66,
    ROBO2_TABLE_ETCT_ID                 = 67,
    ROBO2_TABLE_ARLFM1_GHT_H0_ID        = 68,
    ROBO2_TABLE_CFP_PMON_ID             = 69,
    ROBO2_TABLE_MAX_CONFIG_ID           = 70,
    ROBO2_TABLE_BMU_PROFILE_ID          = 71,
    ROBO2_TABLE_PV2LI_ID                = 72,
    ROBO2_TABLE_IPP_RSCALE_ID           = 73,
    ROBO2_TABLE_PQM_PMON_ID             = 74,
    ROBO2_TABLE_IKFT_ID                 = 75,
    ROBO2_TABLE_ARLFM1_GHT_H1_ID        = 76,
    ROBO2_TABLE_EPMT_ID                 = 77,
    ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID = 78,
    ROBO2_TABLE_BMU_PPTR_ID             = 79,
    ROBO2_TABLE_ERT_ID                  = 80,
    ROBO2_TABLE_ACTION_ID               = 81,
    ROBO2_TABLE_RPSLICT_ID              = 82,
    ROBO2_TABLE_SLICTECC_ID             = 83,
    ROBO2_TABLE_LITET_ID                = 84,
    ROBO2_TABLE_TECC_ID                 = 85,
    ROBO2_TABLE_CFP_PPTR_ID             = 86,
    ROBO2_TABLE_WRT_ID                  = 87,
    ROBO2_TABLE_WPT_ID                  = 88,
    ROBO2_TABLE_DLIET_ID                = 89,
    ROBO2_TABLE_PGLCT_ID                = 90,
    ROBO2_TABLE_LPG2AP_ID               = 91,
    ROBO2_TABLE_PQM_PROFILE_ID          = 92,
    ROBO2_TABLE_CPMT_ID                 = 93,
    ROBO2_TABLE_PQM_PP2LPG_ID           = 94,
    ROBO2_TABLE_OFARLFM_ID              = 95,
} soc_robo2_table_id_t;


/* Declaration for supported routines */
extern int soc_robo2_action_disable(int unit);
extern int soc_robo2_action_enable(int unit);
extern int soc_robo2_action_get(int unit, int index, action_t *entry);
extern int soc_robo2_action_init(int unit, int start, int end,
                                 int inc, action_t *entry);
extern int soc_robo2_action_max_index(int unit);
extern int soc_robo2_action_reset(int unit);
extern int soc_robo2_action_set(int unit, int index,
                                action_t *entry, uint32 *status);
extern int soc_robo2_apt_disable(int unit);
extern int soc_robo2_apt_enable(int unit);
extern int soc_robo2_apt_get(int unit, int index, apt_t *entry);
extern int soc_robo2_apt_init(int unit, int start, int end,
                              int inc, apt_t *entry);
extern int soc_robo2_apt_max_index(int unit);
extern int soc_robo2_apt_reset(int unit);
extern int soc_robo2_apt_set(int unit, int index,
                             apt_t *entry, uint32 *status);
extern int soc_robo2_arlfm0_disable(int unit);
extern int soc_robo2_arlfm0_enable(int unit);
extern int soc_robo2_arlfm0_get(int unit, int index, arlfm0_t *entry);
extern int soc_robo2_arlfm0_init(int unit, int start, int end,
                                 int inc, arlfm0_t *entry);
extern int soc_robo2_arlfm0_max_index(int unit);
extern int soc_robo2_arlfm0_reset(int unit);
extern int soc_robo2_arlfm0_set(int unit, int index,
                                arlfm0_t *entry, uint32 *status);
extern int soc_robo2_arlfm1_ght_h0_disable(int unit);
extern int soc_robo2_arlfm1_ght_h0_enable(int unit);
extern int soc_robo2_arlfm1_ght_h0_get(int unit, int index,
                                       arlfm1_ght_h0_t *entry);
extern int soc_robo2_arlfm1_ght_h0_init(int unit, int start, int end,
                                        int inc, arlfm1_ght_h0_t *entry);
extern int soc_robo2_arlfm1_ght_h0_max_index(int unit);
extern int soc_robo2_arlfm1_ght_h0_reset(int unit);
extern int soc_robo2_arlfm1_ght_h0_set(int unit, int index,
                                       arlfm1_ght_h0_t *entry, uint32 *status);
extern int soc_robo2_arlfm1_ght_h1_disable(int unit);
extern int soc_robo2_arlfm1_ght_h1_enable(int unit);
extern int soc_robo2_arlfm1_ght_h1_get(int unit, int index,
                                       arlfm1_ght_h1_t *entry);
extern int soc_robo2_arlfm1_ght_h1_init(int unit, int start, int end,
                                        int inc, arlfm1_ght_h1_t *entry);
extern int soc_robo2_arlfm1_ght_h1_max_index(int unit);
extern int soc_robo2_arlfm1_ght_h1_reset(int unit);
extern int soc_robo2_arlfm1_ght_h1_set(int unit, int index,
                                       arlfm1_ght_h1_t *entry, uint32 *status);
extern int soc_robo2_arlfm_disable(int unit);
extern int soc_robo2_arlfm_enable(int unit);
extern int soc_robo2_arlfm_get(int unit, int index, arlfm_t *entry);
extern int soc_robo2_arlfm_init(int unit, int start, int end,
                                int inc, arlfm_t *entry);
extern int soc_robo2_arlfm_max_index(int unit);
extern int soc_robo2_arlfm_reset(int unit);
extern int soc_robo2_arlfm_set(int unit, int index,
                               arlfm_t *entry, uint32 *status);
extern int soc_robo2_art_disable(int unit);
extern int soc_robo2_art_enable(int unit);
extern int soc_robo2_art_get(int unit, int index, art_t *entry);
extern int soc_robo2_art_init(int unit, int start, int end,
                              int inc, art_t *entry);
extern int soc_robo2_art_max_index(int unit);
extern int soc_robo2_art_reset(int unit);
extern int soc_robo2_art_set(int unit, int index,
                             art_t *entry, uint32 *status);
extern int soc_robo2_bmu_bucket_disable(int unit);
extern int soc_robo2_bmu_bucket_enable(int unit);
extern int soc_robo2_bmu_bucket_get(int unit, int index,
                                    bmu_bucket_t *entry);
extern int soc_robo2_bmu_bucket_init(int unit, int start, int end,
                                     int inc, bmu_bucket_t *entry);
extern int soc_robo2_bmu_bucket_max_index(int unit);
extern int soc_robo2_bmu_bucket_reset(int unit);
extern int soc_robo2_bmu_bucket_set(int unit, int index,
                                    bmu_bucket_t *entry, uint32 *status);
extern int soc_robo2_bmu_pmon_disable(int unit);
extern int soc_robo2_bmu_pmon_enable(int unit);
extern int soc_robo2_bmu_pmon_get(int unit, int index, bmu_pmon_t *entry);
extern int soc_robo2_bmu_pmon_init(int unit, int start, int end,
                                   int inc, bmu_pmon_t *entry);
extern int soc_robo2_bmu_pmon_max_index(int unit);
extern int soc_robo2_bmu_pmon_reset(int unit);
extern int soc_robo2_bmu_pmon_set(int unit, int index,
                                  bmu_pmon_t *entry, uint32 *status);
extern int soc_robo2_bmu_pptr_disable(int unit);
extern int soc_robo2_bmu_pptr_enable(int unit);
extern int soc_robo2_bmu_pptr_get(int unit, int index, bmu_pptr_t *entry);
extern int soc_robo2_bmu_pptr_init(int unit, int start, int end,
                                   int inc, bmu_pptr_t *entry);
extern int soc_robo2_bmu_pptr_max_index(int unit);
extern int soc_robo2_bmu_pptr_reset(int unit);
extern int soc_robo2_bmu_pptr_set(int unit, int index,
                                  bmu_pptr_t *entry, uint32 *status);
extern int soc_robo2_bmu_profile_disable(int unit);
extern int soc_robo2_bmu_profile_enable(int unit);
extern int soc_robo2_bmu_profile_get(int unit, int index,
                                     bmu_profile_t *entry);
extern int soc_robo2_bmu_profile_init(int unit, int start, int end,
                                      int inc, bmu_profile_t *entry);
extern int soc_robo2_bmu_profile_max_index(int unit);
extern int soc_robo2_bmu_profile_reset(int unit);
extern int soc_robo2_bmu_profile_set(int unit, int index,
                                     bmu_profile_t *entry, uint32 *status);
extern int soc_robo2_bmu_rscale_disable(int unit);
extern int soc_robo2_bmu_rscale_enable(int unit);
extern int soc_robo2_bmu_rscale_get(int unit, int index,
                                    bmu_rscale_t *entry);
extern int soc_robo2_bmu_rscale_init(int unit, int start, int end,
                                     int inc, bmu_rscale_t *entry);
extern int soc_robo2_bmu_rscale_max_index(int unit);
extern int soc_robo2_bmu_rscale_reset(int unit);
extern int soc_robo2_bmu_rscale_set(int unit, int index,
                                    bmu_rscale_t *entry, uint32 *status);
extern int soc_robo2_calendar_disable(int unit);
extern int soc_robo2_calendar_enable(int unit);
extern int soc_robo2_calendar_get(int unit, int index, calendar_t *entry);
extern int soc_robo2_calendar_init(int unit, int start, int end,
                                   int inc, calendar_t *entry);
extern int soc_robo2_calendar_max_index(int unit);
extern int soc_robo2_calendar_reset(int unit);
extern int soc_robo2_calendar_set(int unit, int index,
                                  calendar_t *entry, uint32 *status);
extern int soc_robo2_cfp_bucket_disable(int unit);
extern int soc_robo2_cfp_bucket_enable(int unit);
extern int soc_robo2_cfp_bucket_get(int unit, int index,
                                    cfp_bucket_t *entry);
extern int soc_robo2_cfp_bucket_init(int unit, int start, int end,
                                     int inc, cfp_bucket_t *entry);
extern int soc_robo2_cfp_bucket_max_index(int unit);
extern int soc_robo2_cfp_bucket_reset(int unit);
extern int soc_robo2_cfp_bucket_set(int unit, int index,
                                    cfp_bucket_t *entry, uint32 *status);
extern int soc_robo2_cfp_pmon_disable(int unit);
extern int soc_robo2_cfp_pmon_enable(int unit);
extern int soc_robo2_cfp_pmon_get(int unit, int index, cfp_pmon_t *entry);
extern int soc_robo2_cfp_pmon_init(int unit, int start, int end,
                                   int inc, cfp_pmon_t *entry);
extern int soc_robo2_cfp_pmon_max_index(int unit);
extern int soc_robo2_cfp_pmon_reset(int unit);
extern int soc_robo2_cfp_pmon_set(int unit, int index,
                                  cfp_pmon_t *entry, uint32 *status);
extern int soc_robo2_cfp_pptr_disable(int unit);
extern int soc_robo2_cfp_pptr_enable(int unit);
extern int soc_robo2_cfp_pptr_get(int unit, int index, cfp_pptr_t *entry);
extern int soc_robo2_cfp_pptr_init(int unit, int start, int end,
                                   int inc, cfp_pptr_t *entry);
extern int soc_robo2_cfp_pptr_max_index(int unit);
extern int soc_robo2_cfp_pptr_reset(int unit);
extern int soc_robo2_cfp_pptr_set(int unit, int index,
                                  cfp_pptr_t *entry, uint32 *status);
extern int soc_robo2_cfp_profile_disable(int unit);
extern int soc_robo2_cfp_profile_enable(int unit);
extern int soc_robo2_cfp_profile_get(int unit, int index,
                                     cfp_profile_t *entry);
extern int soc_robo2_cfp_profile_init(int unit, int start, int end,
                                      int inc, cfp_profile_t *entry);
extern int soc_robo2_cfp_profile_max_index(int unit);
extern int soc_robo2_cfp_profile_reset(int unit);
extern int soc_robo2_cfp_profile_set(int unit, int index,
                                     cfp_profile_t *entry, uint32 *status);
extern int soc_robo2_cfp_rscale_disable(int unit);
extern int soc_robo2_cfp_rscale_enable(int unit);
extern int soc_robo2_cfp_rscale_get(int unit, int index,
                                    cfp_rscale_t *entry);
extern int soc_robo2_cfp_rscale_init(int unit, int start, int end,
                                     int inc, cfp_rscale_t *entry);
extern int soc_robo2_cfp_rscale_max_index(int unit);
extern int soc_robo2_cfp_rscale_reset(int unit);
extern int soc_robo2_cfp_rscale_set(int unit, int index,
                                    cfp_rscale_t *entry, uint32 *status);
extern int soc_robo2_cfpcam_disable(int unit);
extern int soc_robo2_cfpcam_enable(int unit);
extern int soc_robo2_cfpcam_get(int unit, int index, cfpcam_t *entry);
extern int soc_robo2_cfpcam_init(int unit, int start, int end,
                                 int inc, cfpcam_t *entry);
extern int soc_robo2_cfpcam_max_index(int unit);
extern int soc_robo2_cfpcam_reset(int unit);
extern int soc_robo2_cfpcam_set(int unit, int index,
                                cfpcam_t *entry, uint32 *status);
extern int soc_robo2_cpmt_disable(int unit);
extern int soc_robo2_cpmt_enable(int unit);
extern int soc_robo2_cpmt_get(int unit, int index, cpmt_t *entry);
extern int soc_robo2_cpmt_init(int unit, int start, int end,
                               int inc, cpmt_t *entry);
extern int soc_robo2_cpmt_max_index(int unit);
extern int soc_robo2_cpmt_reset(int unit);
extern int soc_robo2_cpmt_set(int unit, int index,
                              cpmt_t *entry, uint32 *status);
extern int soc_robo2_dgt_disable(int unit);
extern int soc_robo2_dgt_enable(int unit);
extern int soc_robo2_dgt_get(int unit, int index, dgt_t *entry);
extern int soc_robo2_dgt_init(int unit, int start, int end,
                              int inc, dgt_t *entry);
extern int soc_robo2_dgt_max_index(int unit);
extern int soc_robo2_dgt_reset(int unit);
extern int soc_robo2_dgt_set(int unit, int index,
                             dgt_t *entry, uint32 *status);
extern int soc_robo2_dli2ldpg_disable(int unit);
extern int soc_robo2_dli2ldpg_enable(int unit);
extern int soc_robo2_dli2ldpg_get(int unit, int index, dli2ldpg_t *entry);
extern int soc_robo2_dli2ldpg_init(int unit, int start, int end,
                                   int inc, dli2ldpg_t *entry);
extern int soc_robo2_dli2ldpg_max_index(int unit);
extern int soc_robo2_dli2ldpg_reset(int unit);
extern int soc_robo2_dli2ldpg_set(int unit, int index,
                                  dli2ldpg_t *entry, uint32 *status);
extern int soc_robo2_dliet_disable(int unit);
extern int soc_robo2_dliet_enable(int unit);
extern int soc_robo2_dliet_get(int unit, int index, dliet_t *entry);
extern int soc_robo2_dliet_init(int unit, int start, int end,
                                int inc, dliet_t *entry);
extern int soc_robo2_dliet_max_index(int unit);
extern int soc_robo2_dliet_reset(int unit);
extern int soc_robo2_dliet_set(int unit, int index,
                               dliet_t *entry, uint32 *status);
extern int soc_robo2_eeecfg_disable(int unit);
extern int soc_robo2_eeecfg_enable(int unit);
extern int soc_robo2_eeecfg_get(int unit, int index, eeecfg_t *entry);
extern int soc_robo2_eeecfg_init(int unit, int start, int end,
                                 int inc, eeecfg_t *entry);
extern int soc_robo2_eeecfg_max_index(int unit);
extern int soc_robo2_eeecfg_reset(int unit);
extern int soc_robo2_eeecfg_set(int unit, int index,
                                eeecfg_t *entry, uint32 *status);
extern int soc_robo2_epgt_disable(int unit);
extern int soc_robo2_epgt_enable(int unit);
extern int soc_robo2_epgt_get(int unit, int index, epgt_t *entry);
extern int soc_robo2_epgt_init(int unit, int start, int end,
                               int inc, epgt_t *entry);
extern int soc_robo2_epgt_max_index(int unit);
extern int soc_robo2_epgt_reset(int unit);
extern int soc_robo2_epgt_set(int unit, int index,
                              epgt_t *entry, uint32 *status);
extern int soc_robo2_epmt_disable(int unit);
extern int soc_robo2_epmt_enable(int unit);
extern int soc_robo2_epmt_get(int unit, int index, epmt_t *entry);
extern int soc_robo2_epmt_init(int unit, int start, int end,
                               int inc, epmt_t *entry);
extern int soc_robo2_epmt_max_index(int unit);
extern int soc_robo2_epmt_reset(int unit);
extern int soc_robo2_epmt_set(int unit, int index,
                              epmt_t *entry, uint32 *status);
extern int soc_robo2_epp_bmu_tx_reorder_req_lmt_disable(int unit);
extern int soc_robo2_epp_bmu_tx_reorder_req_lmt_enable(int unit);
extern int soc_robo2_epp_bmu_tx_reorder_req_lmt_get(int unit, int index,
                                                    epp_bmu_tx_reorder_req_lmt_t *entry);
extern int soc_robo2_epp_bmu_tx_reorder_req_lmt_init(int unit, int start, int end,
                                                     int inc, epp_bmu_tx_reorder_req_lmt_t *entry);
extern int soc_robo2_epp_bmu_tx_reorder_req_lmt_max_index(int unit);
extern int soc_robo2_epp_bmu_tx_reorder_req_lmt_reset(int unit);
extern int soc_robo2_epp_bmu_tx_reorder_req_lmt_set(int unit, int index,
                                                    epp_bmu_tx_reorder_req_lmt_t *entry, uint32 *status);
extern int soc_robo2_epp_calendar_disable(int unit);
extern int soc_robo2_epp_calendar_enable(int unit);
extern int soc_robo2_epp_calendar_get(int unit, int index,
                                      epp_calendar_t *entry);
extern int soc_robo2_epp_calendar_init(int unit, int start, int end,
                                       int inc, epp_calendar_t *entry);
extern int soc_robo2_epp_calendar_max_index(int unit);
extern int soc_robo2_epp_calendar_reset(int unit);
extern int soc_robo2_epp_calendar_set(int unit, int index,
                                      epp_calendar_t *entry, uint32 *status);
extern int soc_robo2_ert_disable(int unit);
extern int soc_robo2_ert_enable(int unit);
extern int soc_robo2_ert_get(int unit, int index, ert_t *entry);
extern int soc_robo2_ert_init(int unit, int start, int end,
                              int inc, ert_t *entry);
extern int soc_robo2_ert_max_index(int unit);
extern int soc_robo2_ert_reset(int unit);
extern int soc_robo2_ert_set(int unit, int index,
                             ert_t *entry, uint32 *status);
extern int soc_robo2_estget_disable(int unit);
extern int soc_robo2_estget_enable(int unit);
extern int soc_robo2_estget_get(int unit, int index, estget_t *entry);
extern int soc_robo2_estget_init(int unit, int start, int end,
                                 int inc, estget_t *entry);
extern int soc_robo2_estget_max_index(int unit);
extern int soc_robo2_estget_reset(int unit);
extern int soc_robo2_estget_set(int unit, int index,
                                estget_t *entry, uint32 *status);
extern int soc_robo2_etct_disable(int unit);
extern int soc_robo2_etct_enable(int unit);
extern int soc_robo2_etct_get(int unit, int index, etct_t *entry);
extern int soc_robo2_etct_init(int unit, int start, int end,
                               int inc, etct_t *entry);
extern int soc_robo2_etct_max_index(int unit);
extern int soc_robo2_etct_reset(int unit);
extern int soc_robo2_etct_set(int unit, int index,
                              etct_t *entry, uint32 *status);
extern int soc_robo2_fcd_cntr_disable(int unit);
extern int soc_robo2_fcd_cntr_enable(int unit);
extern int soc_robo2_fcd_cntr_get(int unit, int index, fcd_cntr_t *entry);
extern int soc_robo2_fcd_cntr_init(int unit, int start, int end,
                                   int inc, fcd_cntr_t *entry);
extern int soc_robo2_fcd_cntr_max_index(int unit);
extern int soc_robo2_fcd_cntr_reset(int unit);
extern int soc_robo2_fcd_cntr_set(int unit, int index,
                                  fcd_cntr_t *entry, uint32 *status);
extern int soc_robo2_fcd_config_disable(int unit);
extern int soc_robo2_fcd_config_enable(int unit);
extern int soc_robo2_fcd_config_get(int unit, int index,
                                    fcd_config_t *entry);
extern int soc_robo2_fcd_config_init(int unit, int start, int end,
                                     int inc, fcd_config_t *entry);
extern int soc_robo2_fcd_config_max_index(int unit);
extern int soc_robo2_fcd_config_reset(int unit);
extern int soc_robo2_fcd_config_set(int unit, int index,
                                    fcd_config_t *entry, uint32 *status);
extern int soc_robo2_fpslict_disable(int unit);
extern int soc_robo2_fpslict_enable(int unit);
extern int soc_robo2_fpslict_get(int unit, int index, fpslict_t *entry);
extern int soc_robo2_fpslict_init(int unit, int start, int end,
                                  int inc, fpslict_t *entry);
extern int soc_robo2_fpslict_max_index(int unit);
extern int soc_robo2_fpslict_reset(int unit);
extern int soc_robo2_fpslict_set(int unit, int index,
                                 fpslict_t *entry, uint32 *status);
extern int soc_robo2_gfcd_cntr_disable(int unit);
extern int soc_robo2_gfcd_cntr_enable(int unit);
extern int soc_robo2_gfcd_cntr_get(int unit, int index, gfcd_cntr_t *entry);
extern int soc_robo2_gfcd_cntr_init(int unit, int start, int end,
                                    int inc, gfcd_cntr_t *entry);
extern int soc_robo2_gfcd_cntr_max_index(int unit);
extern int soc_robo2_gfcd_cntr_reset(int unit);
extern int soc_robo2_gfcd_cntr_set(int unit, int index,
                                   gfcd_cntr_t *entry, uint32 *status);
extern int soc_robo2_gfcd_config_disable(int unit);
extern int soc_robo2_gfcd_config_enable(int unit);
extern int soc_robo2_gfcd_config_get(int unit, int index,
                                     gfcd_config_t *entry);
extern int soc_robo2_gfcd_config_init(int unit, int start, int end,
                                      int inc, gfcd_config_t *entry);
extern int soc_robo2_gfcd_config_max_index(int unit);
extern int soc_robo2_gfcd_config_reset(int unit);
extern int soc_robo2_gfcd_config_set(int unit, int index,
                                     gfcd_config_t *entry, uint32 *status);
extern int soc_robo2_ghst_disable(int unit);
extern int soc_robo2_ghst_enable(int unit);
extern int soc_robo2_ghst_get(int unit, int index, ghst_t *entry);
extern int soc_robo2_ghst_init(int unit, int start, int end,
                               int inc, ghst_t *entry);
extern int soc_robo2_ghst_max_index(int unit);
extern int soc_robo2_ghst_reset(int unit);
extern int soc_robo2_ghst_set(int unit, int index,
                              ghst_t *entry, uint32 *status);
extern int soc_robo2_ght_disable(int unit);
extern int soc_robo2_ght_enable(int unit);
extern int soc_robo2_ght_get(int unit, int index, ght_t *entry);
extern int soc_robo2_ght_init(int unit, int start, int end,
                              int inc, ght_t *entry);
extern int soc_robo2_ght_max_index(int unit);
extern int soc_robo2_ght_reset(int unit);
extern int soc_robo2_ght_set(int unit, int index,
                             ght_t *entry, uint32 *status);
extern int soc_robo2_ghtdt_disable(int unit);
extern int soc_robo2_ghtdt_enable(int unit);
extern int soc_robo2_ghtdt_get(int unit, int index, ghtdt_t *entry);
extern int soc_robo2_ghtdt_init(int unit, int start, int end,
                                int inc, ghtdt_t *entry);
extern int soc_robo2_ghtdt_max_index(int unit);
extern int soc_robo2_ghtdt_reset(int unit);
extern int soc_robo2_ghtdt_set(int unit, int index,
                               ghtdt_t *entry, uint32 *status);
extern int soc_robo2_gspg2ig_disable(int unit);
extern int soc_robo2_gspg2ig_enable(int unit);
extern int soc_robo2_gspg2ig_get(int unit, int index, gspg2ig_t *entry);
extern int soc_robo2_gspg2ig_init(int unit, int start, int end,
                                  int inc, gspg2ig_t *entry);
extern int soc_robo2_gspg2ig_max_index(int unit);
extern int soc_robo2_gspg2ig_reset(int unit);
extern int soc_robo2_gspg2ig_set(int unit, int index,
                                 gspg2ig_t *entry, uint32 *status);
extern int soc_robo2_hdt_disable(int unit);
extern int soc_robo2_hdt_enable(int unit);
extern int soc_robo2_hdt_get(int unit, int index, hdt_t *entry);
extern int soc_robo2_hdt_init(int unit, int start, int end,
                              int inc, hdt_t *entry);
extern int soc_robo2_hdt_max_index(int unit);
extern int soc_robo2_hdt_reset(int unit);
extern int soc_robo2_hdt_set(int unit, int index,
                             hdt_t *entry, uint32 *status);
extern int soc_robo2_ikft_disable(int unit);
extern int soc_robo2_ikft_enable(int unit);
extern int soc_robo2_ikft_get(int unit, int index, ikft_t *entry);
extern int soc_robo2_ikft_init(int unit, int start, int end,
                               int inc, ikft_t *entry);
extern int soc_robo2_ikft_max_index(int unit);
extern int soc_robo2_ikft_reset(int unit);
extern int soc_robo2_ikft_set(int unit, int index,
                              ikft_t *entry, uint32 *status);
extern int soc_robo2_ipp_bucket_disable(int unit);
extern int soc_robo2_ipp_bucket_enable(int unit);
extern int soc_robo2_ipp_bucket_get(int unit, int index,
                                    ipp_bucket_t *entry);
extern int soc_robo2_ipp_bucket_init(int unit, int start, int end,
                                     int inc, ipp_bucket_t *entry);
extern int soc_robo2_ipp_bucket_max_index(int unit);
extern int soc_robo2_ipp_bucket_reset(int unit);
extern int soc_robo2_ipp_bucket_set(int unit, int index,
                                    ipp_bucket_t *entry, uint32 *status);
extern int soc_robo2_ipp_pmon_disable(int unit);
extern int soc_robo2_ipp_pmon_enable(int unit);
extern int soc_robo2_ipp_pmon_get(int unit, int index, ipp_pmon_t *entry);
extern int soc_robo2_ipp_pmon_init(int unit, int start, int end,
                                   int inc, ipp_pmon_t *entry);
extern int soc_robo2_ipp_pmon_max_index(int unit);
extern int soc_robo2_ipp_pmon_reset(int unit);
extern int soc_robo2_ipp_pmon_set(int unit, int index,
                                  ipp_pmon_t *entry, uint32 *status);
extern int soc_robo2_ipp_pp2lpg_disable(int unit);
extern int soc_robo2_ipp_pp2lpg_enable(int unit);
extern int soc_robo2_ipp_pp2lpg_get(int unit, int index,
                                    ipp_pp2lpg_t *entry);
extern int soc_robo2_ipp_pp2lpg_init(int unit, int start, int end,
                                     int inc, ipp_pp2lpg_t *entry);
extern int soc_robo2_ipp_pp2lpg_max_index(int unit);
extern int soc_robo2_ipp_pp2lpg_reset(int unit);
extern int soc_robo2_ipp_pp2lpg_set(int unit, int index,
                                    ipp_pp2lpg_t *entry, uint32 *status);
extern int soc_robo2_ipp_pptr_disable(int unit);
extern int soc_robo2_ipp_pptr_enable(int unit);
extern int soc_robo2_ipp_pptr_get(int unit, int index, ipp_pptr_t *entry);
extern int soc_robo2_ipp_pptr_init(int unit, int start, int end,
                                   int inc, ipp_pptr_t *entry);
extern int soc_robo2_ipp_pptr_max_index(int unit);
extern int soc_robo2_ipp_pptr_reset(int unit);
extern int soc_robo2_ipp_pptr_set(int unit, int index,
                                  ipp_pptr_t *entry, uint32 *status);
extern int soc_robo2_ipp_profile_disable(int unit);
extern int soc_robo2_ipp_profile_enable(int unit);
extern int soc_robo2_ipp_profile_get(int unit, int index,
                                     ipp_profile_t *entry);
extern int soc_robo2_ipp_profile_init(int unit, int start, int end,
                                      int inc, ipp_profile_t *entry);
extern int soc_robo2_ipp_profile_max_index(int unit);
extern int soc_robo2_ipp_profile_reset(int unit);
extern int soc_robo2_ipp_profile_set(int unit, int index,
                                     ipp_profile_t *entry, uint32 *status);
extern int soc_robo2_ipp_rscale_disable(int unit);
extern int soc_robo2_ipp_rscale_enable(int unit);
extern int soc_robo2_ipp_rscale_get(int unit, int index,
                                    ipp_rscale_t *entry);
extern int soc_robo2_ipp_rscale_init(int unit, int start, int end,
                                     int inc, ipp_rscale_t *entry);
extern int soc_robo2_ipp_rscale_max_index(int unit);
extern int soc_robo2_ipp_rscale_reset(int unit);
extern int soc_robo2_ipp_rscale_set(int unit, int index,
                                    ipp_rscale_t *entry, uint32 *status);
extern int soc_robo2_istget_disable(int unit);
extern int soc_robo2_istget_enable(int unit);
extern int soc_robo2_istget_get(int unit, int index, istget_t *entry);
extern int soc_robo2_istget_init(int unit, int start, int end,
                                 int inc, istget_t *entry);
extern int soc_robo2_istget_max_index(int unit);
extern int soc_robo2_istget_reset(int unit);
extern int soc_robo2_istget_set(int unit, int index,
                                istget_t *entry, uint32 *status);
extern int soc_robo2_kst_disable(int unit);
extern int soc_robo2_kst_enable(int unit);
extern int soc_robo2_kst_get(int unit, int index, kst_t *entry);
extern int soc_robo2_kst_init(int unit, int start, int end,
                              int inc, kst_t *entry);
extern int soc_robo2_kst_max_index(int unit);
extern int soc_robo2_kst_reset(int unit);
extern int soc_robo2_kst_set(int unit, int index,
                             kst_t *entry, uint32 *status);
extern int soc_robo2_lilt_disable(int unit);
extern int soc_robo2_lilt_enable(int unit);
extern int soc_robo2_lilt_get(int unit, int index, lilt_t *entry);
extern int soc_robo2_lilt_init(int unit, int start, int end,
                               int inc, lilt_t *entry);
extern int soc_robo2_lilt_max_index(int unit);
extern int soc_robo2_lilt_reset(int unit);
extern int soc_robo2_lilt_set(int unit, int index,
                              lilt_t *entry, uint32 *status);
extern int soc_robo2_lin2vsi_disable(int unit);
extern int soc_robo2_lin2vsi_enable(int unit);
extern int soc_robo2_lin2vsi_get(int unit, int index, lin2vsi_t *entry);
extern int soc_robo2_lin2vsi_init(int unit, int start, int end,
                                  int inc, lin2vsi_t *entry);
extern int soc_robo2_lin2vsi_max_index(int unit);
extern int soc_robo2_lin2vsi_reset(int unit);
extern int soc_robo2_lin2vsi_set(int unit, int index,
                                 lin2vsi_t *entry, uint32 *status);
extern int soc_robo2_litet_disable(int unit);
extern int soc_robo2_litet_enable(int unit);
extern int soc_robo2_litet_get(int unit, int index, litet_t *entry);
extern int soc_robo2_litet_init(int unit, int start, int end,
                                int inc, litet_t *entry);
extern int soc_robo2_litet_max_index(int unit);
extern int soc_robo2_litet_reset(int unit);
extern int soc_robo2_litet_set(int unit, int index,
                               litet_t *entry, uint32 *status);
extern int soc_robo2_lpg2ap_disable(int unit);
extern int soc_robo2_lpg2ap_enable(int unit);
extern int soc_robo2_lpg2ap_get(int unit, int index, lpg2ap_t *entry);
extern int soc_robo2_lpg2ap_init(int unit, int start, int end,
                                 int inc, lpg2ap_t *entry);
extern int soc_robo2_lpg2ap_max_index(int unit);
extern int soc_robo2_lpg2ap_reset(int unit);
extern int soc_robo2_lpg2ap_set(int unit, int index,
                                lpg2ap_t *entry, uint32 *status);
extern int soc_robo2_lpg2ig_disable(int unit);
extern int soc_robo2_lpg2ig_enable(int unit);
extern int soc_robo2_lpg2ig_get(int unit, int index, lpg2ig_t *entry);
extern int soc_robo2_lpg2ig_init(int unit, int start, int end,
                                 int inc, lpg2ig_t *entry);
extern int soc_robo2_lpg2ig_max_index(int unit);
extern int soc_robo2_lpg2ig_reset(int unit);
extern int soc_robo2_lpg2ig_set(int unit, int index,
                                lpg2ig_t *entry, uint32 *status);
extern int soc_robo2_lpg2pg_disable(int unit);
extern int soc_robo2_lpg2pg_enable(int unit);
extern int soc_robo2_lpg2pg_get(int unit, int index, lpg2pg_t *entry);
extern int soc_robo2_lpg2pg_init(int unit, int start, int end,
                                 int inc, lpg2pg_t *entry);
extern int soc_robo2_lpg2pg_max_index(int unit);
extern int soc_robo2_lpg2pg_reset(int unit);
extern int soc_robo2_lpg2pg_set(int unit, int index,
                                lpg2pg_t *entry, uint32 *status);
extern int soc_robo2_lpg2ppfov_disable(int unit);
extern int soc_robo2_lpg2ppfov_enable(int unit);
extern int soc_robo2_lpg2ppfov_get(int unit, int index, lpg2ppfov_t *entry);
extern int soc_robo2_lpg2ppfov_init(int unit, int start, int end,
                                    int inc, lpg2ppfov_t *entry);
extern int soc_robo2_lpg2ppfov_max_index(int unit);
extern int soc_robo2_lpg2ppfov_reset(int unit);
extern int soc_robo2_lpg2ppfov_set(int unit, int index,
                                   lpg2ppfov_t *entry, uint32 *status);
extern int soc_robo2_m2tk_disable(int unit);
extern int soc_robo2_m2tk_enable(int unit);
extern int soc_robo2_m2tk_get(int unit, int index, m2tk_t *entry);
extern int soc_robo2_m2tk_init(int unit, int start, int end,
                               int inc, m2tk_t *entry);
extern int soc_robo2_m2tk_max_index(int unit);
extern int soc_robo2_m2tk_reset(int unit);
extern int soc_robo2_m2tk_set(int unit, int index,
                              m2tk_t *entry, uint32 *status);
extern int soc_robo2_max_config_disable(int unit);
extern int soc_robo2_max_config_enable(int unit);
extern int soc_robo2_max_config_get(int unit, int index,
                                    max_config_t *entry);
extern int soc_robo2_max_config_init(int unit, int start, int end,
                                     int inc, max_config_t *entry);
extern int soc_robo2_max_config_max_index(int unit);
extern int soc_robo2_max_config_reset(int unit);
extern int soc_robo2_max_config_set(int unit, int index,
                                    max_config_t *entry, uint32 *status);
extern int soc_robo2_mtgt_disable(int unit);
extern int soc_robo2_mtgt_enable(int unit);
extern int soc_robo2_mtgt_get(int unit, int index, mtgt_t *entry);
extern int soc_robo2_mtgt_init(int unit, int start, int end,
                               int inc, mtgt_t *entry);
extern int soc_robo2_mtgt_max_index(int unit);
extern int soc_robo2_mtgt_reset(int unit);
extern int soc_robo2_mtgt_set(int unit, int index,
                              mtgt_t *entry, uint32 *status);
extern int soc_robo2_mtr2tcb_disable(int unit);
extern int soc_robo2_mtr2tcb_enable(int unit);
extern int soc_robo2_mtr2tcb_get(int unit, int index, mtr2tcb_t *entry);
extern int soc_robo2_mtr2tcb_init(int unit, int start, int end,
                                  int inc, mtr2tcb_t *entry);
extern int soc_robo2_mtr2tcb_max_index(int unit);
extern int soc_robo2_mtr2tcb_reset(int unit);
extern int soc_robo2_mtr2tcb_set(int unit, int index,
                                 mtr2tcb_t *entry, uint32 *status);
extern int soc_robo2_ofarlfm_disable(int unit);
extern int soc_robo2_ofarlfm_enable(int unit);
extern int soc_robo2_ofarlfm_get(int unit, int index, ofarlfm_t *entry);
extern int soc_robo2_ofarlfm_init(int unit, int start, int end,
                                  int inc, ofarlfm_t *entry);
extern int soc_robo2_ofarlfm_max_index(int unit);
extern int soc_robo2_ofarlfm_reset(int unit);
extern int soc_robo2_ofarlfm_set(int unit, int index,
                                 ofarlfm_t *entry, uint32 *status);
extern int soc_robo2_pet_disable(int unit);
extern int soc_robo2_pet_enable(int unit);
extern int soc_robo2_pet_get(int unit, int index, pet_t *entry);
extern int soc_robo2_pet_init(int unit, int start, int end,
                              int inc, pet_t *entry);
extern int soc_robo2_pet_max_index(int unit);
extern int soc_robo2_pet_reset(int unit);
extern int soc_robo2_pet_set(int unit, int index,
                             pet_t *entry, uint32 *status);
extern int soc_robo2_pg2lpg_disable(int unit);
extern int soc_robo2_pg2lpg_enable(int unit);
extern int soc_robo2_pg2lpg_get(int unit, int index, pg2lpg_t *entry);
extern int soc_robo2_pg2lpg_init(int unit, int start, int end,
                                 int inc, pg2lpg_t *entry);
extern int soc_robo2_pg2lpg_max_index(int unit);
extern int soc_robo2_pg2lpg_reset(int unit);
extern int soc_robo2_pg2lpg_set(int unit, int index,
                                pg2lpg_t *entry, uint32 *status);
extern int soc_robo2_pglct_disable(int unit);
extern int soc_robo2_pglct_enable(int unit);
extern int soc_robo2_pglct_get(int unit, int index, pglct_t *entry);
extern int soc_robo2_pglct_init(int unit, int start, int end,
                                int inc, pglct_t *entry);
extern int soc_robo2_pglct_max_index(int unit);
extern int soc_robo2_pglct_reset(int unit);
extern int soc_robo2_pglct_set(int unit, int index,
                               pglct_t *entry, uint32 *status);
extern int soc_robo2_pgt_disable(int unit);
extern int soc_robo2_pgt_enable(int unit);
extern int soc_robo2_pgt_get(int unit, int index, pgt_t *entry);
extern int soc_robo2_pgt_init(int unit, int start, int end,
                              int inc, pgt_t *entry);
extern int soc_robo2_pgt_max_index(int unit);
extern int soc_robo2_pgt_reset(int unit);
extern int soc_robo2_pgt_set(int unit, int index,
                             pgt_t *entry, uint32 *status);
extern int soc_robo2_pmipage_disable(int unit);
extern int soc_robo2_pmipage_enable(int unit);
extern int soc_robo2_pmipage_get(int unit, int index, pmipage_t *entry);
extern int soc_robo2_pmipage_init(int unit, int start, int end,
                                  int inc, pmipage_t *entry);
extern int soc_robo2_pmipage_max_index(int unit);
extern int soc_robo2_pmipage_reset(int unit);
extern int soc_robo2_pmipage_set(int unit, int index,
                                 pmipage_t *entry, uint32 *status);
extern int soc_robo2_pqm_bucket_disable(int unit);
extern int soc_robo2_pqm_bucket_enable(int unit);
extern int soc_robo2_pqm_bucket_get(int unit, int index,
                                    pqm_bucket_t *entry);
extern int soc_robo2_pqm_bucket_init(int unit, int start, int end,
                                     int inc, pqm_bucket_t *entry);
extern int soc_robo2_pqm_bucket_max_index(int unit);
extern int soc_robo2_pqm_bucket_reset(int unit);
extern int soc_robo2_pqm_bucket_set(int unit, int index,
                                    pqm_bucket_t *entry, uint32 *status);
extern int soc_robo2_pqm_pmon_disable(int unit);
extern int soc_robo2_pqm_pmon_enable(int unit);
extern int soc_robo2_pqm_pmon_get(int unit, int index, pqm_pmon_t *entry);
extern int soc_robo2_pqm_pmon_init(int unit, int start, int end,
                                   int inc, pqm_pmon_t *entry);
extern int soc_robo2_pqm_pmon_max_index(int unit);
extern int soc_robo2_pqm_pmon_reset(int unit);
extern int soc_robo2_pqm_pmon_set(int unit, int index,
                                  pqm_pmon_t *entry, uint32 *status);
extern int soc_robo2_pqm_pp2lpg_disable(int unit);
extern int soc_robo2_pqm_pp2lpg_enable(int unit);
extern int soc_robo2_pqm_pp2lpg_get(int unit, int index,
                                    pqm_pp2lpg_t *entry);
extern int soc_robo2_pqm_pp2lpg_init(int unit, int start, int end,
                                     int inc, pqm_pp2lpg_t *entry);
extern int soc_robo2_pqm_pp2lpg_max_index(int unit);
extern int soc_robo2_pqm_pp2lpg_reset(int unit);
extern int soc_robo2_pqm_pp2lpg_set(int unit, int index,
                                    pqm_pp2lpg_t *entry, uint32 *status);
extern int soc_robo2_pqm_pptr_disable(int unit);
extern int soc_robo2_pqm_pptr_enable(int unit);
extern int soc_robo2_pqm_pptr_get(int unit, int index, pqm_pptr_t *entry);
extern int soc_robo2_pqm_pptr_init(int unit, int start, int end,
                                   int inc, pqm_pptr_t *entry);
extern int soc_robo2_pqm_pptr_max_index(int unit);
extern int soc_robo2_pqm_pptr_reset(int unit);
extern int soc_robo2_pqm_pptr_set(int unit, int index,
                                  pqm_pptr_t *entry, uint32 *status);
extern int soc_robo2_pqm_profile_disable(int unit);
extern int soc_robo2_pqm_profile_enable(int unit);
extern int soc_robo2_pqm_profile_get(int unit, int index,
                                     pqm_profile_t *entry);
extern int soc_robo2_pqm_profile_init(int unit, int start, int end,
                                      int inc, pqm_profile_t *entry);
extern int soc_robo2_pqm_profile_max_index(int unit);
extern int soc_robo2_pqm_profile_reset(int unit);
extern int soc_robo2_pqm_profile_set(int unit, int index,
                                     pqm_profile_t *entry, uint32 *status);
extern int soc_robo2_pqm_rscale_disable(int unit);
extern int soc_robo2_pqm_rscale_enable(int unit);
extern int soc_robo2_pqm_rscale_get(int unit, int index,
                                    pqm_rscale_t *entry);
extern int soc_robo2_pqm_rscale_init(int unit, int start, int end,
                                     int inc, pqm_rscale_t *entry);
extern int soc_robo2_pqm_rscale_max_index(int unit);
extern int soc_robo2_pqm_rscale_reset(int unit);
extern int soc_robo2_pqm_rscale_set(int unit, int index,
                                    pqm_rscale_t *entry, uint32 *status);
extern int soc_robo2_pv2li_disable(int unit);
extern int soc_robo2_pv2li_enable(int unit);
extern int soc_robo2_pv2li_get(int unit, int index, pv2li_t *entry);
extern int soc_robo2_pv2li_init(int unit, int start, int end,
                                int inc, pv2li_t *entry);
extern int soc_robo2_pv2li_max_index(int unit);
extern int soc_robo2_pv2li_reset(int unit);
extern int soc_robo2_pv2li_set(int unit, int index,
                               pv2li_t *entry, uint32 *status);
extern int soc_robo2_qdschcfg_disable(int unit);
extern int soc_robo2_qdschcfg_enable(int unit);
extern int soc_robo2_qdschcfg_get(int unit, int index, qdschcfg_t *entry);
extern int soc_robo2_qdschcfg_init(int unit, int start, int end,
                                   int inc, qdschcfg_t *entry);
extern int soc_robo2_qdschcfg_max_index(int unit);
extern int soc_robo2_qdschcfg_reset(int unit);
extern int soc_robo2_qdschcfg_set(int unit, int index,
                                  qdschcfg_t *entry, uint32 *status);
extern int soc_robo2_qfccredit_disable(int unit);
extern int soc_robo2_qfccredit_enable(int unit);
extern int soc_robo2_qfccredit_get(int unit, int index, qfccredit_t *entry);
extern int soc_robo2_qfccredit_init(int unit, int start, int end,
                                    int inc, qfccredit_t *entry);
extern int soc_robo2_qfccredit_max_index(int unit);
extern int soc_robo2_qfccredit_reset(int unit);
extern int soc_robo2_qfccredit_set(int unit, int index,
                                   qfccredit_t *entry, uint32 *status);
extern int soc_robo2_qfcqdaddr_disable(int unit);
extern int soc_robo2_qfcqdaddr_enable(int unit);
extern int soc_robo2_qfcqdaddr_get(int unit, int index, qfcqdaddr_t *entry);
extern int soc_robo2_qfcqdaddr_init(int unit, int start, int end,
                                    int inc, qfcqdaddr_t *entry);
extern int soc_robo2_qfcqdaddr_max_index(int unit);
extern int soc_robo2_qfcqdaddr_reset(int unit);
extern int soc_robo2_qfcqdaddr_set(int unit, int index,
                                   qfcqdaddr_t *entry, uint32 *status);
extern int soc_robo2_rpslict_disable(int unit);
extern int soc_robo2_rpslict_enable(int unit);
extern int soc_robo2_rpslict_get(int unit, int index, rpslict_t *entry);
extern int soc_robo2_rpslict_init(int unit, int start, int end,
                                  int inc, rpslict_t *entry);
extern int soc_robo2_rpslict_max_index(int unit);
extern int soc_robo2_rpslict_reset(int unit);
extern int soc_robo2_rpslict_set(int unit, int index,
                                 rpslict_t *entry, uint32 *status);
extern int soc_robo2_rpt_disable(int unit);
extern int soc_robo2_rpt_enable(int unit);
extern int soc_robo2_rpt_get(int unit, int index, rpt_t *entry);
extern int soc_robo2_rpt_init(int unit, int start, int end,
                              int inc, rpt_t *entry);
extern int soc_robo2_rpt_max_index(int unit);
extern int soc_robo2_rpt_reset(int unit);
extern int soc_robo2_rpt_set(int unit, int index,
                             rpt_t *entry, uint32 *status);
extern int soc_robo2_set_disable(int unit);
extern int soc_robo2_set_enable(int unit);
extern int soc_robo2_set_get(int unit, int index, set_t *entry);
extern int soc_robo2_set_init(int unit, int start, int end,
                              int inc, set_t *entry);
extern int soc_robo2_set_max_index(int unit);
extern int soc_robo2_set_reset(int unit);
extern int soc_robo2_set_set(int unit, int index,
                             set_t *entry, uint32 *status);
extern int soc_robo2_slicmap_disable(int unit);
extern int soc_robo2_slicmap_enable(int unit);
extern int soc_robo2_slicmap_get(int unit, int index, slicmap_t *entry);
extern int soc_robo2_slicmap_init(int unit, int start, int end,
                                  int inc, slicmap_t *entry);
extern int soc_robo2_slicmap_max_index(int unit);
extern int soc_robo2_slicmap_reset(int unit);
extern int soc_robo2_slicmap_set(int unit, int index,
                                 slicmap_t *entry, uint32 *status);
extern int soc_robo2_slictecc_disable(int unit);
extern int soc_robo2_slictecc_enable(int unit);
extern int soc_robo2_slictecc_get(int unit, int index, slictecc_t *entry);
extern int soc_robo2_slictecc_init(int unit, int start, int end,
                                   int inc, slictecc_t *entry);
extern int soc_robo2_slictecc_max_index(int unit);
extern int soc_robo2_slictecc_reset(int unit);
extern int soc_robo2_slictecc_set(int unit, int index,
                                  slictecc_t *entry, uint32 *status);
extern int soc_robo2_spg_pp_bmp_config_disable(int unit);
extern int soc_robo2_spg_pp_bmp_config_enable(int unit);
extern int soc_robo2_spg_pp_bmp_config_get(int unit, int index,
                                           spg_pp_bmp_config_t *entry);
extern int soc_robo2_spg_pp_bmp_config_init(int unit, int start, int end,
                                            int inc, spg_pp_bmp_config_t *entry);
extern int soc_robo2_spg_pp_bmp_config_max_index(int unit);
extern int soc_robo2_spg_pp_bmp_config_reset(int unit);
extern int soc_robo2_spg_pp_bmp_config_set(int unit, int index,
                                           spg_pp_bmp_config_t *entry, uint32 *status);
extern int soc_robo2_spldt_disable(int unit);
extern int soc_robo2_spldt_enable(int unit);
extern int soc_robo2_spldt_get(int unit, int index, spldt_t *entry);
extern int soc_robo2_spldt_init(int unit, int start, int end,
                                int inc, spldt_t *entry);
extern int soc_robo2_spldt_max_index(int unit);
extern int soc_robo2_spldt_reset(int unit);
extern int soc_robo2_spldt_set(int unit, int index,
                               spldt_t *entry, uint32 *status);
extern int soc_robo2_srt_disable(int unit);
extern int soc_robo2_srt_enable(int unit);
extern int soc_robo2_srt_get(int unit, int index, srt_t *entry);
extern int soc_robo2_srt_init(int unit, int start, int end,
                              int inc, srt_t *entry);
extern int soc_robo2_srt_max_index(int unit);
extern int soc_robo2_srt_reset(int unit);
extern int soc_robo2_srt_set(int unit, int index,
                             srt_t *entry, uint32 *status);
extern int soc_robo2_stat_disable(int unit);
extern int soc_robo2_stat_enable(int unit);
extern int soc_robo2_stat_get(int unit, int index, stat_t *entry);
extern int soc_robo2_stat_init(int unit, int start, int end,
                               int inc, stat_t *entry);
extern int soc_robo2_stat_max_index(int unit);
extern int soc_robo2_stat_reset(int unit);
extern int soc_robo2_stat_set(int unit, int index,
                              stat_t *entry, uint32 *status);
extern int soc_robo2_stt_disable(int unit);
extern int soc_robo2_stt_enable(int unit);
extern int soc_robo2_stt_get(int unit, int index, stt_t *entry);
extern int soc_robo2_stt_init(int unit, int start, int end,
                              int inc, stt_t *entry);
extern int soc_robo2_stt_max_index(int unit);
extern int soc_robo2_stt_reset(int unit);
extern int soc_robo2_stt_set(int unit, int index,
                             stt_t *entry, uint32 *status);
extern int soc_robo2_svt_disable(int unit);
extern int soc_robo2_svt_enable(int unit);
extern int soc_robo2_svt_get(int unit, int index, svt_t *entry);
extern int soc_robo2_svt_init(int unit, int start, int end,
                              int inc, svt_t *entry);
extern int soc_robo2_svt_max_index(int unit);
extern int soc_robo2_svt_reset(int unit);
extern int soc_robo2_svt_set(int unit, int index,
                             svt_t *entry, uint32 *status);
extern int soc_robo2_table_dump(int unit, soc_robo2_table_id_t tid,
                                int index);
extern int soc_robo2_tc2qd_disable(int unit);
extern int soc_robo2_tc2qd_enable(int unit);
extern int soc_robo2_tc2qd_get(int unit, int index, tc2qd_t *entry);
extern int soc_robo2_tc2qd_init(int unit, int start, int end,
                                int inc, tc2qd_t *entry);
extern int soc_robo2_tc2qd_max_index(int unit);
extern int soc_robo2_tc2qd_reset(int unit);
extern int soc_robo2_tc2qd_set(int unit, int index,
                               tc2qd_t *entry, uint32 *status);
extern int soc_robo2_tct_disable(int unit);
extern int soc_robo2_tct_enable(int unit);
extern int soc_robo2_tct_get(int unit, int index, tct_t *entry);
extern int soc_robo2_tct_init(int unit, int start, int end,
                              int inc, tct_t *entry);
extern int soc_robo2_tct_max_index(int unit);
extern int soc_robo2_tct_reset(int unit);
extern int soc_robo2_tct_set(int unit, int index,
                             tct_t *entry, uint32 *status);
extern int soc_robo2_tecc_disable(int unit);
extern int soc_robo2_tecc_enable(int unit);
extern int soc_robo2_tecc_get(int unit, int index, tecc_t *entry);
extern int soc_robo2_tecc_init(int unit, int start, int end,
                               int inc, tecc_t *entry);
extern int soc_robo2_tecc_max_index(int unit);
extern int soc_robo2_tecc_reset(int unit);
extern int soc_robo2_tecc_set(int unit, int index,
                              tecc_t *entry, uint32 *status);
extern int soc_robo2_tet_disable(int unit);
extern int soc_robo2_tet_enable(int unit);
extern int soc_robo2_tet_get(int unit, int index, tet_t *entry);
extern int soc_robo2_tet_init(int unit, int start, int end,
                              int inc, tet_t *entry);
extern int soc_robo2_tet_max_index(int unit);
extern int soc_robo2_tet_reset(int unit);
extern int soc_robo2_tet_set(int unit, int index,
                             tet_t *entry, uint32 *status);
extern int soc_robo2_vsit_disable(int unit);
extern int soc_robo2_vsit_enable(int unit);
extern int soc_robo2_vsit_get(int unit, int index, vsit_t *entry);
extern int soc_robo2_vsit_init(int unit, int start, int end,
                               int inc, vsit_t *entry);
extern int soc_robo2_vsit_max_index(int unit);
extern int soc_robo2_vsit_reset(int unit);
extern int soc_robo2_vsit_set(int unit, int index,
                              vsit_t *entry, uint32 *status);
extern int soc_robo2_vtct_disable(int unit);
extern int soc_robo2_vtct_enable(int unit);
extern int soc_robo2_vtct_get(int unit, int index, vtct_t *entry);
extern int soc_robo2_vtct_init(int unit, int start, int end,
                               int inc, vtct_t *entry);
extern int soc_robo2_vtct_max_index(int unit);
extern int soc_robo2_vtct_reset(int unit);
extern int soc_robo2_vtct_set(int unit, int index,
                              vtct_t *entry, uint32 *status);
extern int soc_robo2_wpt_disable(int unit);
extern int soc_robo2_wpt_enable(int unit);
extern int soc_robo2_wpt_get(int unit, int index, wpt_t *entry);
extern int soc_robo2_wpt_init(int unit, int start, int end,
                              int inc, wpt_t *entry);
extern int soc_robo2_wpt_max_index(int unit);
extern int soc_robo2_wpt_reset(int unit);
extern int soc_robo2_wpt_set(int unit, int index,
                             wpt_t *entry, uint32 *status);
extern int soc_robo2_wrt_disable(int unit);
extern int soc_robo2_wrt_enable(int unit);
extern int soc_robo2_wrt_get(int unit, int index, wrt_t *entry);
extern int soc_robo2_wrt_init(int unit, int start, int end,
                              int inc, wrt_t *entry);
extern int soc_robo2_wrt_max_index(int unit);
extern int soc_robo2_wrt_reset(int unit);
extern int soc_robo2_wrt_set(int unit, int index,
                             wrt_t *entry, uint32 *status);


#endif /* SOC_ROBO2_TABLES_H */
