/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Id: $
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom/Broadcom-Compute-Connectivity-Software-robo2-rsdk/master/Legal/LICENSE file.
 *
 * $Copyright: (c) 2020 Broadcom Inc.
 * All Rights Reserved.$
 *
 * File:	tables.c
 * Purpose:	Robo2 Table Access Routines
 */



#include <soc/robo2/common/tables.h>

int table_dump_tid = -1;


/**
 * Each table has a mutex for exclusion
 */
/* Mutex for tct */
sal_mutex_t  tct_mutex;

/* Mutex for rpt */
sal_mutex_t  rpt_mutex;

/* Mutex for pgt */
sal_mutex_t  pgt_mutex;

/* Mutex for pmipage */
sal_mutex_t  pmipage_mutex;

/* Mutex for gfcd_config */
sal_mutex_t  gfcd_config_mutex;

/* Mutex for apt */
sal_mutex_t  apt_mutex;

/* Mutex for gfcd_cntr */
sal_mutex_t  gfcd_cntr_mutex;

/* Mutex for spg_pp_bmp_config */
sal_mutex_t  spg_pp_bmp_config_mutex;

/* Mutex for dgt */
sal_mutex_t  dgt_mutex;

/* Mutex for gspg2ig */
sal_mutex_t  gspg2ig_mutex;

/* Mutex for epp_calendar */
sal_mutex_t  epp_calendar_mutex;

/* Mutex for ght */
sal_mutex_t  ght_mutex;

/* Mutex for lin2vsi */
sal_mutex_t  lin2vsi_mutex;

/* Mutex for cfp_profile */
sal_mutex_t  cfp_profile_mutex;

/* Mutex for cfp_bucket */
sal_mutex_t  cfp_bucket_mutex;

/* Mutex for calendar */
sal_mutex_t  calendar_mutex;

/* Mutex for pg2lpg */
sal_mutex_t  pg2lpg_mutex;

/* Mutex for arlfm */
sal_mutex_t  arlfm_mutex;

/* Mutex for arlfm0 */
sal_mutex_t  arlfm0_mutex;

/* Mutex for ipp_bucket */
sal_mutex_t  ipp_bucket_mutex;

/* Mutex for fcd_config */
sal_mutex_t  fcd_config_mutex;

/* Mutex for stat */
sal_mutex_t  stat_mutex;

/* Mutex for eeecfg */
sal_mutex_t  eeecfg_mutex;

/* Mutex for hdt */
sal_mutex_t  hdt_mutex;

/* Mutex for estget */
sal_mutex_t  estget_mutex;

/* Mutex for stt */
sal_mutex_t  stt_mutex;

/* Mutex for pet */
sal_mutex_t  pet_mutex;

/* Mutex for istget */
sal_mutex_t  istget_mutex;

/* Mutex for qdschcfg */
sal_mutex_t  qdschcfg_mutex;

/* Mutex for pqm_rscale */
sal_mutex_t  pqm_rscale_mutex;

/* Mutex for mtr2tcb */
sal_mutex_t  mtr2tcb_mutex;

/* Mutex for dli2ldpg */
sal_mutex_t  dli2ldpg_mutex;

/* Mutex for tc2qd */
sal_mutex_t  tc2qd_mutex;

/* Mutex for spldt */
sal_mutex_t  spldt_mutex;

/* Mutex for cfp_rscale */
sal_mutex_t  cfp_rscale_mutex;

/* Mutex for ghtdt */
sal_mutex_t  ghtdt_mutex;

/* Mutex for bmu_bucket */
sal_mutex_t  bmu_bucket_mutex;

/* Mutex for lilt */
sal_mutex_t  lilt_mutex;

/* Mutex for svt */
sal_mutex_t  svt_mutex;

/* Mutex for slicmap */
sal_mutex_t  slicmap_mutex;

/* Mutex for m2tk */
sal_mutex_t  m2tk_mutex;

/* Mutex for art */
sal_mutex_t  art_mutex;

/* Mutex for lpg2ig */
sal_mutex_t  lpg2ig_mutex;

/* Mutex for ipp_profile */
sal_mutex_t  ipp_profile_mutex;

/* Mutex for qfcqdaddr */
sal_mutex_t  qfcqdaddr_mutex;

/* Mutex for mtgt */
sal_mutex_t  mtgt_mutex;

/* Mutex for ipp_pptr */
sal_mutex_t  ipp_pptr_mutex;

/* Mutex for set */
sal_mutex_t  set_mutex;

/* Mutex for srt */
sal_mutex_t  srt_mutex;

/* Mutex for ipp_pmon */
sal_mutex_t  ipp_pmon_mutex;

/* Mutex for vtct */
sal_mutex_t  vtct_mutex;

/* Mutex for cfpcam */
sal_mutex_t  cfpcam_mutex;

/* Mutex for fcd_cntr */
sal_mutex_t  fcd_cntr_mutex;

/* Mutex for fpslict */
sal_mutex_t  fpslict_mutex;

/* Mutex for kst */
sal_mutex_t  kst_mutex;

/* Mutex for pqm_bucket */
sal_mutex_t  pqm_bucket_mutex;

/* Mutex for ghst */
sal_mutex_t  ghst_mutex;

/* Mutex for lpg2pg */
sal_mutex_t  lpg2pg_mutex;

/* Mutex for epgt */
sal_mutex_t  epgt_mutex;

/* Mutex for bmu_rscale */
sal_mutex_t  bmu_rscale_mutex;

/* Mutex for lpg2ppfov */
sal_mutex_t  lpg2ppfov_mutex;

/* Mutex for vsit */
sal_mutex_t  vsit_mutex;

/* Mutex for qfccredit */
sal_mutex_t  qfccredit_mutex;

/* Mutex for tet */
sal_mutex_t  tet_mutex;

/* Mutex for ipp_pp2lpg */
sal_mutex_t  ipp_pp2lpg_mutex;

/* Mutex for pqm_pptr */
sal_mutex_t  pqm_pptr_mutex;

/* Mutex for bmu_pmon */
sal_mutex_t  bmu_pmon_mutex;

/* Mutex for etct */
sal_mutex_t  etct_mutex;

/* Mutex for arlfm1_ght_h0 */
sal_mutex_t  arlfm1_ght_h0_mutex;

/* Mutex for cfp_pmon */
sal_mutex_t  cfp_pmon_mutex;

/* Mutex for max_config */
sal_mutex_t  max_config_mutex;

/* Mutex for bmu_profile */
sal_mutex_t  bmu_profile_mutex;

/* Mutex for pv2li */
sal_mutex_t  pv2li_mutex;

/* Mutex for ipp_rscale */
sal_mutex_t  ipp_rscale_mutex;

/* Mutex for pqm_pmon */
sal_mutex_t  pqm_pmon_mutex;

/* Mutex for ikft */
sal_mutex_t  ikft_mutex;

/* Mutex for arlfm1_ght_h1 */
sal_mutex_t  arlfm1_ght_h1_mutex;

/* Mutex for epmt */
sal_mutex_t  epmt_mutex;

/* Mutex for epp_bmu_tx_reorder_req_lmt */
sal_mutex_t  epp_bmu_tx_reorder_req_lmt_mutex;

/* Mutex for bmu_pptr */
sal_mutex_t  bmu_pptr_mutex;

/* Mutex for ert */
sal_mutex_t  ert_mutex;

/* Mutex for action */
sal_mutex_t  action_mutex;

/* Mutex for rpslict */
sal_mutex_t  rpslict_mutex;

/* Mutex for slictecc */
sal_mutex_t  slictecc_mutex;

/* Mutex for litet */
sal_mutex_t  litet_mutex;

/* Mutex for tecc */
sal_mutex_t  tecc_mutex;

/* Mutex for cfp_pptr */
sal_mutex_t  cfp_pptr_mutex;

/* Mutex for wrt */
sal_mutex_t  wrt_mutex;

/* Mutex for wpt */
sal_mutex_t  wpt_mutex;

/* Mutex for dliet */
sal_mutex_t  dliet_mutex;

/* Mutex for pglct */
sal_mutex_t  pglct_mutex;

/* Mutex for lpg2ap */
sal_mutex_t  lpg2ap_mutex;

/* Mutex for pqm_profile */
sal_mutex_t  pqm_profile_mutex;

/* Mutex for cpmt */
sal_mutex_t  cpmt_mutex;

/* Mutex for pqm_pp2lpg */
sal_mutex_t  pqm_pp2lpg_mutex;

/* Mutex for ofarlfm */
sal_mutex_t  ofarlfm_mutex;


/**
 * Table id to Names mapping
 */
char *robo2_table_names[] = {
    "tct",
    "rpt",
    "pgt",
    "pmipage",
    "gfcd_config",
    "apt",
    "gfcd_cntr",
    "spg_pp_bmp_config",
    "dgt",
    "gspg2ig",
    "epp_calendar",
    "ght",
    "lin2vsi",
    "cfp_profile",
    "cfp_bucket",
    "calendar",
    "pg2lpg",
    "arlfm",
    "arlfm0",
    "ipp_bucket",
    "fcd_config",
    "stat",
    "eeecfg",
    "hdt",
    "estget",
    "stt",
    "pet",
    "istget",
    "qdschcfg",
    "pqm_rscale",
    "mtr2tcb",
    "dli2ldpg",
    "tc2qd",
    "spldt",
    "cfp_rscale",
    "ghtdt",
    "bmu_bucket",
    "lilt",
    "svt",
    "slicmap",
    "m2tk",
    "art",
    "lpg2ig",
    "ipp_profile",
    "qfcqdaddr",
    "mtgt",
    "ipp_pptr",
    "set",
    "srt",
    "ipp_pmon",
    "vtct",
    "cfpcam",
    "fcd_cntr",
    "fpslict",
    "kst",
    "pqm_bucket",
    "ghst",
    "lpg2pg",
    "epgt",
    "bmu_rscale",
    "lpg2ppfov",
    "vsit",
    "qfccredit",
    "tet",
    "ipp_pp2lpg",
    "pqm_pptr",
    "bmu_pmon",
    "etct",
    "arlfm1_ght_h0",
    "cfp_pmon",
    "max_config",
    "bmu_profile",
    "pv2li",
    "ipp_rscale",
    "pqm_pmon",
    "ikft",
    "arlfm1_ght_h1",
    "epmt",
    "epp_bmu_tx_reorder_req_lmt",
    "bmu_pptr",
    "ert",
    "action",
    "rpslict",
    "slictecc",
    "litet",
    "tecc",
    "cfp_pptr",
    "wrt",
    "wpt",
    "dliet",
    "pglct",
    "lpg2ap",
    "pqm_profile",
    "cpmt",
    "pqm_pp2lpg",
    "ofarlfm",
};

/**
 * @par Function: 
 *      soc_robo2_table_operation
 * @par Description:
 *      This is a helper routine to complete a indirect table access operation
 * 
 *    @param [in]  unit      :  Identifies the chip
 *    @param [in]  tid       :  Table info
 *    @param [in]  operation :  Table operation to be performed
 *    @param [in]  index     :  Index to be used
 *    @param [out] status    :  Hw status after operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_table_operation(int unit, soc_robo2_table_id_t tid, soc_robo2_ia_operation_t operation, int index, uint32 *status)
{
    
    uint32 config = 0;
    int rc = 0;
    uint32 sts = 0;
    uint32 status_reg = 0;
    uint32 config_reg = 0;
    char *table_name = NULL;
    int maxtimeout = 100; /* 100 * 100usec */
    int timeout = maxtimeout;
    uint32 clear = ROBO2_IA_OP_ACK_ERROR;

    switch (tid) {
    case ROBO2_TABLE_TCT_ID:
        status_reg = CB_IPP_TCT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_TCT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_RPT_ID:
        status_reg = CB_IPP_RPT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_RPT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PGT_ID:
        status_reg = CB_IPP_PGT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_PGT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PMIPAGE_ID:
        status_reg = CB_PMI_PMIPAGE_IA_STATUSr_ROBO2;
        config_reg = CB_PMI_PMIPAGE_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_GFCD_CONFIG_ID:
        status_reg = CB_BMU_GFCD_CONFIG_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_GFCD_CONFIG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_APT_ID:
        status_reg = CB_PQM_APT_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_APT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_GFCD_CNTR_ID:
        status_reg = CB_BMU_GFCD_CNTR_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_GFCD_CNTR_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID:
        status_reg = CB_BMU_SPG_PP_BMP_CONFIG_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_SPG_PP_BMP_CONFIG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_DGT_ID:
        status_reg = CB_PQM_DGT_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_DGT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_GSPG2IG_ID:
        status_reg = CB_IPP_GSPG2IG_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_GSPG2IG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_EPP_CALENDAR_ID:
        status_reg = CB_EPP_EPP_CALENDAR_IA_STATUSr_ROBO2;
        config_reg = CB_EPP_EPP_CALENDAR_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_GHT_ID:
        status_reg = CB_ITM_GHT_IA_STATUSr_ROBO2;
        config_reg = CB_ITM_GHT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_LIN2VSI_ID:
        status_reg = CB_IPP_LIN2VSI_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_LIN2VSI_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_CFP_PROFILE_ID:
        status_reg = CB_CFP_PROFILE_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_PROFILE_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_CFP_BUCKET_ID:
        status_reg = CB_CFP_BUCKET_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_BUCKET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_CALENDAR_ID:
        status_reg = CB_PQS_CALENDAR_IA_STATUSr_ROBO2;
        config_reg = CB_PQS_CALENDAR_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PG2LPG_ID:
        status_reg = CB_PQM_PG2LPG_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_PG2LPG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ARLFM_ID:
        status_reg = CB_ITM_ARLFM_IA_STATUSr_ROBO2;
        config_reg = CB_ITM_ARLFM_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ARLFM0_ID:
        status_reg = CB_ITM_ARLFM0_IA_STATUSr_ROBO2;
        config_reg = CB_ITM_ARLFM0_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_IPP_BUCKET_ID:
        status_reg = CB_IPP_BUCKET_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_BUCKET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_FCD_CONFIG_ID:
        status_reg = CB_BMU_FCD_CONFIG_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_FCD_CONFIG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_STAT_ID:
        status_reg = CB_CFP_STAT_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_STAT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_EEECFG_ID:
        status_reg = CB_PQM_EEECFG_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_EEECFG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_HDT_ID:
        status_reg = CB_IPP_HDT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_HDT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ESTGET_ID:
        status_reg = CB_PQM_ESTGET_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_ESTGET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_STT_ID:
        status_reg = CB_IPP_STT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_STT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PET_ID:
        status_reg = CB_ETM_PET_IA_STATUSr_ROBO2;
        config_reg = CB_ETM_PET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ISTGET_ID:
        status_reg = CB_IPP_ISTGET_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_ISTGET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_QDSCHCFG_ID:
        status_reg = CB_PQM_QDSCHCFG_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_QDSCHCFG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PQM_RSCALE_ID:
        status_reg = CB_PQM_RSCALE_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_RSCALE_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_MTR2TCB_ID:
        status_reg = CB_BMU_MTR2TCB_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_MTR2TCB_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_DLI2LDPG_ID:
        status_reg = CB_PQM_DLI2LDPG_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_DLI2LDPG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_TC2QD_ID:
        status_reg = CB_PQM_TC2QD_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_TC2QD_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_SPLDT_ID:
        status_reg = CB_EPP_SPLDT_IA_STATUSr_ROBO2;
        config_reg = CB_EPP_SPLDT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_CFP_RSCALE_ID:
        status_reg = CB_CFP_RSCALE_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_RSCALE_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_GHTDT_ID:
        status_reg = CB_ITM_GHTDT_IA_STATUSr_ROBO2;
        config_reg = CB_ITM_GHTDT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_BMU_BUCKET_ID:
        status_reg = CB_BMU_BUCKET_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_BUCKET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_LILT_ID:
        status_reg = CB_PQM_LILT_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_LILT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_SVT_ID:
        status_reg = CB_PQM_SVT_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_SVT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_SLICMAP_ID:
        status_reg = CB_IPP_SLICMAP_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_SLICMAP_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_M2TK_ID:
        status_reg = CB_IPP_M2TK_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_M2TK_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ART_ID:
        status_reg = CB_CFP_ART_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_ART_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_LPG2IG_ID:
        status_reg = CB_PQM_LPG2IG_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_LPG2IG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_IPP_PROFILE_ID:
        status_reg = CB_IPP_PROFILE_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_PROFILE_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_QFCQDADDR_ID:
        status_reg = CB_PQM_QFCQDADDR_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_QFCQDADDR_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_MTGT_ID:
        status_reg = CB_PQM_MTGT_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_MTGT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_IPP_PPTR_ID:
        status_reg = CB_IPP_PPTR_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_PPTR_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_SET_ID:
        status_reg = CB_EPP_SET_IA_STATUSr_ROBO2;
        config_reg = CB_EPP_SET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_SRT_ID:
        status_reg = CB_IPP_SRT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_SRT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_IPP_PMON_ID:
        status_reg = CB_IPP_PMON_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_PMON_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_VTCT_ID:
        status_reg = CB_ETM_VTCT_IA_STATUSr_ROBO2;
        config_reg = CB_ETM_VTCT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_CFPCAM_ID:
        status_reg = CB_CFP_CFPCAM_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_CFPCAM_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_FCD_CNTR_ID:
        status_reg = CB_BMU_FCD_CNTR_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_FCD_CNTR_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_FPSLICT_ID:
        status_reg = CB_IPP_FPSLICT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_FPSLICT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_KST_ID:
        status_reg = CB_IPP_KST_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_KST_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PQM_BUCKET_ID:
        status_reg = CB_PQM_BUCKET_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_BUCKET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_GHST_ID:
        status_reg = CB_ITM_GHST_IA_STATUSr_ROBO2;
        config_reg = CB_ITM_GHST_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_LPG2PG_ID:
        status_reg = CB_PQM_LPG2PG_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_LPG2PG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_EPGT_ID:
        status_reg = CB_EPP_EPGT_IA_STATUSr_ROBO2;
        config_reg = CB_EPP_EPGT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_BMU_RSCALE_ID:
        status_reg = CB_BMU_RSCALE_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_RSCALE_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_LPG2PPFOV_ID:
        status_reg = CB_PQM_LPG2PPFOV_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_LPG2PPFOV_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_VSIT_ID:
        status_reg = CB_IPP_VSIT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_VSIT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_QFCCREDIT_ID:
        status_reg = CB_PQM_QFCCREDIT_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_QFCCREDIT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_TET_ID:
        status_reg = CB_EPP_TET_IA_STATUSr_ROBO2;
        config_reg = CB_EPP_TET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_IPP_PP2LPG_ID:
        status_reg = CB_IPP_PP2LPG_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_PP2LPG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PQM_PPTR_ID:
        status_reg = CB_PQM_PPTR_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_PPTR_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_BMU_PMON_ID:
        status_reg = CB_BMU_PMON_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_PMON_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ETCT_ID:
        status_reg = CB_ETM_ETCT_IA_STATUSr_ROBO2;
        config_reg = CB_ETM_ETCT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ARLFM1_GHT_H0_ID:
        status_reg = CB_ITM_ARLFM1_GHT_H0_IA_STATUSr_ROBO2;
        config_reg = CB_ITM_ARLFM1_GHT_H0_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_CFP_PMON_ID:
        status_reg = CB_CFP_PMON_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_PMON_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_MAX_CONFIG_ID:
        status_reg = CB_PQS_MAX_CONFIG_IA_STATUSr_ROBO2;
        config_reg = CB_PQS_MAX_CONFIG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_BMU_PROFILE_ID:
        status_reg = CB_BMU_PROFILE_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_PROFILE_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PV2LI_ID:
        status_reg = CB_IPP_PV2LI_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_PV2LI_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_IPP_RSCALE_ID:
        status_reg = CB_IPP_RSCALE_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_RSCALE_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PQM_PMON_ID:
        status_reg = CB_PQM_PMON_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_PMON_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_IKFT_ID:
        status_reg = CB_IPP_IKFT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_IKFT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ARLFM1_GHT_H1_ID:
        status_reg = CB_ITM_ARLFM1_GHT_H1_IA_STATUSr_ROBO2;
        config_reg = CB_ITM_ARLFM1_GHT_H1_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_EPMT_ID:
        status_reg = CB_EPP_EPMT_IA_STATUSr_ROBO2;
        config_reg = CB_EPP_EPMT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID:
        status_reg = CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_STATUSr_ROBO2;
        config_reg = CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_BMU_PPTR_ID:
        status_reg = CB_BMU_PPTR_IA_STATUSr_ROBO2;
        config_reg = CB_BMU_PPTR_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ERT_ID:
        status_reg = CB_ETM_ERT_IA_STATUSr_ROBO2;
        config_reg = CB_ETM_ERT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_ACTION_ID:
        status_reg = CB_CFP_ACTION_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_ACTION_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_RPSLICT_ID:
        status_reg = CB_IPP_RPSLICT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_RPSLICT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_SLICTECC_ID:
        status_reg = CB_IPP_SLICTECC_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_SLICTECC_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_LITET_ID:
        status_reg = CB_PQM_LITET_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_LITET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_TECC_ID:
        status_reg = CB_CFP_TECC_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_TECC_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_CFP_PPTR_ID:
        status_reg = CB_CFP_PPTR_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_PPTR_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_WRT_ID:
        status_reg = CB_CFP_WRT_IA_STATUSr_ROBO2;
        config_reg = CB_CFP_WRT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_WPT_ID:
        status_reg = CB_PQM_WPT_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_WPT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_DLIET_ID:
        status_reg = CB_ETM_DLIET_IA_STATUSr_ROBO2;
        config_reg = CB_ETM_DLIET_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PGLCT_ID:
        status_reg = CB_ITM_PGLCT_IA_STATUSr_ROBO2;
        config_reg = CB_ITM_PGLCT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_LPG2AP_ID:
        status_reg = CB_PQM_LPG2AP_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_LPG2AP_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PQM_PROFILE_ID:
        status_reg = CB_PQM_PROFILE_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_PROFILE_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_CPMT_ID:
        status_reg = CB_IPP_CPMT_IA_STATUSr_ROBO2;
        config_reg = CB_IPP_CPMT_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_PQM_PP2LPG_ID:
        status_reg = CB_PQM_PP2LPG_IA_STATUSr_ROBO2;
        config_reg = CB_PQM_PP2LPG_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    case ROBO2_TABLE_OFARLFM_ID:
        status_reg = CB_ITM_OFARLFM_IA_STATUSr_ROBO2;
        config_reg = CB_ITM_OFARLFM_IA_CONFIGr_ROBO2;
        table_name = robo2_table_names[tid];
        break;
    default:
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("Error: soc_robo2_table_operation: Unknown Table id %d\n", tid));
        return SOC_E_PARAM;
    };
    if (operation != ROBO2_IA_OP_TABLE_ENABLE) {
        /* Paranoid: Check if the entry is ready to be written */
        do {
            rc = ROBO2_REG_READ_WITH_ID(unit, status_reg, REG_PORT_ANY, 0, status);
            LOG_INFO(BSL_LS_SOC_CRAL,
                ("Logging status register before operation "
                 "unit=%d, table=%s, val=%x\n", unit, table_name, *status));
            if (rc != 0) {
                LOG_ERROR(BSL_LS_SOC_CRAL,
                    ("soc_robo2_table_operation: Failed Register read for status "
                     "unit=%d, table=%s\n", unit, table_name));
                return SOC_E_FAIL;
            }
            SOC_REG_FIELD_GET(unit, status_reg, status, CODEf, &sts);
            switch (sts) {
            case ROBO2_IA_STATUS_TIMEOUT:
            case ROBO2_IA_STATUS_OVERRUN:
            case ROBO2_IA_STATUS_BAD_OFFSET:
            case ROBO2_IA_STATUS_BAD_OPCODE:
                /* Clear any error that exists */
                ROBO2_REG_READ_WITH_ID(unit, config_reg, REG_PORT_ANY, 0, &config);
                SOC_REG_FIELD_SET(unit, config_reg, &config, OPf, &clear);
                ROBO2_REG_WRITE_WITH_ID(unit, config_reg, REG_PORT_ANY, 0, &config);
                break;
            case ROBO2_IA_STATUS_POWERED_DOWN:
                return SOC_E_INIT;
            default:
                /* ready/busy */
                break;
            }
            if (sts == ROBO2_IA_STATUS_READY) { break;}
            /* Fix me */
            sal_usleep(100);
            timeout--;
        } while (timeout > 0);

        /* Did we timeout? */
        if (timeout <= 0) {
            return SOC_E_BUSY;
        }
    }
    /* Initiate required operation on the entry and wait for completion */
    SOC_REG_FIELD_SET(unit, config_reg, &config, OPf, (uint32*)&operation);
    SOC_REG_FIELD_SET(unit, config_reg, &config, ADDRf, (uint32*)&index);
    if (tid == ROBO2_TABLE_GHT_ID) {
        /* Configure sub-table id if passed along the index value */
        sts = 0;
        SOC_REG_FIELD_GET(unit, config_reg, (uint32*)&index, TABLE_IDf, &sts);
        if (sts != 0) {
            SOC_REG_FIELD_SET(unit, config_reg, &config, TABLE_IDf, &sts);
            sts = 0;
        }
    }

    ROBO2_REG_WRITE_WITH_ID(unit, config_reg, REG_PORT_ANY, 0, &config);

    /* Reset timeout */
    timeout = maxtimeout;
    do {
        rc = ROBO2_REG_READ_WITH_ID(unit, status_reg, REG_PORT_ANY, 0, status);
        LOG_INFO(BSL_LS_SOC_CRAL,
            ("Logging status register after operation "
              "unit=%d, table=%d, val=%x\n", unit, tid, *status));
        if (rc != 0) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_table_operation: Failed Register read for status, "
                   "unit=%d, table=%s\n", unit, table_name));
            return SOC_E_FAIL;
        }
        SOC_REG_FIELD_GET(unit, status_reg, status, CODEf, &sts);
        switch (sts) {
        case ROBO2_IA_STATUS_TIMEOUT:
            return SOC_E_TIMEOUT;
        case ROBO2_IA_STATUS_BAD_OFFSET:
            return SOC_E_PARAM;
        case ROBO2_IA_STATUS_OVERRUN:
            return SOC_E_FAIL;
        case ROBO2_IA_STATUS_BAD_OPCODE:
            return SOC_E_INTERNAL;
        case ROBO2_IA_STATUS_POWERED_DOWN:
            return SOC_E_INIT;
        }
        if (sts == ROBO2_IA_STATUS_READY) { break;}
        sal_usleep(100);
        timeout--;
    } while (timeout > 0);

    /* Did we timeout? */
    if (timeout <= 0) {
        return SOC_E_BUSY;
    }

    return SOC_E_NONE;
}

/**
 * @par Function:
 *     soc_robo2_table_dump
 * @par Description:
 *      This is a helper routine to dump a particular index
 *      of a table.
 *
 *    @param [in]  unit      :  Identifies the chip
 *    @param [in]  tid       :  Table info
 *    @param [in]  index     :  Index to be used
 *
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_table_dump(int unit, soc_robo2_table_id_t tid, int index)
{
    int rv = 0;
    uint32 ent[20];

    table_dump_tid = tid;

    sal_printf("************************************************\n");

    switch (tid) {
    case ROBO2_TABLE_TCT_ID:
        sal_printf("Table name: tct ; index : %d\n", index);
        rv = soc_robo2_tct_get(unit, index, (tct_t *)&ent);
        break;
    case ROBO2_TABLE_RPT_ID:
        sal_printf("Table name: rpt ; index : %d\n", index);
        rv = soc_robo2_rpt_get(unit, index, (rpt_t *)&ent);
        break;
    case ROBO2_TABLE_PGT_ID:
        sal_printf("Table name: pgt ; index : %d\n", index);
        rv = soc_robo2_pgt_get(unit, index, (pgt_t *)&ent);
        break;
    case ROBO2_TABLE_PMIPAGE_ID:
        sal_printf("Table name: pmipage ; index : %d\n", index);
        rv = soc_robo2_pmipage_get(unit, index, (pmipage_t *)&ent);
        break;
    case ROBO2_TABLE_GFCD_CONFIG_ID:
        sal_printf("Table name: gfcd_config ; index : %d\n", index);
        rv = soc_robo2_gfcd_config_get(unit, index, (gfcd_config_t *)&ent);
        break;
    case ROBO2_TABLE_APT_ID:
        sal_printf("Table name: apt ; index : %d\n", index);
        rv = soc_robo2_apt_get(unit, index, (apt_t *)&ent);
        break;
    case ROBO2_TABLE_GFCD_CNTR_ID:
        sal_printf("Table name: gfcd_cntr ; index : %d\n", index);
        rv = soc_robo2_gfcd_cntr_get(unit, index, (gfcd_cntr_t *)&ent);
        break;
    case ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID:
        sal_printf("Table name: spg_pp_bmp_config ; index : %d\n", index);
        rv = soc_robo2_spg_pp_bmp_config_get(unit, index, (spg_pp_bmp_config_t *)&ent);
        break;
    case ROBO2_TABLE_DGT_ID:
        sal_printf("Table name: dgt ; index : %d\n", index);
        rv = soc_robo2_dgt_get(unit, index, (dgt_t *)&ent);
        break;
    case ROBO2_TABLE_GSPG2IG_ID:
        sal_printf("Table name: gspg2ig ; index : %d\n", index);
        rv = soc_robo2_gspg2ig_get(unit, index, (gspg2ig_t *)&ent);
        break;
    case ROBO2_TABLE_EPP_CALENDAR_ID:
        sal_printf("Table name: epp_calendar ; index : %d\n", index);
        rv = soc_robo2_epp_calendar_get(unit, index, (epp_calendar_t *)&ent);
        break;
    case ROBO2_TABLE_GHT_ID:
        sal_printf("Table name: ght ; index : %d\n", index);
        rv = soc_robo2_ght_get(unit, index, (ght_t *)&ent);
        break;
    case ROBO2_TABLE_LIN2VSI_ID:
        sal_printf("Table name: lin2vsi ; index : %d\n", index);
        rv = soc_robo2_lin2vsi_get(unit, index, (lin2vsi_t *)&ent);
        break;
    case ROBO2_TABLE_CFP_PROFILE_ID:
        sal_printf("Table name: cfp_profile ; index : %d\n", index);
        rv = soc_robo2_cfp_profile_get(unit, index, (cfp_profile_t *)&ent);
        break;
    case ROBO2_TABLE_CFP_BUCKET_ID:
        sal_printf("Table name: cfp_bucket ; index : %d\n", index);
        rv = soc_robo2_cfp_bucket_get(unit, index, (cfp_bucket_t *)&ent);
        break;
    case ROBO2_TABLE_CALENDAR_ID:
        sal_printf("Table name: calendar ; index : %d\n", index);
        rv = soc_robo2_calendar_get(unit, index, (calendar_t *)&ent);
        break;
    case ROBO2_TABLE_PG2LPG_ID:
        sal_printf("Table name: pg2lpg ; index : %d\n", index);
        rv = soc_robo2_pg2lpg_get(unit, index, (pg2lpg_t *)&ent);
        break;
    case ROBO2_TABLE_ARLFM_ID:
        sal_printf("Table name: arlfm ; index : %d\n", index);
        rv = soc_robo2_arlfm_get(unit, index, (arlfm_t *)&ent);
        break;
    case ROBO2_TABLE_ARLFM0_ID:
        sal_printf("Table name: arlfm0 ; index : %d\n", index);
        rv = soc_robo2_arlfm0_get(unit, index, (arlfm0_t *)&ent);
        break;
    case ROBO2_TABLE_IPP_BUCKET_ID:
        sal_printf("Table name: ipp_bucket ; index : %d\n", index);
        rv = soc_robo2_ipp_bucket_get(unit, index, (ipp_bucket_t *)&ent);
        break;
    case ROBO2_TABLE_FCD_CONFIG_ID:
        sal_printf("Table name: fcd_config ; index : %d\n", index);
        rv = soc_robo2_fcd_config_get(unit, index, (fcd_config_t *)&ent);
        break;
    case ROBO2_TABLE_STAT_ID:
        sal_printf("Table name: stat ; index : %d\n", index);
        rv = soc_robo2_stat_get(unit, index, (stat_t *)&ent);
        break;
    case ROBO2_TABLE_EEECFG_ID:
        sal_printf("Table name: eeecfg ; index : %d\n", index);
        rv = soc_robo2_eeecfg_get(unit, index, (eeecfg_t *)&ent);
        break;
    case ROBO2_TABLE_HDT_ID:
        sal_printf("Table name: hdt ; index : %d\n", index);
        rv = soc_robo2_hdt_get(unit, index, (hdt_t *)&ent);
        break;
    case ROBO2_TABLE_ESTGET_ID:
        sal_printf("Table name: estget ; index : %d\n", index);
        rv = soc_robo2_estget_get(unit, index, (estget_t *)&ent);
        break;
    case ROBO2_TABLE_STT_ID:
        sal_printf("Table name: stt ; index : %d\n", index);
        rv = soc_robo2_stt_get(unit, index, (stt_t *)&ent);
        break;
    case ROBO2_TABLE_PET_ID:
        sal_printf("Table name: pet ; index : %d\n", index);
        rv = soc_robo2_pet_get(unit, index, (pet_t *)&ent);
        break;
    case ROBO2_TABLE_ISTGET_ID:
        sal_printf("Table name: istget ; index : %d\n", index);
        rv = soc_robo2_istget_get(unit, index, (istget_t *)&ent);
        break;
    case ROBO2_TABLE_QDSCHCFG_ID:
        sal_printf("Table name: qdschcfg ; index : %d\n", index);
        rv = soc_robo2_qdschcfg_get(unit, index, (qdschcfg_t *)&ent);
        break;
    case ROBO2_TABLE_PQM_RSCALE_ID:
        sal_printf("Table name: pqm_rscale ; index : %d\n", index);
        rv = soc_robo2_pqm_rscale_get(unit, index, (pqm_rscale_t *)&ent);
        break;
    case ROBO2_TABLE_MTR2TCB_ID:
        sal_printf("Table name: mtr2tcb ; index : %d\n", index);
        rv = soc_robo2_mtr2tcb_get(unit, index, (mtr2tcb_t *)&ent);
        break;
    case ROBO2_TABLE_DLI2LDPG_ID:
        sal_printf("Table name: dli2ldpg ; index : %d\n", index);
        rv = soc_robo2_dli2ldpg_get(unit, index, (dli2ldpg_t *)&ent);
        break;
    case ROBO2_TABLE_TC2QD_ID:
        sal_printf("Table name: tc2qd ; index : %d\n", index);
        rv = soc_robo2_tc2qd_get(unit, index, (tc2qd_t *)&ent);
        break;
    case ROBO2_TABLE_SPLDT_ID:
        sal_printf("Table name: spldt ; index : %d\n", index);
        rv = soc_robo2_spldt_get(unit, index, (spldt_t *)&ent);
        break;
    case ROBO2_TABLE_CFP_RSCALE_ID:
        sal_printf("Table name: cfp_rscale ; index : %d\n", index);
        rv = soc_robo2_cfp_rscale_get(unit, index, (cfp_rscale_t *)&ent);
        break;
    case ROBO2_TABLE_GHTDT_ID:
        sal_printf("Table name: ghtdt ; index : %d\n", index);
        rv = soc_robo2_ghtdt_get(unit, index, (ghtdt_t *)&ent);
        break;
    case ROBO2_TABLE_BMU_BUCKET_ID:
        sal_printf("Table name: bmu_bucket ; index : %d\n", index);
        rv = soc_robo2_bmu_bucket_get(unit, index, (bmu_bucket_t *)&ent);
        break;
    case ROBO2_TABLE_LILT_ID:
        sal_printf("Table name: lilt ; index : %d\n", index);
        rv = soc_robo2_lilt_get(unit, index, (lilt_t *)&ent);
        break;
    case ROBO2_TABLE_SVT_ID:
        sal_printf("Table name: svt ; index : %d\n", index);
        rv = soc_robo2_svt_get(unit, index, (svt_t *)&ent);
        break;
    case ROBO2_TABLE_SLICMAP_ID:
        sal_printf("Table name: slicmap ; index : %d\n", index);
        rv = soc_robo2_slicmap_get(unit, index, (slicmap_t *)&ent);
        break;
    case ROBO2_TABLE_M2TK_ID:
        sal_printf("Table name: m2tk ; index : %d\n", index);
        rv = soc_robo2_m2tk_get(unit, index, (m2tk_t *)&ent);
        break;
    case ROBO2_TABLE_ART_ID:
        sal_printf("Table name: art ; index : %d\n", index);
        rv = soc_robo2_art_get(unit, index, (art_t *)&ent);
        break;
    case ROBO2_TABLE_LPG2IG_ID:
        sal_printf("Table name: lpg2ig ; index : %d\n", index);
        rv = soc_robo2_lpg2ig_get(unit, index, (lpg2ig_t *)&ent);
        break;
    case ROBO2_TABLE_IPP_PROFILE_ID:
        sal_printf("Table name: ipp_profile ; index : %d\n", index);
        rv = soc_robo2_ipp_profile_get(unit, index, (ipp_profile_t *)&ent);
        break;
    case ROBO2_TABLE_QFCQDADDR_ID:
        sal_printf("Table name: qfcqdaddr ; index : %d\n", index);
        rv = soc_robo2_qfcqdaddr_get(unit, index, (qfcqdaddr_t *)&ent);
        break;
    case ROBO2_TABLE_MTGT_ID:
        sal_printf("Table name: mtgt ; index : %d\n", index);
        rv = soc_robo2_mtgt_get(unit, index, (mtgt_t *)&ent);
        break;
    case ROBO2_TABLE_IPP_PPTR_ID:
        sal_printf("Table name: ipp_pptr ; index : %d\n", index);
        rv = soc_robo2_ipp_pptr_get(unit, index, (ipp_pptr_t *)&ent);
        break;
    case ROBO2_TABLE_SET_ID:
        sal_printf("Table name: set ; index : %d\n", index);
        rv = soc_robo2_set_get(unit, index, (set_t *)&ent);
        break;
    case ROBO2_TABLE_SRT_ID:
        sal_printf("Table name: srt ; index : %d\n", index);
        rv = soc_robo2_srt_get(unit, index, (srt_t *)&ent);
        break;
    case ROBO2_TABLE_IPP_PMON_ID:
        sal_printf("Table name: ipp_pmon ; index : %d\n", index);
        rv = soc_robo2_ipp_pmon_get(unit, index, (ipp_pmon_t *)&ent);
        break;
    case ROBO2_TABLE_VTCT_ID:
        sal_printf("Table name: vtct ; index : %d\n", index);
        rv = soc_robo2_vtct_get(unit, index, (vtct_t *)&ent);
        break;
    case ROBO2_TABLE_CFPCAM_ID:
        sal_printf("Table name: cfpcam ; index : %d\n", index);
        rv = soc_robo2_cfpcam_get(unit, index, (cfpcam_t *)&ent);
        break;
    case ROBO2_TABLE_FCD_CNTR_ID:
        sal_printf("Table name: fcd_cntr ; index : %d\n", index);
        rv = soc_robo2_fcd_cntr_get(unit, index, (fcd_cntr_t *)&ent);
        break;
    case ROBO2_TABLE_FPSLICT_ID:
        sal_printf("Table name: fpslict ; index : %d\n", index);
        rv = soc_robo2_fpslict_get(unit, index, (fpslict_t *)&ent);
        break;
    case ROBO2_TABLE_KST_ID:
        sal_printf("Table name: kst ; index : %d\n", index);
        rv = soc_robo2_kst_get(unit, index, (kst_t *)&ent);
        break;
    case ROBO2_TABLE_PQM_BUCKET_ID:
        sal_printf("Table name: pqm_bucket ; index : %d\n", index);
        rv = soc_robo2_pqm_bucket_get(unit, index, (pqm_bucket_t *)&ent);
        break;
    case ROBO2_TABLE_GHST_ID:
        sal_printf("Table name: ghst ; index : %d\n", index);
        rv = soc_robo2_ghst_get(unit, index, (ghst_t *)&ent);
        break;
    case ROBO2_TABLE_LPG2PG_ID:
        sal_printf("Table name: lpg2pg ; index : %d\n", index);
        rv = soc_robo2_lpg2pg_get(unit, index, (lpg2pg_t *)&ent);
        break;
    case ROBO2_TABLE_EPGT_ID:
        sal_printf("Table name: epgt ; index : %d\n", index);
        rv = soc_robo2_epgt_get(unit, index, (epgt_t *)&ent);
        break;
    case ROBO2_TABLE_BMU_RSCALE_ID:
        sal_printf("Table name: bmu_rscale ; index : %d\n", index);
        rv = soc_robo2_bmu_rscale_get(unit, index, (bmu_rscale_t *)&ent);
        break;
    case ROBO2_TABLE_LPG2PPFOV_ID:
        sal_printf("Table name: lpg2ppfov ; index : %d\n", index);
        rv = soc_robo2_lpg2ppfov_get(unit, index, (lpg2ppfov_t *)&ent);
        break;
    case ROBO2_TABLE_VSIT_ID:
        sal_printf("Table name: vsit ; index : %d\n", index);
        rv = soc_robo2_vsit_get(unit, index, (vsit_t *)&ent);
        break;
    case ROBO2_TABLE_QFCCREDIT_ID:
        sal_printf("Table name: qfccredit ; index : %d\n", index);
        rv = soc_robo2_qfccredit_get(unit, index, (qfccredit_t *)&ent);
        break;
    case ROBO2_TABLE_TET_ID:
        sal_printf("Table name: tet ; index : %d\n", index);
        rv = soc_robo2_tet_get(unit, index, (tet_t *)&ent);
        break;
    case ROBO2_TABLE_IPP_PP2LPG_ID:
        sal_printf("Table name: ipp_pp2lpg ; index : %d\n", index);
        rv = soc_robo2_ipp_pp2lpg_get(unit, index, (ipp_pp2lpg_t *)&ent);
        break;
    case ROBO2_TABLE_PQM_PPTR_ID:
        sal_printf("Table name: pqm_pptr ; index : %d\n", index);
        rv = soc_robo2_pqm_pptr_get(unit, index, (pqm_pptr_t *)&ent);
        break;
    case ROBO2_TABLE_BMU_PMON_ID:
        sal_printf("Table name: bmu_pmon ; index : %d\n", index);
        rv = soc_robo2_bmu_pmon_get(unit, index, (bmu_pmon_t *)&ent);
        break;
    case ROBO2_TABLE_ETCT_ID:
        sal_printf("Table name: etct ; index : %d\n", index);
        rv = soc_robo2_etct_get(unit, index, (etct_t *)&ent);
        break;
    case ROBO2_TABLE_ARLFM1_GHT_H0_ID:
        sal_printf("Table name: arlfm1_ght_h0 ; index : %d\n", index);
        rv = soc_robo2_arlfm1_ght_h0_get(unit, index, (arlfm1_ght_h0_t *)&ent);
        break;
    case ROBO2_TABLE_CFP_PMON_ID:
        sal_printf("Table name: cfp_pmon ; index : %d\n", index);
        rv = soc_robo2_cfp_pmon_get(unit, index, (cfp_pmon_t *)&ent);
        break;
    case ROBO2_TABLE_MAX_CONFIG_ID:
        sal_printf("Table name: max_config ; index : %d\n", index);
        rv = soc_robo2_max_config_get(unit, index, (max_config_t *)&ent);
        break;
    case ROBO2_TABLE_BMU_PROFILE_ID:
        sal_printf("Table name: bmu_profile ; index : %d\n", index);
        rv = soc_robo2_bmu_profile_get(unit, index, (bmu_profile_t *)&ent);
        break;
    case ROBO2_TABLE_PV2LI_ID:
        sal_printf("Table name: pv2li ; index : %d\n", index);
        rv = soc_robo2_pv2li_get(unit, index, (pv2li_t *)&ent);
        break;
    case ROBO2_TABLE_IPP_RSCALE_ID:
        sal_printf("Table name: ipp_rscale ; index : %d\n", index);
        rv = soc_robo2_ipp_rscale_get(unit, index, (ipp_rscale_t *)&ent);
        break;
    case ROBO2_TABLE_PQM_PMON_ID:
        sal_printf("Table name: pqm_pmon ; index : %d\n", index);
        rv = soc_robo2_pqm_pmon_get(unit, index, (pqm_pmon_t *)&ent);
        break;
    case ROBO2_TABLE_IKFT_ID:
        sal_printf("Table name: ikft ; index : %d\n", index);
        rv = soc_robo2_ikft_get(unit, index, (ikft_t *)&ent);
        break;
    case ROBO2_TABLE_ARLFM1_GHT_H1_ID:
        sal_printf("Table name: arlfm1_ght_h1 ; index : %d\n", index);
        rv = soc_robo2_arlfm1_ght_h1_get(unit, index, (arlfm1_ght_h1_t *)&ent);
        break;
    case ROBO2_TABLE_EPMT_ID:
        sal_printf("Table name: epmt ; index : %d\n", index);
        rv = soc_robo2_epmt_get(unit, index, (epmt_t *)&ent);
        break;
    case ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID:
        sal_printf("Table name: epp_bmu_tx_reorder_req_lmt ; index : %d\n", index);
        rv = soc_robo2_epp_bmu_tx_reorder_req_lmt_get(unit, index, (epp_bmu_tx_reorder_req_lmt_t *)&ent);
        break;
    case ROBO2_TABLE_BMU_PPTR_ID:
        sal_printf("Table name: bmu_pptr ; index : %d\n", index);
        rv = soc_robo2_bmu_pptr_get(unit, index, (bmu_pptr_t *)&ent);
        break;
    case ROBO2_TABLE_ERT_ID:
        sal_printf("Table name: ert ; index : %d\n", index);
        rv = soc_robo2_ert_get(unit, index, (ert_t *)&ent);
        break;
    case ROBO2_TABLE_ACTION_ID:
        sal_printf("Table name: action ; index : %d\n", index);
        rv = soc_robo2_action_get(unit, index, (action_t *)&ent);
        break;
    case ROBO2_TABLE_RPSLICT_ID:
        sal_printf("Table name: rpslict ; index : %d\n", index);
        rv = soc_robo2_rpslict_get(unit, index, (rpslict_t *)&ent);
        break;
    case ROBO2_TABLE_SLICTECC_ID:
        sal_printf("Table name: slictecc ; index : %d\n", index);
        rv = soc_robo2_slictecc_get(unit, index, (slictecc_t *)&ent);
        break;
    case ROBO2_TABLE_LITET_ID:
        sal_printf("Table name: litet ; index : %d\n", index);
        rv = soc_robo2_litet_get(unit, index, (litet_t *)&ent);
        break;
    case ROBO2_TABLE_TECC_ID:
        sal_printf("Table name: tecc ; index : %d\n", index);
        rv = soc_robo2_tecc_get(unit, index, (tecc_t *)&ent);
        break;
    case ROBO2_TABLE_CFP_PPTR_ID:
        sal_printf("Table name: cfp_pptr ; index : %d\n", index);
        rv = soc_robo2_cfp_pptr_get(unit, index, (cfp_pptr_t *)&ent);
        break;
    case ROBO2_TABLE_WRT_ID:
        sal_printf("Table name: wrt ; index : %d\n", index);
        rv = soc_robo2_wrt_get(unit, index, (wrt_t *)&ent);
        break;
    case ROBO2_TABLE_WPT_ID:
        sal_printf("Table name: wpt ; index : %d\n", index);
        rv = soc_robo2_wpt_get(unit, index, (wpt_t *)&ent);
        break;
    case ROBO2_TABLE_DLIET_ID:
        sal_printf("Table name: dliet ; index : %d\n", index);
        rv = soc_robo2_dliet_get(unit, index, (dliet_t *)&ent);
        break;
    case ROBO2_TABLE_PGLCT_ID:
        sal_printf("Table name: pglct ; index : %d\n", index);
        rv = soc_robo2_pglct_get(unit, index, (pglct_t *)&ent);
        break;
    case ROBO2_TABLE_LPG2AP_ID:
        sal_printf("Table name: lpg2ap ; index : %d\n", index);
        rv = soc_robo2_lpg2ap_get(unit, index, (lpg2ap_t *)&ent);
        break;
    case ROBO2_TABLE_PQM_PROFILE_ID:
        sal_printf("Table name: pqm_profile ; index : %d\n", index);
        rv = soc_robo2_pqm_profile_get(unit, index, (pqm_profile_t *)&ent);
        break;
    case ROBO2_TABLE_CPMT_ID:
        sal_printf("Table name: cpmt ; index : %d\n", index);
        rv = soc_robo2_cpmt_get(unit, index, (cpmt_t *)&ent);
        break;
    case ROBO2_TABLE_PQM_PP2LPG_ID:
        sal_printf("Table name: pqm_pp2lpg ; index : %d\n", index);
        rv = soc_robo2_pqm_pp2lpg_get(unit, index, (pqm_pp2lpg_t *)&ent);
        break;
    case ROBO2_TABLE_OFARLFM_ID:
        sal_printf("Table name: ofarlfm ; index : %d\n", index);
        rv = soc_robo2_ofarlfm_get(unit, index, (ofarlfm_t *)&ent);
        break;
    default:
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("Error: soc_robo2_table_dump: Unknown Table id %d\n", tid));
        rv = SOC_E_PARAM;
        break;
    };

    sal_printf("------------------------------------------------\n");

    table_dump_tid = -1;
    return rv;
}

/**
 * @par Function: 
 *      soc_robo2_tct_max_index
 * @par Description:
 *      Return the max valid index for tct table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_tct_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_TCT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_max_index: Failed register "
                "CB_IPP_TCT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_TCT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_rpt_max_index
 * @par Description:
 *      Return the max valid index for rpt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_rpt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_RPT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_max_index: Failed register "
                "CB_IPP_RPT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_RPT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pgt_max_index
 * @par Description:
 *      Return the max valid index for pgt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pgt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_PGT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_max_index: Failed register "
                "CB_IPP_PGT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_PGT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pmipage_max_index
 * @par Description:
 *      Return the max valid index for pmipage table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pmipage_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PMI_PMIPAGE_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_max_index: Failed register "
                "CB_PMI_PMIPAGE_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PMI_PMIPAGE_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_config_max_index
 * @par Description:
 *      Return the max valid index for gfcd_config table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_gfcd_config_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_GFCD_CONFIG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_max_index: Failed register "
                "CB_BMU_GFCD_CONFIG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_GFCD_CONFIG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_apt_max_index
 * @par Description:
 *      Return the max valid index for apt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_apt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_APT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_max_index: Failed register "
                "CB_PQM_APT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_APT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_cntr_max_index
 * @par Description:
 *      Return the max valid index for gfcd_cntr table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_gfcd_cntr_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_GFCD_CNTR_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_max_index: Failed register "
                "CB_BMU_GFCD_CNTR_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_GFCD_CNTR_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_spg_pp_bmp_config_max_index
 * @par Description:
 *      Return the max valid index for spg_pp_bmp_config table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_spg_pp_bmp_config_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_SPG_PP_BMP_CONFIG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_max_index: Failed register "
                "CB_BMU_SPG_PP_BMP_CONFIG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_SPG_PP_BMP_CONFIG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_dgt_max_index
 * @par Description:
 *      Return the max valid index for dgt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_dgt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_DGT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_max_index: Failed register "
                "CB_PQM_DGT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_DGT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_gspg2ig_max_index
 * @par Description:
 *      Return the max valid index for gspg2ig table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_gspg2ig_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_GSPG2IG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_max_index: Failed register "
                "CB_IPP_GSPG2IG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_GSPG2IG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_epp_calendar_max_index
 * @par Description:
 *      Return the max valid index for epp_calendar table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_epp_calendar_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_EPP_EPP_CALENDAR_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_max_index: Failed register "
                "CB_EPP_EPP_CALENDAR_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_EPP_EPP_CALENDAR_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ght_max_index
 * @par Description:
 *      Return the max valid index for ght table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ght_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ITM_GHT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_max_index: Failed register "
                "CB_ITM_GHT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ITM_GHT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_lin2vsi_max_index
 * @par Description:
 *      Return the max valid index for lin2vsi table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_lin2vsi_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_LIN2VSI_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_max_index: Failed register "
                "CB_IPP_LIN2VSI_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_LIN2VSI_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_profile_max_index
 * @par Description:
 *      Return the max valid index for cfp_profile table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_cfp_profile_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_PROFILE_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_max_index: Failed register "
                "CB_CFP_PROFILE_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_PROFILE_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_bucket_max_index
 * @par Description:
 *      Return the max valid index for cfp_bucket table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_cfp_bucket_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_BUCKET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_max_index: Failed register "
                "CB_CFP_BUCKET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_BUCKET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_calendar_max_index
 * @par Description:
 *      Return the max valid index for calendar table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_calendar_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQS_CALENDAR_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_max_index: Failed register "
                "CB_PQS_CALENDAR_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQS_CALENDAR_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pg2lpg_max_index
 * @par Description:
 *      Return the max valid index for pg2lpg table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pg2lpg_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_PG2LPG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_max_index: Failed register "
                "CB_PQM_PG2LPG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_PG2LPG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm_max_index
 * @par Description:
 *      Return the max valid index for arlfm table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_arlfm_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ITM_ARLFM_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_max_index: Failed register "
                "CB_ITM_ARLFM_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ITM_ARLFM_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm0_max_index
 * @par Description:
 *      Return the max valid index for arlfm0 table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_arlfm0_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ITM_ARLFM0_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_max_index: Failed register "
                "CB_ITM_ARLFM0_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ITM_ARLFM0_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_bucket_max_index
 * @par Description:
 *      Return the max valid index for ipp_bucket table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ipp_bucket_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_BUCKET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_max_index: Failed register "
                "CB_IPP_BUCKET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_BUCKET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_config_max_index
 * @par Description:
 *      Return the max valid index for fcd_config table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_fcd_config_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_FCD_CONFIG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_max_index: Failed register "
                "CB_BMU_FCD_CONFIG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_FCD_CONFIG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_stat_max_index
 * @par Description:
 *      Return the max valid index for stat table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_stat_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_STAT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_max_index: Failed register "
                "CB_CFP_STAT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_STAT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_eeecfg_max_index
 * @par Description:
 *      Return the max valid index for eeecfg table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_eeecfg_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_EEECFG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_max_index: Failed register "
                "CB_PQM_EEECFG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_EEECFG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_hdt_max_index
 * @par Description:
 *      Return the max valid index for hdt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_hdt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_HDT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_max_index: Failed register "
                "CB_IPP_HDT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_HDT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_estget_max_index
 * @par Description:
 *      Return the max valid index for estget table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_estget_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_ESTGET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_max_index: Failed register "
                "CB_PQM_ESTGET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_ESTGET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_stt_max_index
 * @par Description:
 *      Return the max valid index for stt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_stt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_STT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_max_index: Failed register "
                "CB_IPP_STT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_STT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pet_max_index
 * @par Description:
 *      Return the max valid index for pet table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pet_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ETM_PET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_max_index: Failed register "
                "CB_ETM_PET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ETM_PET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_istget_max_index
 * @par Description:
 *      Return the max valid index for istget table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_istget_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_ISTGET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_max_index: Failed register "
                "CB_IPP_ISTGET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_ISTGET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_qdschcfg_max_index
 * @par Description:
 *      Return the max valid index for qdschcfg table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_qdschcfg_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_QDSCHCFG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_max_index: Failed register "
                "CB_PQM_QDSCHCFG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_QDSCHCFG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_rscale_max_index
 * @par Description:
 *      Return the max valid index for pqm_rscale table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pqm_rscale_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_RSCALE_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_max_index: Failed register "
                "CB_PQM_RSCALE_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_RSCALE_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_mtr2tcb_max_index
 * @par Description:
 *      Return the max valid index for mtr2tcb table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_mtr2tcb_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_MTR2TCB_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_max_index: Failed register "
                "CB_BMU_MTR2TCB_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_MTR2TCB_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_dli2ldpg_max_index
 * @par Description:
 *      Return the max valid index for dli2ldpg table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_dli2ldpg_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_DLI2LDPG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_max_index: Failed register "
                "CB_PQM_DLI2LDPG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_DLI2LDPG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_tc2qd_max_index
 * @par Description:
 *      Return the max valid index for tc2qd table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_tc2qd_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_TC2QD_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_max_index: Failed register "
                "CB_PQM_TC2QD_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_TC2QD_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_spldt_max_index
 * @par Description:
 *      Return the max valid index for spldt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_spldt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_EPP_SPLDT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_max_index: Failed register "
                "CB_EPP_SPLDT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_EPP_SPLDT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_rscale_max_index
 * @par Description:
 *      Return the max valid index for cfp_rscale table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_cfp_rscale_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_RSCALE_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_max_index: Failed register "
                "CB_CFP_RSCALE_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_RSCALE_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ghtdt_max_index
 * @par Description:
 *      Return the max valid index for ghtdt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ghtdt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ITM_GHTDT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_max_index: Failed register "
                "CB_ITM_GHTDT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ITM_GHTDT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_bucket_max_index
 * @par Description:
 *      Return the max valid index for bmu_bucket table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_bmu_bucket_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_BUCKET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_max_index: Failed register "
                "CB_BMU_BUCKET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_BUCKET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_lilt_max_index
 * @par Description:
 *      Return the max valid index for lilt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_lilt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_LILT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_max_index: Failed register "
                "CB_PQM_LILT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_LILT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_svt_max_index
 * @par Description:
 *      Return the max valid index for svt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_svt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_SVT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_max_index: Failed register "
                "CB_PQM_SVT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_SVT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_slicmap_max_index
 * @par Description:
 *      Return the max valid index for slicmap table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_slicmap_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_SLICMAP_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_max_index: Failed register "
                "CB_IPP_SLICMAP_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_SLICMAP_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_m2tk_max_index
 * @par Description:
 *      Return the max valid index for m2tk table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_m2tk_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_M2TK_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_max_index: Failed register "
                "CB_IPP_M2TK_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_M2TK_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_art_max_index
 * @par Description:
 *      Return the max valid index for art table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_art_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_ART_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_max_index: Failed register "
                "CB_CFP_ART_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_ART_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ig_max_index
 * @par Description:
 *      Return the max valid index for lpg2ig table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_lpg2ig_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_LPG2IG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_max_index: Failed register "
                "CB_PQM_LPG2IG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_LPG2IG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_profile_max_index
 * @par Description:
 *      Return the max valid index for ipp_profile table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ipp_profile_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_PROFILE_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_max_index: Failed register "
                "CB_IPP_PROFILE_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_PROFILE_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_qfcqdaddr_max_index
 * @par Description:
 *      Return the max valid index for qfcqdaddr table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_qfcqdaddr_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_QFCQDADDR_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_max_index: Failed register "
                "CB_PQM_QFCQDADDR_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_QFCQDADDR_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_mtgt_max_index
 * @par Description:
 *      Return the max valid index for mtgt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_mtgt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_MTGT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_max_index: Failed register "
                "CB_PQM_MTGT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_MTGT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pptr_max_index
 * @par Description:
 *      Return the max valid index for ipp_pptr table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ipp_pptr_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_PPTR_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_max_index: Failed register "
                "CB_IPP_PPTR_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_PPTR_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_set_max_index
 * @par Description:
 *      Return the max valid index for set table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_set_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_EPP_SET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_max_index: Failed register "
                "CB_EPP_SET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_EPP_SET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_srt_max_index
 * @par Description:
 *      Return the max valid index for srt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_srt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_SRT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_max_index: Failed register "
                "CB_IPP_SRT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_SRT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pmon_max_index
 * @par Description:
 *      Return the max valid index for ipp_pmon table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ipp_pmon_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_PMON_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_max_index: Failed register "
                "CB_IPP_PMON_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_PMON_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_vtct_max_index
 * @par Description:
 *      Return the max valid index for vtct table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_vtct_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ETM_VTCT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_max_index: Failed register "
                "CB_ETM_VTCT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ETM_VTCT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_cfpcam_max_index
 * @par Description:
 *      Return the max valid index for cfpcam table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_cfpcam_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_CFPCAM_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_max_index: Failed register "
                "CB_CFP_CFPCAM_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_CFPCAM_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_cntr_max_index
 * @par Description:
 *      Return the max valid index for fcd_cntr table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_fcd_cntr_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_FCD_CNTR_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_max_index: Failed register "
                "CB_BMU_FCD_CNTR_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_FCD_CNTR_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_fpslict_max_index
 * @par Description:
 *      Return the max valid index for fpslict table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_fpslict_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_FPSLICT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_max_index: Failed register "
                "CB_IPP_FPSLICT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_FPSLICT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_kst_max_index
 * @par Description:
 *      Return the max valid index for kst table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_kst_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_KST_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_max_index: Failed register "
                "CB_IPP_KST_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_KST_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_bucket_max_index
 * @par Description:
 *      Return the max valid index for pqm_bucket table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pqm_bucket_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_BUCKET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_max_index: Failed register "
                "CB_PQM_BUCKET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_BUCKET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ghst_max_index
 * @par Description:
 *      Return the max valid index for ghst table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ghst_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ITM_GHST_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_max_index: Failed register "
                "CB_ITM_GHST_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ITM_GHST_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2pg_max_index
 * @par Description:
 *      Return the max valid index for lpg2pg table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_lpg2pg_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_LPG2PG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_max_index: Failed register "
                "CB_PQM_LPG2PG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_LPG2PG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_epgt_max_index
 * @par Description:
 *      Return the max valid index for epgt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_epgt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_EPP_EPGT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_max_index: Failed register "
                "CB_EPP_EPGT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_EPP_EPGT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_rscale_max_index
 * @par Description:
 *      Return the max valid index for bmu_rscale table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_bmu_rscale_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_RSCALE_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_max_index: Failed register "
                "CB_BMU_RSCALE_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_RSCALE_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ppfov_max_index
 * @par Description:
 *      Return the max valid index for lpg2ppfov table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_lpg2ppfov_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_LPG2PPFOV_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_max_index: Failed register "
                "CB_PQM_LPG2PPFOV_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_LPG2PPFOV_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_vsit_max_index
 * @par Description:
 *      Return the max valid index for vsit table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_vsit_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_VSIT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_max_index: Failed register "
                "CB_IPP_VSIT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_VSIT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_qfccredit_max_index
 * @par Description:
 *      Return the max valid index for qfccredit table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_qfccredit_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_QFCCREDIT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_max_index: Failed register "
                "CB_PQM_QFCCREDIT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_QFCCREDIT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_tet_max_index
 * @par Description:
 *      Return the max valid index for tet table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_tet_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_EPP_TET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_max_index: Failed register "
                "CB_EPP_TET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_EPP_TET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pp2lpg_max_index
 * @par Description:
 *      Return the max valid index for ipp_pp2lpg table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ipp_pp2lpg_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_PP2LPG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_max_index: Failed register "
                "CB_IPP_PP2LPG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_PP2LPG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pptr_max_index
 * @par Description:
 *      Return the max valid index for pqm_pptr table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pqm_pptr_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_PPTR_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_max_index: Failed register "
                "CB_PQM_PPTR_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_PPTR_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pmon_max_index
 * @par Description:
 *      Return the max valid index for bmu_pmon table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_bmu_pmon_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_PMON_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_max_index: Failed register "
                "CB_BMU_PMON_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_PMON_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_etct_max_index
 * @par Description:
 *      Return the max valid index for etct table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_etct_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ETM_ETCT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_max_index: Failed register "
                "CB_ETM_ETCT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ETM_ETCT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h0_max_index
 * @par Description:
 *      Return the max valid index for arlfm1_ght_h0 table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_arlfm1_ght_h0_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H0_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_max_index: Failed register "
                "CB_ITM_ARLFM1_GHT_H0_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ITM_ARLFM1_GHT_H0_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pmon_max_index
 * @par Description:
 *      Return the max valid index for cfp_pmon table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_cfp_pmon_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_PMON_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_max_index: Failed register "
                "CB_CFP_PMON_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_PMON_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_max_config_max_index
 * @par Description:
 *      Return the max valid index for max_config table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_max_config_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQS_MAX_CONFIG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_max_index: Failed register "
                "CB_PQS_MAX_CONFIG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQS_MAX_CONFIG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_profile_max_index
 * @par Description:
 *      Return the max valid index for bmu_profile table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_bmu_profile_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_PROFILE_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_max_index: Failed register "
                "CB_BMU_PROFILE_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_PROFILE_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pv2li_max_index
 * @par Description:
 *      Return the max valid index for pv2li table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pv2li_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_PV2LI_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_max_index: Failed register "
                "CB_IPP_PV2LI_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_PV2LI_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_rscale_max_index
 * @par Description:
 *      Return the max valid index for ipp_rscale table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ipp_rscale_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_RSCALE_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_max_index: Failed register "
                "CB_IPP_RSCALE_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_RSCALE_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pmon_max_index
 * @par Description:
 *      Return the max valid index for pqm_pmon table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pqm_pmon_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_PMON_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_max_index: Failed register "
                "CB_PQM_PMON_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_PMON_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ikft_max_index
 * @par Description:
 *      Return the max valid index for ikft table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ikft_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_IKFT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_max_index: Failed register "
                "CB_IPP_IKFT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_IKFT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h1_max_index
 * @par Description:
 *      Return the max valid index for arlfm1_ght_h1 table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_arlfm1_ght_h1_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H1_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_max_index: Failed register "
                "CB_ITM_ARLFM1_GHT_H1_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ITM_ARLFM1_GHT_H1_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_epmt_max_index
 * @par Description:
 *      Return the max valid index for epmt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_epmt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_EPP_EPMT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_max_index: Failed register "
                "CB_EPP_EPMT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_EPP_EPMT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_epp_bmu_tx_reorder_req_lmt_max_index
 * @par Description:
 *      Return the max valid index for epp_bmu_tx_reorder_req_lmt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_epp_bmu_tx_reorder_req_lmt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_max_index: Failed register "
                "CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pptr_max_index
 * @par Description:
 *      Return the max valid index for bmu_pptr table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_bmu_pptr_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_BMU_PPTR_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_max_index: Failed register "
                "CB_BMU_PPTR_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_BMU_PPTR_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ert_max_index
 * @par Description:
 *      Return the max valid index for ert table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ert_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ETM_ERT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_max_index: Failed register "
                "CB_ETM_ERT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ETM_ERT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_action_max_index
 * @par Description:
 *      Return the max valid index for action table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_action_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_ACTION_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_max_index: Failed register "
                "CB_CFP_ACTION_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_ACTION_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_rpslict_max_index
 * @par Description:
 *      Return the max valid index for rpslict table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_rpslict_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_RPSLICT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_max_index: Failed register "
                "CB_IPP_RPSLICT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_RPSLICT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_slictecc_max_index
 * @par Description:
 *      Return the max valid index for slictecc table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_slictecc_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_SLICTECC_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_max_index: Failed register "
                "CB_IPP_SLICTECC_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_SLICTECC_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_litet_max_index
 * @par Description:
 *      Return the max valid index for litet table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_litet_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_LITET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_max_index: Failed register "
                "CB_PQM_LITET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_LITET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_tecc_max_index
 * @par Description:
 *      Return the max valid index for tecc table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_tecc_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_TECC_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_max_index: Failed register "
                "CB_CFP_TECC_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_TECC_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pptr_max_index
 * @par Description:
 *      Return the max valid index for cfp_pptr table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_cfp_pptr_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_PPTR_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_max_index: Failed register "
                "CB_CFP_PPTR_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_PPTR_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_wrt_max_index
 * @par Description:
 *      Return the max valid index for wrt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_wrt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_CFP_WRT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_max_index: Failed register "
                "CB_CFP_WRT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_CFP_WRT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_wpt_max_index
 * @par Description:
 *      Return the max valid index for wpt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_wpt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_WPT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_max_index: Failed register "
                "CB_PQM_WPT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_WPT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_dliet_max_index
 * @par Description:
 *      Return the max valid index for dliet table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_dliet_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ETM_DLIET_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_max_index: Failed register "
                "CB_ETM_DLIET_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ETM_DLIET_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pglct_max_index
 * @par Description:
 *      Return the max valid index for pglct table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pglct_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ITM_PGLCT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_max_index: Failed register "
                "CB_ITM_PGLCT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ITM_PGLCT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ap_max_index
 * @par Description:
 *      Return the max valid index for lpg2ap table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_lpg2ap_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_LPG2AP_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_max_index: Failed register "
                "CB_PQM_LPG2AP_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_LPG2AP_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_profile_max_index
 * @par Description:
 *      Return the max valid index for pqm_profile table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pqm_profile_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_PROFILE_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_max_index: Failed register "
                "CB_PQM_PROFILE_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_PROFILE_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_cpmt_max_index
 * @par Description:
 *      Return the max valid index for cpmt table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_cpmt_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_IPP_CPMT_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_max_index: Failed register "
                "CB_IPP_CPMT_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_IPP_CPMT_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pp2lpg_max_index
 * @par Description:
 *      Return the max valid index for pqm_pp2lpg table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_pqm_pp2lpg_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_PQM_PP2LPG_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_max_index: Failed register "
                "CB_PQM_PP2LPG_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_PQM_PP2LPG_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_ofarlfm_max_index
 * @par Description:
 *      Return the max valid index for ofarlfm table
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @returns Integer, Max index on success
 *     -1 on failure
 */
int
soc_robo2_ofarlfm_max_index(int unit)
{
    uint32 regval = 0;
    uint32 index = 0;
    int rc = 0;
   
    rc = REG_READ_CB_ITM_OFARLFM_IA_STATUSr(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_max_index: Failed register "
                "CB_ITM_OFARLFM_IA_STATUSr read\n"));
        return -1;
    }
    SOC_REG_FIELD_GET(unit, CB_ITM_OFARLFM_IA_STATUSr, &regval, ADDRf, &index);
    return index;
}

/**
 * @par Function: 
 *      soc_robo2_tct_get
 * @par Description:
 *      Perform a read on the tct table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_tct_get(int unit, int index, tct_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(tct_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TCT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_get: Failed reading table %s index %d rc %d\n",
                "tct", index, rc));
        sal_mutex_give(tct_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_TCT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_get: Failed register "
                "CB_IPP_TCT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(tct_mutex);
        return rc;
    }
    soc_CB_IPP_TCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DROPf, &tmpval);
    entry->drop = tmpval & 1;
    soc_CB_IPP_TCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TERMf, &tmpval);
    entry->term = tmpval & 1;
    soc_CB_IPP_TCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TRAP_GROUPf, &tmpval);
    entry->trap_group = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_TCT_ID) {
        sal_printf("DROPf = 0x%x\n", entry->drop);
        sal_printf("TERMf = 0x%x\n", entry->term);
        sal_printf("TRAP_GROUPf = 0x%x\n", entry->trap_group);
    }
    sal_mutex_give(tct_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_rpt_get
 * @par Description:
 *      Perform a read on the rpt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpt_get(int unit, int index, rpt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(rpt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_get: Failed reading table %s index %d rc %d\n",
                "rpt", index, rc));
        sal_mutex_give(rpt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_RPT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_get: Failed register "
                "CB_IPP_RPT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(rpt_mutex);
        return rc;
    }
    soc_CB_IPP_RPT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SOURCEf, &tmpval);
    entry->source = tmpval & 3;
    rc = REG_READ_CB_IPP_RPT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_get: Failed register "
                "CB_IPP_RPT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(rpt_mutex);
        return rc;
    }
    soc_CB_IPP_RPT_IA_RDATA_PART1r_field_get(unit, &regval, 
        HIf, &tmpval);
    entry->hi = tmpval & 65535;
    soc_CB_IPP_RPT_IA_RDATA_PART1r_field_get(unit, &regval, 
        LOf, &tmpval);
    entry->lo = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_RPT_ID) {
        sal_printf("SOURCEf = 0x%x\n", entry->source);
        sal_printf("HIf = 0x%x\n", entry->hi);
        sal_printf("LOf = 0x%x\n", entry->lo);
    }
    sal_mutex_give(rpt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pgt_get
 * @par Description:
 *      Perform a read on the pgt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pgt_get(int unit, int index, pgt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pgt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed reading table %s index %d rc %d\n",
                "pgt", index, rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        PPPOE_ENf, &tmpval);
    entry->pppoe_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        ITAG_ENf, &tmpval);
    entry->itag_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TAG_PARSE_ENf, &tmpval);
    entry->tag_parse_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        IPV4_ENf, &tmpval);
    entry->ipv4_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SLIC_MAP_ENf, &tmpval);
    entry->slic_map_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        CTAG_ENf, &tmpval);
    entry->ctag_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SOFT_TAG_ENf, &tmpval);
    entry->soft_tag_en = tmpval & 63;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        MCMPLS_ENf, &tmpval);
    entry->mcmpls_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        METADATA_LENf, &tmpval);
    entry->metadata_len = tmpval & 3;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        LLC_ENf, &tmpval);
    entry->llc_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        PTP_ENf, &tmpval);
    entry->ptp_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        ETAG_ENf, &tmpval);
    entry->etag_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        STAG_ENf, &tmpval);
    entry->stag_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        IPV6_ENf, &tmpval);
    entry->ipv6_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TLV_PARSE_ENf, &tmpval);
    entry->tlv_parse_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        ARP_ENf, &tmpval);
    entry->arp_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        UCMPLS_ENf, &tmpval);
    entry->ucmpls_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        HDR_WORDS_M1f, &tmpval);
    entry->hdr_words_m1 = tmpval & 15;
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART1r_field_get(unit, &regval, 
        LEN0f, &tmpval);
    entry->len0 = tmpval & 63;
    soc_CB_IPP_PGT_IA_RDATA_PART1r_field_get(unit, &regval, 
        PROTO1f, &tmpval);
    entry->proto1 = tmpval & 255;
    soc_CB_IPP_PGT_IA_RDATA_PART1r_field_get(unit, &regval, 
        PROTO0f, &tmpval);
    entry->proto0 = tmpval & 255;
    soc_CB_IPP_PGT_IA_RDATA_PART1r_field_get(unit, &regval, 
        LEN1f, &tmpval);
    entry->len1 = tmpval & 63;
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART2 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ARB4f, &tmpval);
    entry->arb4 = tmpval & 3;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ARB1f, &tmpval);
    entry->arb1 = tmpval & 3;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ARB7f, &tmpval);
    entry->arb7 = tmpval & 3;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ARB3f, &tmpval);
    entry->arb3 = tmpval & 3;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        SRC2f, &tmpval);
    entry->src2 = tmpval & 15;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ARB2f, &tmpval);
    entry->arb2 = tmpval & 3;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        SRC0f, &tmpval);
    entry->src0 = tmpval & 15;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        SRC1f, &tmpval);
    entry->src1 = tmpval & 15;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ARB0f, &tmpval);
    entry->arb0 = tmpval & 3;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ARB6f, &tmpval);
    entry->arb6 = tmpval & 3;
    soc_CB_IPP_PGT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ARB5f, &tmpval);
    entry->arb5 = tmpval & 3;
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART3 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART3r_field_get(unit, &regval, 
        PRI_BASE0f, &tmpval);
    entry->pri_base0 = tmpval & 511;
    soc_CB_IPP_PGT_IA_RDATA_PART3r_field_get(unit, &regval, 
        DEFAULT_TCf, &tmpval);
    entry->default_tc = tmpval & 7;
    soc_CB_IPP_PGT_IA_RDATA_PART3r_field_get(unit, &regval, 
        DEFAULT_DPf, &tmpval);
    entry->default_dp = tmpval & 3;
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART4 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART4r_field_get(unit, &regval, 
        PRI_BASE1f, &tmpval);
    entry->pri_base1 = tmpval & 511;
    soc_CB_IPP_PGT_IA_RDATA_PART4r_field_get(unit, &regval, 
        PRI_BASE2f, &tmpval);
    entry->pri_base2 = tmpval & 511;
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART5 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART5r_field_get(unit, &regval, 
        FCD3f, &tmpval);
    entry->fcd3 = tmpval & 7;
    soc_CB_IPP_PGT_IA_RDATA_PART5r_field_get(unit, &regval, 
        FCD4f, &tmpval);
    entry->fcd4 = tmpval & 7;
    soc_CB_IPP_PGT_IA_RDATA_PART5r_field_get(unit, &regval, 
        FCD2f, &tmpval);
    entry->fcd2 = tmpval & 7;
    soc_CB_IPP_PGT_IA_RDATA_PART5r_field_get(unit, &regval, 
        FCD1f, &tmpval);
    entry->fcd1 = tmpval & 7;
    soc_CB_IPP_PGT_IA_RDATA_PART5r_field_get(unit, &regval, 
        FCD5f, &tmpval);
    entry->fcd5 = tmpval & 7;
    soc_CB_IPP_PGT_IA_RDATA_PART5r_field_get(unit, &regval, 
        FCD6f, &tmpval);
    entry->fcd6 = tmpval & 7;
    soc_CB_IPP_PGT_IA_RDATA_PART5r_field_get(unit, &regval, 
        FCD7f, &tmpval);
    entry->fcd7 = tmpval & 7;
    soc_CB_IPP_PGT_IA_RDATA_PART5r_field_get(unit, &regval, 
        FCD0f, &tmpval);
    entry->fcd0 = tmpval & 7;
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART6 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART6r_field_get(unit, &regval, 
        MIRRORf, &tmpval);
    entry->mirror = tmpval & 63;
    soc_CB_IPP_PGT_IA_RDATA_PART6r_field_get(unit, &regval, 
        PEPPERf, &tmpval);
    entry->pepper = tmpval & 4095;
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART7r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART7 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART7r_field_get(unit, &regval, 
        VID_SRCf, &tmpval);
    entry->vid_src = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART7r_field_get(unit, &regval, 
        DEFAULT_VIDf, &tmpval);
    entry->default_vid = tmpval & 4095;
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART8r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART8 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART8r_field_get(unit, &regval, 
        DEFAULT_SLIf, &tmpval);
    entry->default_sli = tmpval & 262143;
    soc_CB_IPP_PGT_IA_RDATA_PART8r_field_get(unit, &regval, 
        DEFAULT_SLICIDf, &tmpval);
    entry->default_slicid = tmpval & 255;
    rc = REG_READ_CB_IPP_PGT_IA_RDATA_PART9r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_get: Failed register "
                "CB_IPP_PGT_IA_WDATA_PART9 read\n"));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    soc_CB_IPP_PGT_IA_RDATA_PART9r_field_get(unit, &regval, 
        DFP_ENf, &tmpval);
    entry->dfp_en = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART9r_field_get(unit, &regval, 
        DROP_ULFf, &tmpval);
    entry->drop_ulf = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART9r_field_get(unit, &regval, 
        IPP_METER_SETS_DPf, &tmpval);
    entry->ipp_meter_sets_dp = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART9r_field_get(unit, &regval, 
        SPGIDf, &tmpval);
    entry->spgid = tmpval & 31;
    soc_CB_IPP_PGT_IA_RDATA_PART9r_field_get(unit, &regval, 
        DROP_SLFf, &tmpval);
    entry->drop_slf = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART9r_field_get(unit, &regval, 
        DROP_MLFf, &tmpval);
    entry->drop_mlf = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART9r_field_get(unit, &regval, 
        DROP_BCASTf, &tmpval);
    entry->drop_bcast = tmpval & 1;
    soc_CB_IPP_PGT_IA_RDATA_PART9r_field_get(unit, &regval, 
        RP_EXTRAf, &tmpval);
    entry->rp_extra = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PGT_ID) {
        sal_printf("PPPOE_ENf = 0x%x\n", entry->pppoe_en);
        sal_printf("ITAG_ENf = 0x%x\n", entry->itag_en);
        sal_printf("TAG_PARSE_ENf = 0x%x\n", entry->tag_parse_en);
        sal_printf("IPV4_ENf = 0x%x\n", entry->ipv4_en);
        sal_printf("SLIC_MAP_ENf = 0x%x\n", entry->slic_map_en);
        sal_printf("CTAG_ENf = 0x%x\n", entry->ctag_en);
        sal_printf("SOFT_TAG_ENf = 0x%x\n", entry->soft_tag_en);
        sal_printf("MCMPLS_ENf = 0x%x\n", entry->mcmpls_en);
        sal_printf("METADATA_LENf = 0x%x\n", entry->metadata_len);
        sal_printf("LLC_ENf = 0x%x\n", entry->llc_en);
        sal_printf("PTP_ENf = 0x%x\n", entry->ptp_en);
        sal_printf("ETAG_ENf = 0x%x\n", entry->etag_en);
        sal_printf("STAG_ENf = 0x%x\n", entry->stag_en);
        sal_printf("IPV6_ENf = 0x%x\n", entry->ipv6_en);
        sal_printf("TLV_PARSE_ENf = 0x%x\n", entry->tlv_parse_en);
        sal_printf("ARP_ENf = 0x%x\n", entry->arp_en);
        sal_printf("UCMPLS_ENf = 0x%x\n", entry->ucmpls_en);
        sal_printf("HDR_WORDS_M1f = 0x%x\n", entry->hdr_words_m1);
        sal_printf("LEN0f = 0x%x\n", entry->len0);
        sal_printf("PROTO1f = 0x%x\n", entry->proto1);
        sal_printf("PROTO0f = 0x%x\n", entry->proto0);
        sal_printf("LEN1f = 0x%x\n", entry->len1);
        sal_printf("ARB4f = 0x%x\n", entry->arb4);
        sal_printf("ARB1f = 0x%x\n", entry->arb1);
        sal_printf("ARB7f = 0x%x\n", entry->arb7);
        sal_printf("ARB3f = 0x%x\n", entry->arb3);
        sal_printf("SRC2f = 0x%x\n", entry->src2);
        sal_printf("ARB2f = 0x%x\n", entry->arb2);
        sal_printf("SRC0f = 0x%x\n", entry->src0);
        sal_printf("SRC1f = 0x%x\n", entry->src1);
        sal_printf("ARB0f = 0x%x\n", entry->arb0);
        sal_printf("ARB6f = 0x%x\n", entry->arb6);
        sal_printf("ARB5f = 0x%x\n", entry->arb5);
        sal_printf("PRI_BASE0f = 0x%x\n", entry->pri_base0);
        sal_printf("DEFAULT_TCf = 0x%x\n", entry->default_tc);
        sal_printf("DEFAULT_DPf = 0x%x\n", entry->default_dp);
        sal_printf("PRI_BASE1f = 0x%x\n", entry->pri_base1);
        sal_printf("PRI_BASE2f = 0x%x\n", entry->pri_base2);
        sal_printf("FCD3f = 0x%x\n", entry->fcd3);
        sal_printf("FCD4f = 0x%x\n", entry->fcd4);
        sal_printf("FCD2f = 0x%x\n", entry->fcd2);
        sal_printf("FCD1f = 0x%x\n", entry->fcd1);
        sal_printf("FCD5f = 0x%x\n", entry->fcd5);
        sal_printf("FCD6f = 0x%x\n", entry->fcd6);
        sal_printf("FCD7f = 0x%x\n", entry->fcd7);
        sal_printf("FCD0f = 0x%x\n", entry->fcd0);
        sal_printf("MIRRORf = 0x%x\n", entry->mirror);
        sal_printf("PEPPERf = 0x%x\n", entry->pepper);
        sal_printf("VID_SRCf = 0x%x\n", entry->vid_src);
        sal_printf("DEFAULT_VIDf = 0x%x\n", entry->default_vid);
        sal_printf("DEFAULT_SLIf = 0x%x\n", entry->default_sli);
        sal_printf("DEFAULT_SLICIDf = 0x%x\n", entry->default_slicid);
        sal_printf("DFP_ENf = 0x%x\n", entry->dfp_en);
        sal_printf("DROP_ULFf = 0x%x\n", entry->drop_ulf);
        sal_printf("IPP_METER_SETS_DPf = 0x%x\n", entry->ipp_meter_sets_dp);
        sal_printf("SPGIDf = 0x%x\n", entry->spgid);
        sal_printf("DROP_SLFf = 0x%x\n", entry->drop_slf);
        sal_printf("DROP_MLFf = 0x%x\n", entry->drop_mlf);
        sal_printf("DROP_BCASTf = 0x%x\n", entry->drop_bcast);
        sal_printf("RP_EXTRAf = 0x%x\n", entry->rp_extra);
    }
    sal_mutex_give(pgt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pmipage_get
 * @par Description:
 *      Perform a read on the pmipage table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pmipage_get(int unit, int index, pmipage_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pmipage_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PMIPAGE_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_get: Failed reading table %s index %d rc %d\n",
                "pmipage", index, rc));
        sal_mutex_give(pmipage_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PMI_PMIPAGE_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_get: Failed register "
                "CB_PMI_PMIPAGE_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pmipage_mutex);
        return rc;
    }
    soc_CB_PMI_PMIPAGE_IA_RDATA_PART0r_field_get(unit, &regval, 
        PHYPAGEVLDf, &tmpval);
    entry->phypagevld = tmpval & 1;
    soc_CB_PMI_PMIPAGE_IA_RDATA_PART0r_field_get(unit, &regval, 
        PHYPAGEf, &tmpval);
    entry->phypage = tmpval & 8191;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PMIPAGE_ID) {
        sal_printf("PHYPAGEVLDf = 0x%x\n", entry->phypagevld);
        sal_printf("PHYPAGEf = 0x%x\n", entry->phypage);
    }
    sal_mutex_give(pmipage_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_gfcd_config_get
 * @par Description:
 *      Perform a read on the gfcd_config table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_config_get(int unit, int index, gfcd_config_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(gfcd_config_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CONFIG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_get: Failed reading table %s index %d rc %d\n",
                "gfcd_config", index, rc));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_GFCD_CONFIG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_get: Failed register "
                "CB_BMU_GFCD_CONFIG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART0r_field_get(unit, &regval, 
        THRESH1f, &tmpval);
    entry->thresh1 = tmpval & 8191;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART0r_field_get(unit, &regval, 
        THRESH0f, &tmpval);
    entry->thresh0 = tmpval & 8191;
    rc = REG_READ_CB_BMU_GFCD_CONFIG_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_get: Failed register "
                "CB_BMU_GFCD_CONFIG_IA_WDATA_PART1 read\n"));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART1r_field_get(unit, &regval, 
        THRESH3f, &tmpval);
    entry->thresh3 = tmpval & 8191;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART1r_field_get(unit, &regval, 
        THRESH2f, &tmpval);
    entry->thresh2 = tmpval & 8191;
    rc = REG_READ_CB_BMU_GFCD_CONFIG_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_get: Failed register "
                "CB_BMU_GFCD_CONFIG_IA_WDATA_PART2 read\n"));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART2r_field_get(unit, &regval, 
        COUNTER_ENABLEf, &tmpval);
    entry->counter_enable = tmpval & 1;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART2r_field_get(unit, &regval, 
        GFC_ENABLEf, &tmpval);
    entry->gfc_enable = tmpval & 1;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART2r_field_get(unit, &regval, 
        HYSTERESISf, &tmpval);
    entry->hysteresis = tmpval & 8191;
    rc = REG_READ_CB_BMU_GFCD_CONFIG_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_get: Failed register "
                "CB_BMU_GFCD_CONFIG_IA_WDATA_PART3 read\n"));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART3r_field_get(unit, &regval, 
        TC_PP_BMP_3f, &tmpval);
    entry->tc_pp_bmp_3 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART3r_field_get(unit, &regval, 
        TC_PP_BMP_2f, &tmpval);
    entry->tc_pp_bmp_2 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART3r_field_get(unit, &regval, 
        TC_PP_BMP_1f, &tmpval);
    entry->tc_pp_bmp_1 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART3r_field_get(unit, &regval, 
        TC_PP_BMP_0f, &tmpval);
    entry->tc_pp_bmp_0 = tmpval & 255;
    rc = REG_READ_CB_BMU_GFCD_CONFIG_IA_RDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_get: Failed register "
                "CB_BMU_GFCD_CONFIG_IA_WDATA_PART4 read\n"));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART4r_field_get(unit, &regval, 
        TC_PP_BMP_5f, &tmpval);
    entry->tc_pp_bmp_5 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART4r_field_get(unit, &regval, 
        TC_PP_BMP_7f, &tmpval);
    entry->tc_pp_bmp_7 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART4r_field_get(unit, &regval, 
        TC_PP_BMP_4f, &tmpval);
    entry->tc_pp_bmp_4 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART4r_field_get(unit, &regval, 
        TC_PP_BMP_6f, &tmpval);
    entry->tc_pp_bmp_6 = tmpval & 255;
    rc = REG_READ_CB_BMU_GFCD_CONFIG_IA_RDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_get: Failed register "
                "CB_BMU_GFCD_CONFIG_IA_WDATA_PART5 read\n"));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART5r_field_get(unit, &regval, 
        TC_PP_BMP_9f, &tmpval);
    entry->tc_pp_bmp_9 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART5r_field_get(unit, &regval, 
        TC_PP_BMP_8f, &tmpval);
    entry->tc_pp_bmp_8 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART5r_field_get(unit, &regval, 
        TC_PP_BMP_10f, &tmpval);
    entry->tc_pp_bmp_10 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART5r_field_get(unit, &regval, 
        TC_PP_BMP_11f, &tmpval);
    entry->tc_pp_bmp_11 = tmpval & 255;
    rc = REG_READ_CB_BMU_GFCD_CONFIG_IA_RDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_get: Failed register "
                "CB_BMU_GFCD_CONFIG_IA_WDATA_PART6 read\n"));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART6r_field_get(unit, &regval, 
        TC_PP_BMP_14f, &tmpval);
    entry->tc_pp_bmp_14 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART6r_field_get(unit, &regval, 
        TC_PP_BMP_15f, &tmpval);
    entry->tc_pp_bmp_15 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART6r_field_get(unit, &regval, 
        TC_PP_BMP_13f, &tmpval);
    entry->tc_pp_bmp_13 = tmpval & 255;
    soc_CB_BMU_GFCD_CONFIG_IA_RDATA_PART6r_field_get(unit, &regval, 
        TC_PP_BMP_12f, &tmpval);
    entry->tc_pp_bmp_12 = tmpval & 255;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_GFCD_CONFIG_ID) {
        sal_printf("THRESH1f = 0x%x\n", entry->thresh1);
        sal_printf("THRESH0f = 0x%x\n", entry->thresh0);
        sal_printf("THRESH3f = 0x%x\n", entry->thresh3);
        sal_printf("THRESH2f = 0x%x\n", entry->thresh2);
        sal_printf("COUNTER_ENABLEf = 0x%x\n", entry->counter_enable);
        sal_printf("GFC_ENABLEf = 0x%x\n", entry->gfc_enable);
        sal_printf("HYSTERESISf = 0x%x\n", entry->hysteresis);
        sal_printf("TC_PP_BMP_3f = 0x%x\n", entry->tc_pp_bmp_3);
        sal_printf("TC_PP_BMP_2f = 0x%x\n", entry->tc_pp_bmp_2);
        sal_printf("TC_PP_BMP_1f = 0x%x\n", entry->tc_pp_bmp_1);
        sal_printf("TC_PP_BMP_0f = 0x%x\n", entry->tc_pp_bmp_0);
        sal_printf("TC_PP_BMP_5f = 0x%x\n", entry->tc_pp_bmp_5);
        sal_printf("TC_PP_BMP_7f = 0x%x\n", entry->tc_pp_bmp_7);
        sal_printf("TC_PP_BMP_4f = 0x%x\n", entry->tc_pp_bmp_4);
        sal_printf("TC_PP_BMP_6f = 0x%x\n", entry->tc_pp_bmp_6);
        sal_printf("TC_PP_BMP_9f = 0x%x\n", entry->tc_pp_bmp_9);
        sal_printf("TC_PP_BMP_8f = 0x%x\n", entry->tc_pp_bmp_8);
        sal_printf("TC_PP_BMP_10f = 0x%x\n", entry->tc_pp_bmp_10);
        sal_printf("TC_PP_BMP_11f = 0x%x\n", entry->tc_pp_bmp_11);
        sal_printf("TC_PP_BMP_14f = 0x%x\n", entry->tc_pp_bmp_14);
        sal_printf("TC_PP_BMP_15f = 0x%x\n", entry->tc_pp_bmp_15);
        sal_printf("TC_PP_BMP_13f = 0x%x\n", entry->tc_pp_bmp_13);
        sal_printf("TC_PP_BMP_12f = 0x%x\n", entry->tc_pp_bmp_12);
    }
    sal_mutex_give(gfcd_config_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_apt_get
 * @par Description:
 *      Perform a read on the apt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_apt_get(int unit, int index, apt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(apt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_APT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_get: Failed reading table %s index %d rc %d\n",
                "apt", index, rc));
        sal_mutex_give(apt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_APT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_get: Failed register "
                "CB_PQM_APT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(apt_mutex);
        return rc;
    }
    soc_CB_PQM_APT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DROP_THRESHf, &tmpval);
    entry->drop_thresh = tmpval & 8191;
    rc = REG_READ_CB_PQM_APT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_get: Failed register "
                "CB_PQM_APT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(apt_mutex);
        return rc;
    }
    soc_CB_PQM_APT_IA_RDATA_PART1r_field_get(unit, &regval, 
        WRED_Mf, &tmpval);
    entry->wred_m = tmpval & 255;
    rc = REG_READ_CB_PQM_APT_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_get: Failed register "
                "CB_PQM_APT_IA_WDATA_PART2 read\n"));
        sal_mutex_give(apt_mutex);
        return rc;
    }
    soc_CB_PQM_APT_IA_RDATA_PART2r_field_get(unit, &regval, 
        WRED_Cf, &tmpval);
    entry->wred_c = tmpval & 16383;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_APT_ID) {
        sal_printf("DROP_THRESHf = 0x%x\n", entry->drop_thresh);
        sal_printf("WRED_Mf = 0x%x\n", entry->wred_m);
        sal_printf("WRED_Cf = 0x%x\n", entry->wred_c);
    }
    sal_mutex_give(apt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_gfcd_cntr_get
 * @par Description:
 *      Perform a read on the gfcd_cntr table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_cntr_get(int unit, int index, gfcd_cntr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(gfcd_cntr_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CNTR_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_get: Failed reading table %s index %d rc %d\n",
                "gfcd_cntr", index, rc));
        sal_mutex_give(gfcd_cntr_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_GFCD_CNTR_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_get: Failed register "
                "CB_BMU_GFCD_CNTR_IA_WDATA_PART0 read\n"));
        sal_mutex_give(gfcd_cntr_mutex);
        return rc;
    }
    soc_CB_BMU_GFCD_CNTR_IA_RDATA_PART0r_field_get(unit, &regval, 
        PAGE_CNTf, &tmpval);
    entry->page_cnt = tmpval & 8191;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_GFCD_CNTR_ID) {
        sal_printf("PAGE_CNTf = 0x%x\n", entry->page_cnt);
    }
    sal_mutex_give(gfcd_cntr_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_spg_pp_bmp_config_get
 * @par Description:
 *      Perform a read on the spg_pp_bmp_config table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_spg_pp_bmp_config_get(int unit, int index, spg_pp_bmp_config_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(spg_pp_bmp_config_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_get: Failed reading table %s index %d rc %d\n",
                "spg_pp_bmp_config", index, rc));
        sal_mutex_give(spg_pp_bmp_config_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_SPG_PP_BMP_CONFIG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_get: Failed register "
                "CB_BMU_SPG_PP_BMP_CONFIG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(spg_pp_bmp_config_mutex);
        return rc;
    }
    soc_CB_BMU_SPG_PP_BMP_CONFIG_IA_RDATA_PART0r_field_get(unit, &regval, 
        SPG_PP_BMPf, &tmpval);
    entry->spg_pp_bmp = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID) {
        sal_printf("SPG_PP_BMPf = 0x%x\n", entry->spg_pp_bmp);
    }
    sal_mutex_give(spg_pp_bmp_config_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_dgt_get
 * @par Description:
 *      Perform a read on the dgt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_dgt_get(int unit, int index, dgt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(dgt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DGT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_get: Failed reading table %s index %d rc %d\n",
                "dgt", index, rc));
        sal_mutex_give(dgt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_DGT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_get: Failed register "
                "CB_PQM_DGT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(dgt_mutex);
        return rc;
    }
    soc_CB_PQM_DGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        LILT_TYPEf, &tmpval);
    entry->lilt_type = tmpval & 1;
    soc_CB_PQM_DGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        LILT_NDXf, &tmpval);
    entry->lilt_ndx = tmpval & 4095;
    rc = REG_READ_CB_PQM_DGT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_get: Failed register "
                "CB_PQM_DGT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(dgt_mutex);
        return rc;
    }
    soc_CB_PQM_DGT_IA_RDATA_PART1r_field_get(unit, &regval, 
        PGFOVf, &tmpval);
    entry->pgfov = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_DGT_ID) {
        sal_printf("LILT_TYPEf = 0x%x\n", entry->lilt_type);
        sal_printf("LILT_NDXf = 0x%x\n", entry->lilt_ndx);
        sal_printf("PGFOVf = 0x%x\n", entry->pgfov);
    }
    sal_mutex_give(dgt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_gspg2ig_get
 * @par Description:
 *      Perform a read on the gspg2ig table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_gspg2ig_get(int unit, int index, gspg2ig_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(gspg2ig_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GSPG2IG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_get: Failed reading table %s index %d rc %d\n",
                "gspg2ig", index, rc));
        sal_mutex_give(gspg2ig_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_GSPG2IG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_get: Failed register "
                "CB_IPP_GSPG2IG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(gspg2ig_mutex);
        return rc;
    }
    soc_CB_IPP_GSPG2IG_IA_RDATA_PART0r_field_get(unit, &regval, 
        IGf, &tmpval);
    entry->ig = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_GSPG2IG_ID) {
        sal_printf("IGf = 0x%x\n", entry->ig);
    }
    sal_mutex_give(gspg2ig_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_epp_calendar_get
 * @par Description:
 *      Perform a read on the epp_calendar table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_calendar_get(int unit, int index, epp_calendar_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(epp_calendar_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_CALENDAR_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_get: Failed reading table %s index %d rc %d\n",
                "epp_calendar", index, rc));
        sal_mutex_give(epp_calendar_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_EPP_EPP_CALENDAR_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_get: Failed register "
                "CB_EPP_EPP_CALENDAR_IA_WDATA_PART0 read\n"));
        sal_mutex_give(epp_calendar_mutex);
        return rc;
    }
    soc_CB_EPP_EPP_CALENDAR_IA_RDATA_PART0r_field_get(unit, &regval, 
        SLOT_PORTf, &tmpval);
    entry->slot_port = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_EPP_CALENDAR_ID) {
        sal_printf("SLOT_PORTf = 0x%x\n", entry->slot_port);
    }
    sal_mutex_give(epp_calendar_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ght_get
 * @par Description:
 *      Perform a read on the ght table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ght_get(int unit, int index, ght_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ght_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_get: Failed reading table %s index %d rc %d\n",
                "ght", index, rc));
        sal_mutex_give(ght_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ITM_GHT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_get: Failed register "
                "CB_ITM_GHT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ght_mutex);
        return rc;
    }
    soc_CB_ITM_GHT_IA_RDATA_PART0r_field_get(unit, &regval, 
        KEY_31_0f, &entry->key_31_0);
    rc = REG_READ_CB_ITM_GHT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_get: Failed register "
                "CB_ITM_GHT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(ght_mutex);
        return rc;
    }
    soc_CB_ITM_GHT_IA_RDATA_PART1r_field_get(unit, &regval, 
        KEY_63_32f, &entry->key_63_32);
    rc = REG_READ_CB_ITM_GHT_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_get: Failed register "
                "CB_ITM_GHT_IA_WDATA_PART2 read\n"));
        sal_mutex_give(ght_mutex);
        return rc;
    }
    soc_CB_ITM_GHT_IA_RDATA_PART2r_field_get(unit, &regval, 
        KEY_95_64f, &entry->key_95_64);
    rc = REG_READ_CB_ITM_GHT_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_get: Failed register "
                "CB_ITM_GHT_IA_WDATA_PART3 read\n"));
        sal_mutex_give(ght_mutex);
        return rc;
    }
    soc_CB_ITM_GHT_IA_RDATA_PART3r_field_get(unit, &regval, 
        N_OR_VSIf, &tmpval);
    entry->n_or_vsi = tmpval & 4095;
    soc_CB_ITM_GHT_IA_RDATA_PART3r_field_get(unit, &regval, 
        VALIDf, &tmpval);
    entry->valid = tmpval & 1;
    soc_CB_ITM_GHT_IA_RDATA_PART3r_field_get(unit, &regval, 
        KEY_113_96f, &tmpval);
    entry->key_113_96 = tmpval & 262143;
    soc_CB_ITM_GHT_IA_RDATA_PART3r_field_get(unit, &regval, 
        LI_TYPEf, &tmpval);
    entry->li_type = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_GHT_ID) {
        sal_printf("KEY_31_0f = 0x%x\n", entry->key_31_0);
        sal_printf("KEY_63_32f = 0x%x\n", entry->key_63_32);
        sal_printf("KEY_95_64f = 0x%x\n", entry->key_95_64);
        sal_printf("N_OR_VSIf = 0x%x\n", entry->n_or_vsi);
        sal_printf("VALIDf = 0x%x\n", entry->valid);
        sal_printf("KEY_113_96f = 0x%x\n", entry->key_113_96);
        sal_printf("LI_TYPEf = 0x%x\n", entry->li_type);
    }
    sal_mutex_give(ght_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_lin2vsi_get
 * @par Description:
 *      Perform a read on the lin2vsi table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_lin2vsi_get(int unit, int index, lin2vsi_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lin2vsi_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LIN2VSI_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_get: Failed reading table %s index %d rc %d\n",
                "lin2vsi", index, rc));
        sal_mutex_give(lin2vsi_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_LIN2VSI_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_get: Failed register "
                "CB_IPP_LIN2VSI_IA_WDATA_PART0 read\n"));
        sal_mutex_give(lin2vsi_mutex);
        return rc;
    }
    soc_CB_IPP_LIN2VSI_IA_RDATA_PART0r_field_get(unit, &regval, 
        TCf, &tmpval);
    entry->tc = tmpval & 7;
    soc_CB_IPP_LIN2VSI_IA_RDATA_PART0r_field_get(unit, &regval, 
        DPf, &tmpval);
    entry->dp = tmpval & 3;
    soc_CB_IPP_LIN2VSI_IA_RDATA_PART0r_field_get(unit, &regval, 
        USE_TCf, &tmpval);
    entry->use_tc = tmpval & 1;
    soc_CB_IPP_LIN2VSI_IA_RDATA_PART0r_field_get(unit, &regval, 
        USE_DPf, &tmpval);
    entry->use_dp = tmpval & 1;
    soc_CB_IPP_LIN2VSI_IA_RDATA_PART0r_field_get(unit, &regval, 
        VSIf, &tmpval);
    entry->vsi = tmpval & 4095;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_LIN2VSI_ID) {
        sal_printf("TCf = 0x%x\n", entry->tc);
        sal_printf("DPf = 0x%x\n", entry->dp);
        sal_printf("USE_TCf = 0x%x\n", entry->use_tc);
        sal_printf("USE_DPf = 0x%x\n", entry->use_dp);
        sal_printf("VSIf = 0x%x\n", entry->vsi);
    }
    sal_mutex_give(lin2vsi_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_cfp_profile_get
 * @par Description:
 *      Perform a read on the cfp_profile table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_profile_get(int unit, int index, cfp_profile_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_profile_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PROFILE_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_get: Failed reading table %s index %d rc %d\n",
                "cfp_profile", index, rc));
        sal_mutex_give(cfp_profile_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_PROFILE_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_get: Failed register "
                "CB_CFP_PROFILE_IA_WDATA_PART0 read\n"));
        sal_mutex_give(cfp_profile_mutex);
        return rc;
    }
    soc_CB_CFP_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CBS_EXPf, &tmpval);
    entry->cbs_exp = tmpval & 31;
    soc_CB_CFP_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CBS_MANTISSAf, &tmpval);
    entry->cbs_mantissa = tmpval & 127;
    soc_CB_CFP_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CIR_MANTISSAf, &tmpval);
    entry->cir_mantissa = tmpval & 2047;
    soc_CB_CFP_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CIR_EXPf, &tmpval);
    entry->cir_exp = tmpval & 31;
    rc = REG_READ_CB_CFP_PROFILE_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_get: Failed register "
                "CB_CFP_PROFILE_IA_WDATA_PART1 read\n"));
        sal_mutex_give(cfp_profile_mutex);
        return rc;
    }
    soc_CB_CFP_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EIR_EXPf, &tmpval);
    entry->eir_exp = tmpval & 31;
    soc_CB_CFP_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EBS_EXPf, &tmpval);
    entry->ebs_exp = tmpval & 31;
    soc_CB_CFP_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EIR_MANTISSAf, &tmpval);
    entry->eir_mantissa = tmpval & 2047;
    soc_CB_CFP_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EBS_MANTISSAf, &tmpval);
    entry->ebs_mantissa = tmpval & 127;
    rc = REG_READ_CB_CFP_PROFILE_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_get: Failed register "
                "CB_CFP_PROFILE_IA_WDATA_PART2 read\n"));
        sal_mutex_give(cfp_profile_mutex);
        return rc;
    }
    soc_CB_CFP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        DROP_ON_REDf, &tmpval);
    entry->drop_on_red = tmpval & 1;
    soc_CB_CFP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        PKT_MODEf, &tmpval);
    entry->pkt_mode = tmpval & 1;
    soc_CB_CFP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BKTC_STRICTf, &tmpval);
    entry->bktc_strict = tmpval & 1;
    soc_CB_CFP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BKTE_STRICTf, &tmpval);
    entry->bkte_strict = tmpval & 1;
    soc_CB_CFP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        CFf, &tmpval);
    entry->cf = tmpval & 1;
    soc_CB_CFP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        RFC2698f, &tmpval);
    entry->rfc2698 = tmpval & 1;
    soc_CB_CFP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BLINDf, &tmpval);
    entry->blind = tmpval & 1;
    soc_CB_CFP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        AVB_MODEf, &tmpval);
    entry->avb_mode = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_CFP_PROFILE_ID) {
        sal_printf("CBS_EXPf = 0x%x\n", entry->cbs_exp);
        sal_printf("CBS_MANTISSAf = 0x%x\n", entry->cbs_mantissa);
        sal_printf("CIR_MANTISSAf = 0x%x\n", entry->cir_mantissa);
        sal_printf("CIR_EXPf = 0x%x\n", entry->cir_exp);
        sal_printf("EIR_EXPf = 0x%x\n", entry->eir_exp);
        sal_printf("EBS_EXPf = 0x%x\n", entry->ebs_exp);
        sal_printf("EIR_MANTISSAf = 0x%x\n", entry->eir_mantissa);
        sal_printf("EBS_MANTISSAf = 0x%x\n", entry->ebs_mantissa);
        sal_printf("DROP_ON_REDf = 0x%x\n", entry->drop_on_red);
        sal_printf("PKT_MODEf = 0x%x\n", entry->pkt_mode);
        sal_printf("BKTC_STRICTf = 0x%x\n", entry->bktc_strict);
        sal_printf("BKTE_STRICTf = 0x%x\n", entry->bkte_strict);
        sal_printf("CFf = 0x%x\n", entry->cf);
        sal_printf("RFC2698f = 0x%x\n", entry->rfc2698);
        sal_printf("BLINDf = 0x%x\n", entry->blind);
        sal_printf("AVB_MODEf = 0x%x\n", entry->avb_mode);
    }
    sal_mutex_give(cfp_profile_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_cfp_bucket_get
 * @par Description:
 *      Perform a read on the cfp_bucket table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_bucket_get(int unit, int index, cfp_bucket_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_bucket_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_BUCKET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_get: Failed reading table %s index %d rc %d\n",
                "cfp_bucket", index, rc));
        sal_mutex_give(cfp_bucket_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_BUCKET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_get: Failed register "
                "CB_CFP_BUCKET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(cfp_bucket_mutex);
        return rc;
    }
    soc_CB_CFP_BUCKET_IA_RDATA_PART0r_field_get(unit, &regval, 
        BKTEf, &tmpval);
    entry->bkte = tmpval & 134217727;
    rc = REG_READ_CB_CFP_BUCKET_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_get: Failed register "
                "CB_CFP_BUCKET_IA_WDATA_PART1 read\n"));
        sal_mutex_give(cfp_bucket_mutex);
        return rc;
    }
    soc_CB_CFP_BUCKET_IA_RDATA_PART1r_field_get(unit, &regval, 
        BKTCf, &tmpval);
    entry->bktc = tmpval & 134217727;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_CFP_BUCKET_ID) {
        sal_printf("BKTEf = 0x%x\n", entry->bkte);
        sal_printf("BKTCf = 0x%x\n", entry->bktc);
    }
    sal_mutex_give(cfp_bucket_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_calendar_get
 * @par Description:
 *      Perform a read on the calendar table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_calendar_get(int unit, int index, calendar_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(calendar_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CALENDAR_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_get: Failed reading table %s index %d rc %d\n",
                "calendar", index, rc));
        sal_mutex_give(calendar_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQS_CALENDAR_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_get: Failed register "
                "CB_PQS_CALENDAR_IA_WDATA_PART0 read\n"));
        sal_mutex_give(calendar_mutex);
        return rc;
    }
    soc_CB_PQS_CALENDAR_IA_RDATA_PART0r_field_get(unit, &regval, 
        SLOT_PORT_SEL_ENf, &tmpval);
    entry->slot_port_sel_en = tmpval & 1;
    soc_CB_PQS_CALENDAR_IA_RDATA_PART0r_field_get(unit, &regval, 
        SLOT_PORTf, &tmpval);
    entry->slot_port = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_CALENDAR_ID) {
        sal_printf("SLOT_PORT_SEL_ENf = 0x%x\n", entry->slot_port_sel_en);
        sal_printf("SLOT_PORTf = 0x%x\n", entry->slot_port);
    }
    sal_mutex_give(calendar_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pg2lpg_get
 * @par Description:
 *      Perform a read on the pg2lpg table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pg2lpg_get(int unit, int index, pg2lpg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pg2lpg_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PG2LPG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_get: Failed reading table %s index %d rc %d\n",
                "pg2lpg", index, rc));
        sal_mutex_give(pg2lpg_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_PG2LPG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_get: Failed register "
                "CB_PQM_PG2LPG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pg2lpg_mutex);
        return rc;
    }
    soc_CB_PQM_PG2LPG_IA_RDATA_PART0r_field_get(unit, &regval, 
        LPGf, &tmpval);
    entry->lpg = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PG2LPG_ID) {
        sal_printf("LPGf = 0x%x\n", entry->lpg);
    }
    sal_mutex_give(pg2lpg_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_arlfm_get
 * @par Description:
 *      Perform a read on the arlfm table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm_get(int unit, int index, arlfm_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(arlfm_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_get: Failed reading table %s index %d rc %d\n",
                "arlfm", index, rc));
        sal_mutex_give(arlfm_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ITM_ARLFM_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_get: Failed register "
                "CB_ITM_ARLFM_IA_WDATA_PART0 read\n"));
        sal_mutex_give(arlfm_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM_IA_RDATA_PART0r_field_get(unit, &regval, 
        MAC_LOf, &entry->mac_lo);
    rc = REG_READ_CB_ITM_ARLFM_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_get: Failed register "
                "CB_ITM_ARLFM_IA_WDATA_PART1 read\n"));
        sal_mutex_give(arlfm_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM_IA_RDATA_PART1r_field_get(unit, &regval, 
        FIDf, &tmpval);
    entry->fid = tmpval & 4095;
    soc_CB_ITM_ARLFM_IA_RDATA_PART1r_field_get(unit, &regval, 
        UPD_CTRLf, &tmpval);
    entry->upd_ctrl = tmpval & 3;
    soc_CB_ITM_ARLFM_IA_RDATA_PART1r_field_get(unit, &regval, 
        MAC_HIf, &tmpval);
    entry->mac_hi = tmpval & 65535;
    soc_CB_ITM_ARLFM_IA_RDATA_PART1r_field_get(unit, &regval, 
        FWD_CTRLf, &tmpval);
    entry->fwd_ctrl = tmpval & 3;
    rc = REG_READ_CB_ITM_ARLFM_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_get: Failed register "
                "CB_ITM_ARLFM_IA_WDATA_PART2 read\n"));
        sal_mutex_give(arlfm_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM_IA_RDATA_PART2r_field_get(unit, &regval, 
        VALIDf, &tmpval);
    entry->valid = tmpval & 3;
    soc_CB_ITM_ARLFM_IA_RDATA_PART2r_field_get(unit, &regval, 
        DSTf, &tmpval);
    entry->dst = tmpval & 2047;
    soc_CB_ITM_ARLFM_IA_RDATA_PART2r_field_get(unit, &regval, 
        DST_TYPEf, &tmpval);
    entry->dst_type = tmpval & 3;
    soc_CB_ITM_ARLFM_IA_RDATA_PART2r_field_get(unit, &regval, 
        HITf, &tmpval);
    entry->hit = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ARLFM_ID) {
        sal_printf("MAC_LOf = 0x%x\n", entry->mac_lo);
        sal_printf("FIDf = 0x%x\n", entry->fid);
        sal_printf("UPD_CTRLf = 0x%x\n", entry->upd_ctrl);
        sal_printf("MAC_HIf = 0x%x\n", entry->mac_hi);
        sal_printf("FWD_CTRLf = 0x%x\n", entry->fwd_ctrl);
        sal_printf("VALIDf = 0x%x\n", entry->valid);
        sal_printf("DSTf = 0x%x\n", entry->dst);
        sal_printf("DST_TYPEf = 0x%x\n", entry->dst_type);
        sal_printf("HITf = 0x%x\n", entry->hit);
    }
    sal_mutex_give(arlfm_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_arlfm0_get
 * @par Description:
 *      Perform a read on the arlfm0 table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm0_get(int unit, int index, arlfm0_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(arlfm0_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM0_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_get: Failed reading table %s index %d rc %d\n",
                "arlfm0", index, rc));
        sal_mutex_give(arlfm0_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ITM_ARLFM0_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_get: Failed register "
                "CB_ITM_ARLFM0_IA_WDATA_PART0 read\n"));
        sal_mutex_give(arlfm0_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM0_IA_RDATA_PART0r_field_get(unit, &regval, 
        VALIDf, &tmpval);
    entry->valid = tmpval & 3;
    soc_CB_ITM_ARLFM0_IA_RDATA_PART0r_field_get(unit, &regval, 
        DSTf, &tmpval);
    entry->dst = tmpval & 2047;
    soc_CB_ITM_ARLFM0_IA_RDATA_PART0r_field_get(unit, &regval, 
        DST_TYPEf, &tmpval);
    entry->dst_type = tmpval & 3;
    soc_CB_ITM_ARLFM0_IA_RDATA_PART0r_field_get(unit, &regval, 
        HITf, &tmpval);
    entry->hit = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ARLFM0_ID) {
        sal_printf("VALIDf = 0x%x\n", entry->valid);
        sal_printf("DSTf = 0x%x\n", entry->dst);
        sal_printf("DST_TYPEf = 0x%x\n", entry->dst_type);
        sal_printf("HITf = 0x%x\n", entry->hit);
    }
    sal_mutex_give(arlfm0_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ipp_bucket_get
 * @par Description:
 *      Perform a read on the ipp_bucket table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_bucket_get(int unit, int index, ipp_bucket_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_bucket_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_BUCKET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_get: Failed reading table %s index %d rc %d\n",
                "ipp_bucket", index, rc));
        sal_mutex_give(ipp_bucket_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_BUCKET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_get: Failed register "
                "CB_IPP_BUCKET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ipp_bucket_mutex);
        return rc;
    }
    soc_CB_IPP_BUCKET_IA_RDATA_PART0r_field_get(unit, &regval, 
        BKTEf, &tmpval);
    entry->bkte = tmpval & 134217727;
    rc = REG_READ_CB_IPP_BUCKET_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_get: Failed register "
                "CB_IPP_BUCKET_IA_WDATA_PART1 read\n"));
        sal_mutex_give(ipp_bucket_mutex);
        return rc;
    }
    soc_CB_IPP_BUCKET_IA_RDATA_PART1r_field_get(unit, &regval, 
        BKTCf, &tmpval);
    entry->bktc = tmpval & 134217727;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_IPP_BUCKET_ID) {
        sal_printf("BKTEf = 0x%x\n", entry->bkte);
        sal_printf("BKTCf = 0x%x\n", entry->bktc);
    }
    sal_mutex_give(ipp_bucket_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_fcd_config_get
 * @par Description:
 *      Perform a read on the fcd_config table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_config_get(int unit, int index, fcd_config_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(fcd_config_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CONFIG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_get: Failed reading table %s index %d rc %d\n",
                "fcd_config", index, rc));
        sal_mutex_give(fcd_config_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_FCD_CONFIG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_get: Failed register "
                "CB_BMU_FCD_CONFIG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(fcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_FCD_CONFIG_IA_RDATA_PART0r_field_get(unit, &regval, 
        THRESH1f, &tmpval);
    entry->thresh1 = tmpval & 8191;
    soc_CB_BMU_FCD_CONFIG_IA_RDATA_PART0r_field_get(unit, &regval, 
        THRESH0f, &tmpval);
    entry->thresh0 = tmpval & 8191;
    rc = REG_READ_CB_BMU_FCD_CONFIG_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_get: Failed register "
                "CB_BMU_FCD_CONFIG_IA_WDATA_PART1 read\n"));
        sal_mutex_give(fcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_FCD_CONFIG_IA_RDATA_PART1r_field_get(unit, &regval, 
        THRESH3f, &tmpval);
    entry->thresh3 = tmpval & 8191;
    soc_CB_BMU_FCD_CONFIG_IA_RDATA_PART1r_field_get(unit, &regval, 
        THRESH2f, &tmpval);
    entry->thresh2 = tmpval & 8191;
    rc = REG_READ_CB_BMU_FCD_CONFIG_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_get: Failed register "
                "CB_BMU_FCD_CONFIG_IA_WDATA_PART2 read\n"));
        sal_mutex_give(fcd_config_mutex);
        return rc;
    }
    soc_CB_BMU_FCD_CONFIG_IA_RDATA_PART2r_field_get(unit, &regval, 
        COUNTER_ENABLEf, &tmpval);
    entry->counter_enable = tmpval & 1;
    soc_CB_BMU_FCD_CONFIG_IA_RDATA_PART2r_field_get(unit, &regval, 
        TC_BMPf, &tmpval);
    entry->tc_bmp = tmpval & 255;
    soc_CB_BMU_FCD_CONFIG_IA_RDATA_PART2r_field_get(unit, &regval, 
        FC_ENABLEf, &tmpval);
    entry->fc_enable = tmpval & 1;
    soc_CB_BMU_FCD_CONFIG_IA_RDATA_PART2r_field_get(unit, &regval, 
        HYSTERESISf, &tmpval);
    entry->hysteresis = tmpval & 8191;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_FCD_CONFIG_ID) {
        sal_printf("THRESH1f = 0x%x\n", entry->thresh1);
        sal_printf("THRESH0f = 0x%x\n", entry->thresh0);
        sal_printf("THRESH3f = 0x%x\n", entry->thresh3);
        sal_printf("THRESH2f = 0x%x\n", entry->thresh2);
        sal_printf("COUNTER_ENABLEf = 0x%x\n", entry->counter_enable);
        sal_printf("TC_BMPf = 0x%x\n", entry->tc_bmp);
        sal_printf("FC_ENABLEf = 0x%x\n", entry->fc_enable);
        sal_printf("HYSTERESISf = 0x%x\n", entry->hysteresis);
    }
    sal_mutex_give(fcd_config_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_stat_get
 * @par Description:
 *      Perform a read on the stat table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_stat_get(int unit, int index, stat_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(stat_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STAT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_get: Failed reading table %s index %d rc %d\n",
                "stat", index, rc));
        sal_mutex_give(stat_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_STAT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_get: Failed register "
                "CB_CFP_STAT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(stat_mutex);
        return rc;
    }
    soc_CB_CFP_STAT_IA_RDATA_PART0r_field_get(unit, &regval, 
        STAT_COUNTER0_LOf, &entry->stat_counter0_lo);
    rc = REG_READ_CB_CFP_STAT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_get: Failed register "
                "CB_CFP_STAT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(stat_mutex);
        return rc;
    }
    soc_CB_CFP_STAT_IA_RDATA_PART1r_field_get(unit, &regval, 
        STAT_COUNTER0_HIf, &entry->stat_counter0_hi);
    rc = REG_READ_CB_CFP_STAT_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_get: Failed register "
                "CB_CFP_STAT_IA_WDATA_PART2 read\n"));
        sal_mutex_give(stat_mutex);
        return rc;
    }
    soc_CB_CFP_STAT_IA_RDATA_PART2r_field_get(unit, &regval, 
        STAT_COUNTER1_LOf, &entry->stat_counter1_lo);
    rc = REG_READ_CB_CFP_STAT_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_get: Failed register "
                "CB_CFP_STAT_IA_WDATA_PART3 read\n"));
        sal_mutex_give(stat_mutex);
        return rc;
    }
    soc_CB_CFP_STAT_IA_RDATA_PART3r_field_get(unit, &regval, 
        STAT_COUNTER1_HIf, &entry->stat_counter1_hi);
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_STAT_ID) {
        sal_printf("STAT_COUNTER0_LOf = 0x%x\n", entry->stat_counter0_lo);
        sal_printf("STAT_COUNTER0_HIf = 0x%x\n", entry->stat_counter0_hi);
        sal_printf("STAT_COUNTER1_LOf = 0x%x\n", entry->stat_counter1_lo);
        sal_printf("STAT_COUNTER1_HIf = 0x%x\n", entry->stat_counter1_hi);
    }
    sal_mutex_give(stat_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_eeecfg_get
 * @par Description:
 *      Perform a read on the eeecfg table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_eeecfg_get(int unit, int index, eeecfg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(eeecfg_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EEECFG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_get: Failed reading table %s index %d rc %d\n",
                "eeecfg", index, rc));
        sal_mutex_give(eeecfg_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_EEECFG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_get: Failed register "
                "CB_PQM_EEECFG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(eeecfg_mutex);
        return rc;
    }
    soc_CB_PQM_EEECFG_IA_RDATA_PART0r_field_get(unit, &regval, 
        EEE_THRESHf, &tmpval);
    entry->eee_thresh = tmpval & 65535;
    soc_CB_PQM_EEECFG_IA_RDATA_PART0r_field_get(unit, &regval, 
        EEE_TIMERf, &tmpval);
    entry->eee_timer = tmpval & 32767;
    soc_CB_PQM_EEECFG_IA_RDATA_PART0r_field_get(unit, &regval, 
        EEE_ENf, &tmpval);
    entry->eee_en = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_EEECFG_ID) {
        sal_printf("EEE_THRESHf = 0x%x\n", entry->eee_thresh);
        sal_printf("EEE_TIMERf = 0x%x\n", entry->eee_timer);
        sal_printf("EEE_ENf = 0x%x\n", entry->eee_en);
    }
    sal_mutex_give(eeecfg_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_hdt_get
 * @par Description:
 *      Perform a read on the hdt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_hdt_get(int unit, int index, hdt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(hdt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_HDT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_get: Failed reading table %s index %d rc %d\n",
                "hdt", index, rc));
        sal_mutex_give(hdt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_HDT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_get: Failed register "
                "CB_IPP_HDT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(hdt_mutex);
        return rc;
    }
    soc_CB_IPP_HDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TYPE0f, &tmpval);
    entry->type0 = tmpval & 255;
    soc_CB_IPP_HDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        WHICH0f, &tmpval);
    entry->which0 = tmpval & 3;
    soc_CB_IPP_HDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        UPTILL0f, &tmpval);
    entry->uptill0 = tmpval & 1;
    soc_CB_IPP_HDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TYPE1f, &tmpval);
    entry->type1 = tmpval & 255;
    soc_CB_IPP_HDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        WHICH1f, &tmpval);
    entry->which1 = tmpval & 3;
    soc_CB_IPP_HDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        UPTILL1f, &tmpval);
    entry->uptill1 = tmpval & 1;
    rc = REG_READ_CB_IPP_HDT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_get: Failed register "
                "CB_IPP_HDT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(hdt_mutex);
        return rc;
    }
    soc_CB_IPP_HDT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TYPE2f, &tmpval);
    entry->type2 = tmpval & 255;
    soc_CB_IPP_HDT_IA_RDATA_PART1r_field_get(unit, &regval, 
        UPTILL2f, &tmpval);
    entry->uptill2 = tmpval & 1;
    soc_CB_IPP_HDT_IA_RDATA_PART1r_field_get(unit, &regval, 
        UPTILL3f, &tmpval);
    entry->uptill3 = tmpval & 1;
    soc_CB_IPP_HDT_IA_RDATA_PART1r_field_get(unit, &regval, 
        WHICH2f, &tmpval);
    entry->which2 = tmpval & 3;
    soc_CB_IPP_HDT_IA_RDATA_PART1r_field_get(unit, &regval, 
        WHICH3f, &tmpval);
    entry->which3 = tmpval & 3;
    soc_CB_IPP_HDT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TYPE3f, &tmpval);
    entry->type3 = tmpval & 255;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_HDT_ID) {
        sal_printf("TYPE0f = 0x%x\n", entry->type0);
        sal_printf("WHICH0f = 0x%x\n", entry->which0);
        sal_printf("UPTILL0f = 0x%x\n", entry->uptill0);
        sal_printf("TYPE1f = 0x%x\n", entry->type1);
        sal_printf("WHICH1f = 0x%x\n", entry->which1);
        sal_printf("UPTILL1f = 0x%x\n", entry->uptill1);
        sal_printf("TYPE2f = 0x%x\n", entry->type2);
        sal_printf("UPTILL2f = 0x%x\n", entry->uptill2);
        sal_printf("UPTILL3f = 0x%x\n", entry->uptill3);
        sal_printf("WHICH2f = 0x%x\n", entry->which2);
        sal_printf("WHICH3f = 0x%x\n", entry->which3);
        sal_printf("TYPE3f = 0x%x\n", entry->type3);
    }
    sal_mutex_give(hdt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_estget_get
 * @par Description:
 *      Perform a read on the estget table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_estget_get(int unit, int index, estget_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(estget_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ESTGET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_get: Failed reading table %s index %d rc %d\n",
                "estget", index, rc));
        sal_mutex_give(estget_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_ESTGET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_get: Failed register "
                "CB_PQM_ESTGET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(estget_mutex);
        return rc;
    }
    soc_CB_PQM_ESTGET_IA_RDATA_PART0r_field_get(unit, &regval, 
        TX_ENAf, &tmpval);
    entry->tx_ena = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ESTGET_ID) {
        sal_printf("TX_ENAf = 0x%x\n", entry->tx_ena);
    }
    sal_mutex_give(estget_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_stt_get
 * @par Description:
 *      Perform a read on the stt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_stt_get(int unit, int index, stt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(stt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_get: Failed reading table %s index %d rc %d\n",
                "stt", index, rc));
        sal_mutex_give(stt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_STT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_get: Failed register "
                "CB_IPP_STT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(stt_mutex);
        return rc;
    }
    soc_CB_IPP_STT_IA_RDATA_PART0r_field_get(unit, &regval, 
        ETYPEf, &tmpval);
    entry->etype = tmpval & 65535;
    soc_CB_IPP_STT_IA_RDATA_PART0r_field_get(unit, &regval, 
        NTYPEf, &tmpval);
    entry->ntype = tmpval & 255;
    rc = REG_READ_CB_IPP_STT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_get: Failed register "
                "CB_IPP_STT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(stt_mutex);
        return rc;
    }
    soc_CB_IPP_STT_IA_RDATA_PART1r_field_get(unit, &regval, 
        EKEY_TYPEf, &tmpval);
    entry->ekey_type = tmpval & 15;
    soc_CB_IPP_STT_IA_RDATA_PART1r_field_get(unit, &regval, 
        LENGTHf, &tmpval);
    entry->length = tmpval & 7;
    soc_CB_IPP_STT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCIf, &tmpval);
    entry->tci = tmpval & 7;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_STT_ID) {
        sal_printf("ETYPEf = 0x%x\n", entry->etype);
        sal_printf("NTYPEf = 0x%x\n", entry->ntype);
        sal_printf("EKEY_TYPEf = 0x%x\n", entry->ekey_type);
        sal_printf("LENGTHf = 0x%x\n", entry->length);
        sal_printf("TCIf = 0x%x\n", entry->tci);
    }
    sal_mutex_give(stt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pet_get
 * @par Description:
 *      Perform a read on the pet table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pet_get(int unit, int index, pet_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pet_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_get: Failed reading table %s index %d rc %d\n",
                "pet", index, rc));
        sal_mutex_give(pet_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ETM_PET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_get: Failed register "
                "CB_ETM_PET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pet_mutex);
        return rc;
    }
    soc_CB_ETM_PET_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP4f, &tmpval);
    entry->encap4 = tmpval & 255;
    soc_CB_ETM_PET_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP5f, &tmpval);
    entry->encap5 = tmpval & 255;
    soc_CB_ETM_PET_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP7f, &tmpval);
    entry->encap7 = tmpval & 255;
    soc_CB_ETM_PET_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP6f, &tmpval);
    entry->encap6 = tmpval & 255;
    rc = REG_READ_CB_ETM_PET_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_get: Failed register "
                "CB_ETM_PET_IA_WDATA_PART1 read\n"));
        sal_mutex_give(pet_mutex);
        return rc;
    }
    soc_CB_ETM_PET_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP2f, &tmpval);
    entry->encap2 = tmpval & 255;
    soc_CB_ETM_PET_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP3f, &tmpval);
    entry->encap3 = tmpval & 255;
    soc_CB_ETM_PET_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP0f, &tmpval);
    entry->encap0 = tmpval & 255;
    soc_CB_ETM_PET_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP1f, &tmpval);
    entry->encap1 = tmpval & 255;
    rc = REG_READ_CB_ETM_PET_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_get: Failed register "
                "CB_ETM_PET_IA_WDATA_PART2 read\n"));
        sal_mutex_give(pet_mutex);
        return rc;
    }
    soc_CB_ETM_PET_IA_RDATA_PART2r_field_get(unit, &regval, 
        FULLf, &tmpval);
    entry->full = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PET_ID) {
        sal_printf("ENCAP4f = 0x%x\n", entry->encap4);
        sal_printf("ENCAP5f = 0x%x\n", entry->encap5);
        sal_printf("ENCAP7f = 0x%x\n", entry->encap7);
        sal_printf("ENCAP6f = 0x%x\n", entry->encap6);
        sal_printf("ENCAP2f = 0x%x\n", entry->encap2);
        sal_printf("ENCAP3f = 0x%x\n", entry->encap3);
        sal_printf("ENCAP0f = 0x%x\n", entry->encap0);
        sal_printf("ENCAP1f = 0x%x\n", entry->encap1);
        sal_printf("FULLf = 0x%x\n", entry->full);
    }
    sal_mutex_give(pet_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_istget_get
 * @par Description:
 *      Perform a read on the istget table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_istget_get(int unit, int index, istget_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(istget_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ISTGET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_get: Failed reading table %s index %d rc %d\n",
                "istget", index, rc));
        sal_mutex_give(istget_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_ISTGET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_get: Failed register "
                "CB_IPP_ISTGET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(istget_mutex);
        return rc;
    }
    soc_CB_IPP_ISTGET_IA_RDATA_PART0r_field_get(unit, &regval, 
        RX_ENAf, &tmpval);
    entry->rx_ena = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ISTGET_ID) {
        sal_printf("RX_ENAf = 0x%x\n", entry->rx_ena);
    }
    sal_mutex_give(istget_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_qdschcfg_get
 * @par Description:
 *      Perform a read on the qdschcfg table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_qdschcfg_get(int unit, int index, qdschcfg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(qdschcfg_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QDSCHCFG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_get: Failed reading table %s index %d rc %d\n",
                "qdschcfg", index, rc));
        sal_mutex_give(qdschcfg_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_QDSCHCFG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_get: Failed register "
                "CB_PQM_QDSCHCFG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(qdschcfg_mutex);
        return rc;
    }
    soc_CB_PQM_QDSCHCFG_IA_RDATA_PART0r_field_get(unit, &regval, 
        SP_RR_SCHf, &tmpval);
    entry->sp_rr_sch = tmpval & 255;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_QDSCHCFG_ID) {
        sal_printf("SP_RR_SCHf = 0x%x\n", entry->sp_rr_sch);
    }
    sal_mutex_give(qdschcfg_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pqm_rscale_get
 * @par Description:
 *      Perform a read on the pqm_rscale table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_rscale_get(int unit, int index, pqm_rscale_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_rscale_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_RSCALE_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_get: Failed reading table %s index %d rc %d\n",
                "pqm_rscale", index, rc));
        sal_mutex_give(pqm_rscale_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_RSCALE_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_get: Failed register "
                "CB_PQM_RSCALE_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pqm_rscale_mutex);
        return rc;
    }
    soc_CB_PQM_RSCALE_IA_RDATA_PART0r_field_get(unit, &regval, 
        SCALEf, &tmpval);
    entry->scale = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PQM_RSCALE_ID) {
        sal_printf("SCALEf = 0x%x\n", entry->scale);
    }
    sal_mutex_give(pqm_rscale_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_mtr2tcb_get
 * @par Description:
 *      Perform a read on the mtr2tcb table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtr2tcb_get(int unit, int index, mtr2tcb_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(mtr2tcb_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTR2TCB_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_get: Failed reading table %s index %d rc %d\n",
                "mtr2tcb", index, rc));
        sal_mutex_give(mtr2tcb_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_MTR2TCB_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_get: Failed register "
                "CB_BMU_MTR2TCB_IA_WDATA_PART0 read\n"));
        sal_mutex_give(mtr2tcb_mutex);
        return rc;
    }
    soc_CB_BMU_MTR2TCB_IA_RDATA_PART0r_field_get(unit, &regval, 
        TC_BMPf, &tmpval);
    entry->tc_bmp = tmpval & 255;
    soc_CB_BMU_MTR2TCB_IA_RDATA_PART0r_field_get(unit, &regval, 
        SHP_ENf, &tmpval);
    entry->shp_en = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_MTR2TCB_ID) {
        sal_printf("TC_BMPf = 0x%x\n", entry->tc_bmp);
        sal_printf("SHP_ENf = 0x%x\n", entry->shp_en);
    }
    sal_mutex_give(mtr2tcb_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_dli2ldpg_get
 * @par Description:
 *      Perform a read on the dli2ldpg table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_dli2ldpg_get(int unit, int index, dli2ldpg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(dli2ldpg_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLI2LDPG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_get: Failed reading table %s index %d rc %d\n",
                "dli2ldpg", index, rc));
        sal_mutex_give(dli2ldpg_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_DLI2LDPG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_get: Failed register "
                "CB_PQM_DLI2LDPG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(dli2ldpg_mutex);
        return rc;
    }
    soc_CB_PQM_DLI2LDPG_IA_RDATA_PART0r_field_get(unit, &regval, 
        LDPGIDf, &tmpval);
    entry->ldpgid = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_DLI2LDPG_ID) {
        sal_printf("LDPGIDf = 0x%x\n", entry->ldpgid);
    }
    sal_mutex_give(dli2ldpg_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_tc2qd_get
 * @par Description:
 *      Perform a read on the tc2qd table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_tc2qd_get(int unit, int index, tc2qd_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(tc2qd_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TC2QD_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_get: Failed reading table %s index %d rc %d\n",
                "tc2qd", index, rc));
        sal_mutex_give(tc2qd_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_TC2QD_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_get: Failed register "
                "CB_PQM_TC2QD_IA_WDATA_PART0 read\n"));
        sal_mutex_give(tc2qd_mutex);
        return rc;
    }
    soc_CB_PQM_TC2QD_IA_RDATA_PART0r_field_get(unit, &regval, 
        QDf, &tmpval);
    entry->qd = tmpval & 7;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_TC2QD_ID) {
        sal_printf("QDf = 0x%x\n", entry->qd);
    }
    sal_mutex_give(tc2qd_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_spldt_get
 * @par Description:
 *      Perform a read on the spldt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_spldt_get(int unit, int index, spldt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(spldt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPLDT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_get: Failed reading table %s index %d rc %d\n",
                "spldt", index, rc));
        sal_mutex_give(spldt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_EPP_SPLDT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_get: Failed register "
                "CB_EPP_SPLDT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(spldt_mutex);
        return rc;
    }
    soc_CB_EPP_SPLDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        LINK_DELAYf, &tmpval);
    entry->link_delay = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_SPLDT_ID) {
        sal_printf("LINK_DELAYf = 0x%x\n", entry->link_delay);
    }
    sal_mutex_give(spldt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_cfp_rscale_get
 * @par Description:
 *      Perform a read on the cfp_rscale table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_rscale_get(int unit, int index, cfp_rscale_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_rscale_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_RSCALE_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_get: Failed reading table %s index %d rc %d\n",
                "cfp_rscale", index, rc));
        sal_mutex_give(cfp_rscale_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_RSCALE_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_get: Failed register "
                "CB_CFP_RSCALE_IA_WDATA_PART0 read\n"));
        sal_mutex_give(cfp_rscale_mutex);
        return rc;
    }
    soc_CB_CFP_RSCALE_IA_RDATA_PART0r_field_get(unit, &regval, 
        SCALEf, &tmpval);
    entry->scale = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_CFP_RSCALE_ID) {
        sal_printf("SCALEf = 0x%x\n", entry->scale);
    }
    sal_mutex_give(cfp_rscale_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ghtdt_get
 * @par Description:
 *      Perform a read on the ghtdt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghtdt_get(int unit, int index, ghtdt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ghtdt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHTDT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_get: Failed reading table %s index %d rc %d\n",
                "ghtdt", index, rc));
        sal_mutex_give(ghtdt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ITM_GHTDT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_get: Failed register "
                "CB_ITM_GHTDT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ghtdt_mutex);
        return rc;
    }
    soc_CB_ITM_GHTDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SEED1f, &tmpval);
    entry->seed1 = tmpval & 7;
    soc_CB_ITM_GHTDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        BASEf, &tmpval);
    entry->base = tmpval & 16383;
    soc_CB_ITM_GHTDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        NUM_ENTRIESf, &tmpval);
    entry->num_entries = tmpval & 15;
    soc_CB_ITM_GHTDT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SEED0f, &tmpval);
    entry->seed0 = tmpval & 7;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_GHTDT_ID) {
        sal_printf("SEED1f = 0x%x\n", entry->seed1);
        sal_printf("BASEf = 0x%x\n", entry->base);
        sal_printf("NUM_ENTRIESf = 0x%x\n", entry->num_entries);
        sal_printf("SEED0f = 0x%x\n", entry->seed0);
    }
    sal_mutex_give(ghtdt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_bmu_bucket_get
 * @par Description:
 *      Perform a read on the bmu_bucket table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_bucket_get(int unit, int index, bmu_bucket_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_bucket_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_BUCKET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_get: Failed reading table %s index %d rc %d\n",
                "bmu_bucket", index, rc));
        sal_mutex_give(bmu_bucket_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_BUCKET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_get: Failed register "
                "CB_BMU_BUCKET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(bmu_bucket_mutex);
        return rc;
    }
    soc_CB_BMU_BUCKET_IA_RDATA_PART0r_field_get(unit, &regval, 
        BKTEf, &tmpval);
    entry->bkte = tmpval & 134217727;
    rc = REG_READ_CB_BMU_BUCKET_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_get: Failed register "
                "CB_BMU_BUCKET_IA_WDATA_PART1 read\n"));
        sal_mutex_give(bmu_bucket_mutex);
        return rc;
    }
    soc_CB_BMU_BUCKET_IA_RDATA_PART1r_field_get(unit, &regval, 
        BKTCf, &tmpval);
    entry->bktc = tmpval & 134217727;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_BMU_BUCKET_ID) {
        sal_printf("BKTEf = 0x%x\n", entry->bkte);
        sal_printf("BKTCf = 0x%x\n", entry->bktc);
    }
    sal_mutex_give(bmu_bucket_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_lilt_get
 * @par Description:
 *      Perform a read on the lilt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_lilt_get(int unit, int index, lilt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lilt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LILT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_get: Failed reading table %s index %d rc %d\n",
                "lilt", index, rc));
        sal_mutex_give(lilt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_LILT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_get: Failed register "
                "CB_PQM_LILT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(lilt_mutex);
        return rc;
    }
    soc_CB_PQM_LILT_IA_RDATA_PART0r_field_get(unit, &regval, 
        LILT_ENTRYf, &entry->lilt_entry);
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_LILT_ID) {
        sal_printf("LILT_ENTRYf = 0x%x\n", entry->lilt_entry);
    }
    sal_mutex_give(lilt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_svt_get
 * @par Description:
 *      Perform a read on the svt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_svt_get(int unit, int index, svt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(svt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SVT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_get: Failed reading table %s index %d rc %d\n",
                "svt", index, rc));
        sal_mutex_give(svt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_SVT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_get: Failed register "
                "CB_PQM_SVT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(svt_mutex);
        return rc;
    }
    soc_CB_PQM_SVT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SVT_MASKf, &tmpval);
    entry->svt_mask = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_SVT_ID) {
        sal_printf("SVT_MASKf = 0x%x\n", entry->svt_mask);
    }
    sal_mutex_give(svt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_slicmap_get
 * @par Description:
 *      Perform a read on the slicmap table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_slicmap_get(int unit, int index, slicmap_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(slicmap_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICMAP_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed reading table %s index %d rc %d\n",
                "slicmap", index, rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_SLICMAP_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed register "
                "CB_IPP_SLICMAP_IA_WDATA_PART0 read\n"));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_RDATA_PART0r_field_get(unit, &regval, 
        TCI5f, &tmpval);
    entry->tci5 = tmpval & 65535;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART0r_field_get(unit, &regval, 
        TCI4f, &tmpval);
    entry->tci4 = tmpval & 65535;
    rc = REG_READ_CB_IPP_SLICMAP_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed register "
                "CB_IPP_SLICMAP_IA_WDATA_PART1 read\n"));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCI2f, &tmpval);
    entry->tci2 = tmpval & 65535;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCI3f, &tmpval);
    entry->tci3 = tmpval & 65535;
    rc = REG_READ_CB_IPP_SLICMAP_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed register "
                "CB_IPP_SLICMAP_IA_WDATA_PART2 read\n"));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_RDATA_PART2r_field_get(unit, &regval, 
        TCI1f, &tmpval);
    entry->tci1 = tmpval & 65535;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART2r_field_get(unit, &regval, 
        TCI0f, &tmpval);
    entry->tci0 = tmpval & 65535;
    rc = REG_READ_CB_IPP_SLICMAP_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed register "
                "CB_IPP_SLICMAP_IA_WDATA_PART3 read\n"));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_RDATA_PART3r_field_get(unit, &regval, 
        VALIDf, &tmpval);
    entry->valid = tmpval & 63;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART3r_field_get(unit, &regval, 
        TPID0f, &tmpval);
    entry->tpid0 = tmpval & 15;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART3r_field_get(unit, &regval, 
        TPID1f, &tmpval);
    entry->tpid1 = tmpval & 15;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART3r_field_get(unit, &regval, 
        UNUSEDBf, &tmpval);
    entry->unusedb = tmpval & 3;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART3r_field_get(unit, &regval, 
        TPID2f, &tmpval);
    entry->tpid2 = tmpval & 15;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART3r_field_get(unit, &regval, 
        TPID4f, &tmpval);
    entry->tpid4 = tmpval & 15;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART3r_field_get(unit, &regval, 
        ETYPEf, &tmpval);
    entry->etype = tmpval & 15;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART3r_field_get(unit, &regval, 
        TPID3f, &tmpval);
    entry->tpid3 = tmpval & 15;
    rc = REG_READ_CB_IPP_SLICMAP_IA_RDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed register "
                "CB_IPP_SLICMAP_IA_WDATA_PART4 read\n"));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_RDATA_PART4r_field_get(unit, &regval, 
        SMAC_LO32f, &entry->smac_lo32);
    rc = REG_READ_CB_IPP_SLICMAP_IA_RDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed register "
                "CB_IPP_SLICMAP_IA_WDATA_PART5 read\n"));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_RDATA_PART5r_field_get(unit, &regval, 
        SMAC_HI16f, &tmpval);
    entry->smac_hi16 = tmpval & 65535;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART5r_field_get(unit, &regval, 
        DMAC_LO16f, &tmpval);
    entry->dmac_lo16 = tmpval & 65535;
    rc = REG_READ_CB_IPP_SLICMAP_IA_RDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed register "
                "CB_IPP_SLICMAP_IA_WDATA_PART6 read\n"));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_RDATA_PART6r_field_get(unit, &regval, 
        DMAC_HI32f, &entry->dmac_hi32);
    rc = REG_READ_CB_IPP_SLICMAP_IA_RDATA_PART7r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed register "
                "CB_IPP_SLICMAP_IA_WDATA_PART7 read\n"));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_RDATA_PART7r_field_get(unit, &regval, 
        PEPPERf, &tmpval);
    entry->pepper = tmpval & 4095;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART7r_field_get(unit, &regval, 
        PG_MAPf, &tmpval);
    entry->pg_map = tmpval & 65535;
    soc_CB_IPP_SLICMAP_IA_RDATA_PART7r_field_get(unit, &regval, 
        UNUSEDAf, &tmpval);
    entry->unuseda = tmpval & 15;
    rc = REG_READ_CB_IPP_SLICMAP_IA_RDATA_PART8r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_get: Failed register "
                "CB_IPP_SLICMAP_IA_WDATA_PART8 read\n"));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_RDATA_PART8r_field_get(unit, &regval, 
        VALID_KEY0f, &tmpval);
    entry->valid_key0 = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_SLICMAP_ID) {
        sal_printf("TCI5f = 0x%x\n", entry->tci5);
        sal_printf("TCI4f = 0x%x\n", entry->tci4);
        sal_printf("TCI2f = 0x%x\n", entry->tci2);
        sal_printf("TCI3f = 0x%x\n", entry->tci3);
        sal_printf("TCI1f = 0x%x\n", entry->tci1);
        sal_printf("TCI0f = 0x%x\n", entry->tci0);
        sal_printf("VALIDf = 0x%x\n", entry->valid);
        sal_printf("TPID0f = 0x%x\n", entry->tpid0);
        sal_printf("TPID1f = 0x%x\n", entry->tpid1);
        sal_printf("UNUSEDBf = 0x%x\n", entry->unusedb);
        sal_printf("TPID2f = 0x%x\n", entry->tpid2);
        sal_printf("TPID4f = 0x%x\n", entry->tpid4);
        sal_printf("ETYPEf = 0x%x\n", entry->etype);
        sal_printf("TPID3f = 0x%x\n", entry->tpid3);
        sal_printf("SMAC_LO32f = 0x%x\n", entry->smac_lo32);
        sal_printf("SMAC_HI16f = 0x%x\n", entry->smac_hi16);
        sal_printf("DMAC_LO16f = 0x%x\n", entry->dmac_lo16);
        sal_printf("DMAC_HI32f = 0x%x\n", entry->dmac_hi32);
        sal_printf("PEPPERf = 0x%x\n", entry->pepper);
        sal_printf("PG_MAPf = 0x%x\n", entry->pg_map);
        sal_printf("UNUSEDAf = 0x%x\n", entry->unuseda);
        sal_printf("VALID_KEY0f = 0x%x\n", entry->valid_key0);
    }
    sal_mutex_give(slicmap_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_m2tk_get
 * @par Description:
 *      Perform a read on the m2tk table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_m2tk_get(int unit, int index, m2tk_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(m2tk_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_M2TK_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_get: Failed reading table %s index %d rc %d\n",
                "m2tk", index, rc));
        sal_mutex_give(m2tk_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_M2TK_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_get: Failed register "
                "CB_IPP_M2TK_IA_WDATA_PART0 read\n"));
        sal_mutex_give(m2tk_mutex);
        return rc;
    }
    soc_CB_IPP_M2TK_IA_RDATA_PART0r_field_get(unit, &regval, 
        TABLE_IDf, &tmpval);
    entry->table_id = tmpval & 7;
    soc_CB_IPP_M2TK_IA_RDATA_PART0r_field_get(unit, &regval, 
        KEY_IDf, &tmpval);
    entry->key_id = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_M2TK_ID) {
        sal_printf("TABLE_IDf = 0x%x\n", entry->table_id);
        sal_printf("KEY_IDf = 0x%x\n", entry->key_id);
    }
    sal_mutex_give(m2tk_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_art_get
 * @par Description:
 *      Perform a read on the art table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_art_get(int unit, int index, art_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(art_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ART_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_get: Failed reading table %s index %d rc %d\n",
                "art", index, rc));
        sal_mutex_give(art_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_ART_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_get: Failed register "
                "CB_CFP_ART_IA_WDATA_PART0 read\n"));
        sal_mutex_give(art_mutex);
        return rc;
    }
    soc_CB_CFP_ART_IA_RDATA_PART0r_field_get(unit, &regval, 
        NDXf, &tmpval);
    entry->ndx = tmpval & 1023;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ART_ID) {
        sal_printf("NDXf = 0x%x\n", entry->ndx);
    }
    sal_mutex_give(art_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_lpg2ig_get
 * @par Description:
 *      Perform a read on the lpg2ig table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ig_get(int unit, int index, lpg2ig_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lpg2ig_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2IG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_get: Failed reading table %s index %d rc %d\n",
                "lpg2ig", index, rc));
        sal_mutex_give(lpg2ig_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_LPG2IG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_get: Failed register "
                "CB_PQM_LPG2IG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(lpg2ig_mutex);
        return rc;
    }
    soc_CB_PQM_LPG2IG_IA_RDATA_PART0r_field_get(unit, &regval, 
        IGf, &tmpval);
    entry->ig = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_LPG2IG_ID) {
        sal_printf("IGf = 0x%x\n", entry->ig);
    }
    sal_mutex_give(lpg2ig_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ipp_profile_get
 * @par Description:
 *      Perform a read on the ipp_profile table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_profile_get(int unit, int index, ipp_profile_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_profile_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PROFILE_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_get: Failed reading table %s index %d rc %d\n",
                "ipp_profile", index, rc));
        sal_mutex_give(ipp_profile_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_PROFILE_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_get: Failed register "
                "CB_IPP_PROFILE_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ipp_profile_mutex);
        return rc;
    }
    soc_CB_IPP_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CBS_EXPf, &tmpval);
    entry->cbs_exp = tmpval & 31;
    soc_CB_IPP_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CBS_MANTISSAf, &tmpval);
    entry->cbs_mantissa = tmpval & 127;
    soc_CB_IPP_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CIR_MANTISSAf, &tmpval);
    entry->cir_mantissa = tmpval & 2047;
    soc_CB_IPP_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CIR_EXPf, &tmpval);
    entry->cir_exp = tmpval & 31;
    rc = REG_READ_CB_IPP_PROFILE_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_get: Failed register "
                "CB_IPP_PROFILE_IA_WDATA_PART1 read\n"));
        sal_mutex_give(ipp_profile_mutex);
        return rc;
    }
    soc_CB_IPP_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EIR_EXPf, &tmpval);
    entry->eir_exp = tmpval & 31;
    soc_CB_IPP_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EBS_EXPf, &tmpval);
    entry->ebs_exp = tmpval & 31;
    soc_CB_IPP_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EIR_MANTISSAf, &tmpval);
    entry->eir_mantissa = tmpval & 2047;
    soc_CB_IPP_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EBS_MANTISSAf, &tmpval);
    entry->ebs_mantissa = tmpval & 127;
    rc = REG_READ_CB_IPP_PROFILE_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_get: Failed register "
                "CB_IPP_PROFILE_IA_WDATA_PART2 read\n"));
        sal_mutex_give(ipp_profile_mutex);
        return rc;
    }
    soc_CB_IPP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        DROP_ON_REDf, &tmpval);
    entry->drop_on_red = tmpval & 1;
    soc_CB_IPP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        PKT_MODEf, &tmpval);
    entry->pkt_mode = tmpval & 1;
    soc_CB_IPP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BKTC_STRICTf, &tmpval);
    entry->bktc_strict = tmpval & 1;
    soc_CB_IPP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BKTE_STRICTf, &tmpval);
    entry->bkte_strict = tmpval & 1;
    soc_CB_IPP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        CFf, &tmpval);
    entry->cf = tmpval & 1;
    soc_CB_IPP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        RFC2698f, &tmpval);
    entry->rfc2698 = tmpval & 1;
    soc_CB_IPP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BLINDf, &tmpval);
    entry->blind = tmpval & 1;
    soc_CB_IPP_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        AVB_MODEf, &tmpval);
    entry->avb_mode = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_IPP_PROFILE_ID) {
        sal_printf("CBS_EXPf = 0x%x\n", entry->cbs_exp);
        sal_printf("CBS_MANTISSAf = 0x%x\n", entry->cbs_mantissa);
        sal_printf("CIR_MANTISSAf = 0x%x\n", entry->cir_mantissa);
        sal_printf("CIR_EXPf = 0x%x\n", entry->cir_exp);
        sal_printf("EIR_EXPf = 0x%x\n", entry->eir_exp);
        sal_printf("EBS_EXPf = 0x%x\n", entry->ebs_exp);
        sal_printf("EIR_MANTISSAf = 0x%x\n", entry->eir_mantissa);
        sal_printf("EBS_MANTISSAf = 0x%x\n", entry->ebs_mantissa);
        sal_printf("DROP_ON_REDf = 0x%x\n", entry->drop_on_red);
        sal_printf("PKT_MODEf = 0x%x\n", entry->pkt_mode);
        sal_printf("BKTC_STRICTf = 0x%x\n", entry->bktc_strict);
        sal_printf("BKTE_STRICTf = 0x%x\n", entry->bkte_strict);
        sal_printf("CFf = 0x%x\n", entry->cf);
        sal_printf("RFC2698f = 0x%x\n", entry->rfc2698);
        sal_printf("BLINDf = 0x%x\n", entry->blind);
        sal_printf("AVB_MODEf = 0x%x\n", entry->avb_mode);
    }
    sal_mutex_give(ipp_profile_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_qfcqdaddr_get
 * @par Description:
 *      Perform a read on the qfcqdaddr table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfcqdaddr_get(int unit, int index, qfcqdaddr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(qfcqdaddr_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCQDADDR_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_get: Failed reading table %s index %d rc %d\n",
                "qfcqdaddr", index, rc));
        sal_mutex_give(qfcqdaddr_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_QFCQDADDR_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_get: Failed register "
                "CB_PQM_QFCQDADDR_IA_WDATA_PART0 read\n"));
        sal_mutex_give(qfcqdaddr_mutex);
        return rc;
    }
    soc_CB_PQM_QFCQDADDR_IA_RDATA_PART0r_field_get(unit, &regval, 
        QFC_ADDRf, &tmpval);
    entry->qfc_addr = tmpval & 8191;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_QFCQDADDR_ID) {
        sal_printf("QFC_ADDRf = 0x%x\n", entry->qfc_addr);
    }
    sal_mutex_give(qfcqdaddr_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_mtgt_get
 * @par Description:
 *      Perform a read on the mtgt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtgt_get(int unit, int index, mtgt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(mtgt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTGT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_get: Failed reading table %s index %d rc %d\n",
                "mtgt", index, rc));
        sal_mutex_give(mtgt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_MTGT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_get: Failed register "
                "CB_PQM_MTGT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(mtgt_mutex);
        return rc;
    }
    soc_CB_PQM_MTGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TCf, &tmpval);
    entry->tc = tmpval & 7;
    soc_CB_PQM_MTGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DPf, &tmpval);
    entry->dp = tmpval & 3;
    soc_CB_PQM_MTGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DLI_Nf, &tmpval);
    entry->dli_n = tmpval & 2047;
    soc_CB_PQM_MTGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TRUNCATEf, &tmpval);
    entry->truncate = tmpval & 1;
    rc = REG_READ_CB_PQM_MTGT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_get: Failed register "
                "CB_PQM_MTGT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(mtgt_mutex);
        return rc;
    }
    soc_CB_PQM_MTGT_IA_RDATA_PART1r_field_get(unit, &regval, 
        DROP_PROBf, &tmpval);
    entry->drop_prob = tmpval & 1023;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_MTGT_ID) {
        sal_printf("TCf = 0x%x\n", entry->tc);
        sal_printf("DPf = 0x%x\n", entry->dp);
        sal_printf("DLI_Nf = 0x%x\n", entry->dli_n);
        sal_printf("TRUNCATEf = 0x%x\n", entry->truncate);
        sal_printf("DROP_PROBf = 0x%x\n", entry->drop_prob);
    }
    sal_mutex_give(mtgt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ipp_pptr_get
 * @par Description:
 *      Perform a read on the ipp_pptr table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pptr_get(int unit, int index, ipp_pptr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_pptr_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PPTR_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_get: Failed reading table %s index %d rc %d\n",
                "ipp_pptr", index, rc));
        sal_mutex_give(ipp_pptr_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_PPTR_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_get: Failed register "
                "CB_IPP_PPTR_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ipp_pptr_mutex);
        return rc;
    }
    soc_CB_IPP_PPTR_IA_RDATA_PART0r_field_get(unit, &regval, 
        POINTERf, &tmpval);
    entry->pointer = tmpval & 255;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_IPP_PPTR_ID) {
        sal_printf("POINTERf = 0x%x\n", entry->pointer);
    }
    sal_mutex_give(ipp_pptr_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_set_get
 * @par Description:
 *      Perform a read on the set table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_set_get(int unit, int index, set_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(set_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_get: Failed reading table %s index %d rc %d\n",
                "set", index, rc));
        sal_mutex_give(set_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_EPP_SET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_get: Failed register "
                "CB_EPP_SET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(set_mutex);
        return rc;
    }
    soc_CB_EPP_SET_IA_RDATA_PART0r_field_get(unit, &regval, 
        SMAC_LSBf, &entry->smac_lsb);
    rc = REG_READ_CB_EPP_SET_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_get: Failed register "
                "CB_EPP_SET_IA_WDATA_PART1 read\n"));
        sal_mutex_give(set_mutex);
        return rc;
    }
    soc_CB_EPP_SET_IA_RDATA_PART1r_field_get(unit, &regval, 
        SMAC_MSBf, &tmpval);
    entry->smac_msb = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_SET_ID) {
        sal_printf("SMAC_LSBf = 0x%x\n", entry->smac_lsb);
        sal_printf("SMAC_MSBf = 0x%x\n", entry->smac_msb);
    }
    sal_mutex_give(set_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_srt_get
 * @par Description:
 *      Perform a read on the srt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_srt_get(int unit, int index, srt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(srt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SRT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_get: Failed reading table %s index %d rc %d\n",
                "srt", index, rc));
        sal_mutex_give(srt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_SRT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_get: Failed register "
                "CB_IPP_SRT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(srt_mutex);
        return rc;
    }
    soc_CB_IPP_SRT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SLICIDf, &tmpval);
    entry->slicid = tmpval & 255;
    soc_CB_IPP_SRT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TRAP_GROUPf, &tmpval);
    entry->trap_group = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_SRT_ID) {
        sal_printf("SLICIDf = 0x%x\n", entry->slicid);
        sal_printf("TRAP_GROUPf = 0x%x\n", entry->trap_group);
    }
    sal_mutex_give(srt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ipp_pmon_get
 * @par Description:
 *      Perform a read on the ipp_pmon table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pmon_get(int unit, int index, ipp_pmon_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_pmon_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PMON_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_get: Failed reading table %s index %d rc %d\n",
                "ipp_pmon", index, rc));
        sal_mutex_give(ipp_pmon_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_PMON_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_get: Failed register "
                "CB_IPP_PMON_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ipp_pmon_mutex);
        return rc;
    }
    soc_CB_IPP_PMON_IA_RDATA_PART0r_field_get(unit, &regval, 
        COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_READ_CB_IPP_PMON_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_get: Failed register "
                "CB_IPP_PMON_IA_WDATA_PART1 read\n"));
        sal_mutex_give(ipp_pmon_mutex);
        return rc;
    }
    soc_CB_IPP_PMON_IA_RDATA_PART1r_field_get(unit, &regval, 
        COUNT_MSBSf, &entry->count_msbs);
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_IPP_PMON_ID) {
        sal_printf("COUNT_LSBSf = 0x%x\n", entry->count_lsbs);
        sal_printf("COUNT_MSBSf = 0x%x\n", entry->count_msbs);
    }
    sal_mutex_give(ipp_pmon_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_vtct_get
 * @par Description:
 *      Perform a read on the vtct table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_vtct_get(int unit, int index, vtct_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(vtct_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VTCT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_get: Failed reading table %s index %d rc %d\n",
                "vtct", index, rc));
        sal_mutex_give(vtct_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ETM_VTCT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_get: Failed register "
                "CB_ETM_VTCT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(vtct_mutex);
        return rc;
    }
    soc_CB_ETM_VTCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        VIDf, &tmpval);
    entry->vid = tmpval & 4095;
    rc = REG_READ_CB_ETM_VTCT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_get: Failed register "
                "CB_ETM_VTCT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(vtct_mutex);
        return rc;
    }
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA1f, &tmpval);
    entry->tca1 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA2f, &tmpval);
    entry->tca2 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA13f, &tmpval);
    entry->tca13 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA4f, &tmpval);
    entry->tca4 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA5f, &tmpval);
    entry->tca5 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA8f, &tmpval);
    entry->tca8 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA9f, &tmpval);
    entry->tca9 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA3f, &tmpval);
    entry->tca3 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA14f, &tmpval);
    entry->tca14 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA12f, &tmpval);
    entry->tca12 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA0f, &tmpval);
    entry->tca0 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA10f, &tmpval);
    entry->tca10 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA7f, &tmpval);
    entry->tca7 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA6f, &tmpval);
    entry->tca6 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA11f, &tmpval);
    entry->tca11 = tmpval & 3;
    soc_CB_ETM_VTCT_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCA15f, &tmpval);
    entry->tca15 = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_VTCT_ID) {
        sal_printf("VIDf = 0x%x\n", entry->vid);
        sal_printf("TCA1f = 0x%x\n", entry->tca1);
        sal_printf("TCA2f = 0x%x\n", entry->tca2);
        sal_printf("TCA13f = 0x%x\n", entry->tca13);
        sal_printf("TCA4f = 0x%x\n", entry->tca4);
        sal_printf("TCA5f = 0x%x\n", entry->tca5);
        sal_printf("TCA8f = 0x%x\n", entry->tca8);
        sal_printf("TCA9f = 0x%x\n", entry->tca9);
        sal_printf("TCA3f = 0x%x\n", entry->tca3);
        sal_printf("TCA14f = 0x%x\n", entry->tca14);
        sal_printf("TCA12f = 0x%x\n", entry->tca12);
        sal_printf("TCA0f = 0x%x\n", entry->tca0);
        sal_printf("TCA10f = 0x%x\n", entry->tca10);
        sal_printf("TCA7f = 0x%x\n", entry->tca7);
        sal_printf("TCA6f = 0x%x\n", entry->tca6);
        sal_printf("TCA11f = 0x%x\n", entry->tca11);
        sal_printf("TCA15f = 0x%x\n", entry->tca15);
    }
    sal_mutex_give(vtct_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_cfpcam_get
 * @par Description:
 *      Perform a read on the cfpcam table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfpcam_get(int unit, int index, cfpcam_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfpcam_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFPCAM_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_get: Failed reading table %s index %d rc %d\n",
                "cfpcam", index, rc));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_CFPCAM_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_get: Failed register "
                "CB_CFP_CFPCAM_IA_WDATA_PART0 read\n"));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_RDATA_PART0r_field_get(unit, &regval, 
        TCAM_DATA0f, &entry->tcam_data0);
    rc = REG_READ_CB_CFP_CFPCAM_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_get: Failed register "
                "CB_CFP_CFPCAM_IA_WDATA_PART1 read\n"));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_RDATA_PART1r_field_get(unit, &regval, 
        TCAM_DATA1f, &entry->tcam_data1);
    rc = REG_READ_CB_CFP_CFPCAM_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_get: Failed register "
                "CB_CFP_CFPCAM_IA_WDATA_PART2 read\n"));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_RDATA_PART2r_field_get(unit, &regval, 
        TCAM_DATA2f, &entry->tcam_data2);
    rc = REG_READ_CB_CFP_CFPCAM_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_get: Failed register "
                "CB_CFP_CFPCAM_IA_WDATA_PART3 read\n"));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_RDATA_PART3r_field_get(unit, &regval, 
        TCAM_DATA3f, &entry->tcam_data3);
    rc = REG_READ_CB_CFP_CFPCAM_IA_RDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_get: Failed register "
                "CB_CFP_CFPCAM_IA_WDATA_PART4 read\n"));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_RDATA_PART4r_field_get(unit, &regval, 
        TCAM_DATA4f, &entry->tcam_data4);
    rc = REG_READ_CB_CFP_CFPCAM_IA_RDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_get: Failed register "
                "CB_CFP_CFPCAM_IA_WDATA_PART5 read\n"));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_RDATA_PART5r_field_get(unit, &regval, 
        TCAM_DATA5f, &entry->tcam_data5);
    rc = REG_READ_CB_CFP_CFPCAM_IA_RDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_get: Failed register "
                "CB_CFP_CFPCAM_IA_WDATA_PART6 read\n"));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_RDATA_PART6r_field_get(unit, &regval, 
        TCAM_VALIDf, &tmpval);
    entry->tcam_valid = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_CFPCAM_ID) {
        sal_printf("TCAM_DATA0f = 0x%x\n", entry->tcam_data0);
        sal_printf("TCAM_DATA1f = 0x%x\n", entry->tcam_data1);
        sal_printf("TCAM_DATA2f = 0x%x\n", entry->tcam_data2);
        sal_printf("TCAM_DATA3f = 0x%x\n", entry->tcam_data3);
        sal_printf("TCAM_DATA4f = 0x%x\n", entry->tcam_data4);
        sal_printf("TCAM_DATA5f = 0x%x\n", entry->tcam_data5);
        sal_printf("TCAM_VALIDf = 0x%x\n", entry->tcam_valid);
    }
    sal_mutex_give(cfpcam_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_fcd_cntr_get
 * @par Description:
 *      Perform a read on the fcd_cntr table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_cntr_get(int unit, int index, fcd_cntr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(fcd_cntr_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CNTR_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_get: Failed reading table %s index %d rc %d\n",
                "fcd_cntr", index, rc));
        sal_mutex_give(fcd_cntr_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_FCD_CNTR_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_get: Failed register "
                "CB_BMU_FCD_CNTR_IA_WDATA_PART0 read\n"));
        sal_mutex_give(fcd_cntr_mutex);
        return rc;
    }
    soc_CB_BMU_FCD_CNTR_IA_RDATA_PART0r_field_get(unit, &regval, 
        PAGE_CNTf, &tmpval);
    entry->page_cnt = tmpval & 8191;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_FCD_CNTR_ID) {
        sal_printf("PAGE_CNTf = 0x%x\n", entry->page_cnt);
    }
    sal_mutex_give(fcd_cntr_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_fpslict_get
 * @par Description:
 *      Perform a read on the fpslict table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_fpslict_get(int unit, int index, fpslict_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(fpslict_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FPSLICT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_get: Failed reading table %s index %d rc %d\n",
                "fpslict", index, rc));
        sal_mutex_give(fpslict_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_FPSLICT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_get: Failed register "
                "CB_IPP_FPSLICT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(fpslict_mutex);
        return rc;
    }
    soc_CB_IPP_FPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DST_KEYf, &tmpval);
    entry->dst_key = tmpval & 7;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        IPV6_KEYSETf, &tmpval);
    entry->ipv6_keyset = tmpval & 15;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        IPV4_KEYSETf, &tmpval);
    entry->ipv4_keyset = tmpval & 15;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        OTHER_KEYSETf, &tmpval);
    entry->other_keyset = tmpval & 15;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SRC_KEYf, &tmpval);
    entry->src_key = tmpval & 7;
    rc = REG_READ_CB_IPP_FPSLICT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_get: Failed register "
                "CB_IPP_FPSLICT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(fpslict_mutex);
        return rc;
    }
    soc_CB_IPP_FPSLICT_IA_RDATA_PART1r_field_get(unit, &regval, 
        RSVDf, &tmpval);
    entry->rsvd = tmpval & 1;
    rc = REG_READ_CB_IPP_FPSLICT_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_get: Failed register "
                "CB_IPP_FPSLICT_IA_WDATA_PART2 read\n"));
        sal_mutex_give(fpslict_mutex);
        return rc;
    }
    soc_CB_IPP_FPSLICT_IA_RDATA_PART2r_field_get(unit, &regval, 
        PV2LI_MAP_ENf, &tmpval);
    entry->pv2li_map_en = tmpval & 1;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART2r_field_get(unit, &regval, 
        DEFAULT_SLIf, &tmpval);
    entry->default_sli = tmpval & 262143;
    rc = REG_READ_CB_IPP_FPSLICT_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_get: Failed register "
                "CB_IPP_FPSLICT_IA_WDATA_PART3 read\n"));
        sal_mutex_give(fpslict_mutex);
        return rc;
    }
    soc_CB_IPP_FPSLICT_IA_RDATA_PART3r_field_get(unit, &regval, 
        LI_MAP0f, &tmpval);
    entry->li_map0 = tmpval & 15;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART3r_field_get(unit, &regval, 
        LI_MAP0_ENf, &tmpval);
    entry->li_map0_en = tmpval & 1;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART3r_field_get(unit, &regval, 
        LI_MAP1_ENf, &tmpval);
    entry->li_map1_en = tmpval & 1;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART3r_field_get(unit, &regval, 
        LI_MAP0_DECAPf, &tmpval);
    entry->li_map0_decap = tmpval & 15;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART3r_field_get(unit, &regval, 
        LI_MAP1_DECAPf, &tmpval);
    entry->li_map1_decap = tmpval & 15;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART3r_field_get(unit, &regval, 
        SLIC_DECAPf, &tmpval);
    entry->slic_decap = tmpval & 15;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART3r_field_get(unit, &regval, 
        PV_DECAPf, &tmpval);
    entry->pv_decap = tmpval & 15;
    soc_CB_IPP_FPSLICT_IA_RDATA_PART3r_field_get(unit, &regval, 
        LI_MAP1f, &tmpval);
    entry->li_map1 = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_FPSLICT_ID) {
        sal_printf("DST_KEYf = 0x%x\n", entry->dst_key);
        sal_printf("IPV6_KEYSETf = 0x%x\n", entry->ipv6_keyset);
        sal_printf("IPV4_KEYSETf = 0x%x\n", entry->ipv4_keyset);
        sal_printf("OTHER_KEYSETf = 0x%x\n", entry->other_keyset);
        sal_printf("SRC_KEYf = 0x%x\n", entry->src_key);
        sal_printf("RSVDf = 0x%x\n", entry->rsvd);
        sal_printf("PV2LI_MAP_ENf = 0x%x\n", entry->pv2li_map_en);
        sal_printf("DEFAULT_SLIf = 0x%x\n", entry->default_sli);
        sal_printf("LI_MAP0f = 0x%x\n", entry->li_map0);
        sal_printf("LI_MAP0_ENf = 0x%x\n", entry->li_map0_en);
        sal_printf("LI_MAP1_ENf = 0x%x\n", entry->li_map1_en);
        sal_printf("LI_MAP0_DECAPf = 0x%x\n", entry->li_map0_decap);
        sal_printf("LI_MAP1_DECAPf = 0x%x\n", entry->li_map1_decap);
        sal_printf("SLIC_DECAPf = 0x%x\n", entry->slic_decap);
        sal_printf("PV_DECAPf = 0x%x\n", entry->pv_decap);
        sal_printf("LI_MAP1f = 0x%x\n", entry->li_map1);
    }
    sal_mutex_give(fpslict_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_kst_get
 * @par Description:
 *      Perform a read on the kst table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_kst_get(int unit, int index, kst_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(kst_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_KST_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_get: Failed reading table %s index %d rc %d\n",
                "kst", index, rc));
        sal_mutex_give(kst_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_KST_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_get: Failed register "
                "CB_IPP_KST_IA_WDATA_PART0 read\n"));
        sal_mutex_give(kst_mutex);
        return rc;
    }
    soc_CB_IPP_KST_IA_RDATA_PART0r_field_get(unit, &regval, 
        LBH_KEYf, &tmpval);
    entry->lbh_key = tmpval & 15;
    soc_CB_IPP_KST_IA_RDATA_PART0r_field_get(unit, &regval, 
        LBH_ENf, &tmpval);
    entry->lbh_en = tmpval & 1;
    soc_CB_IPP_KST_IA_RDATA_PART0r_field_get(unit, &regval, 
        CFP_KEY_ENf, &tmpval);
    entry->cfp_key_en = tmpval & 15;
    rc = REG_READ_CB_IPP_KST_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_get: Failed register "
                "CB_IPP_KST_IA_WDATA_PART1 read\n"));
        sal_mutex_give(kst_mutex);
        return rc;
    }
    soc_CB_IPP_KST_IA_RDATA_PART1r_field_get(unit, &regval, 
        DBID3f, &tmpval);
    entry->dbid3 = tmpval & 7;
    soc_CB_IPP_KST_IA_RDATA_PART1r_field_get(unit, &regval, 
        DBID0f, &tmpval);
    entry->dbid0 = tmpval & 7;
    soc_CB_IPP_KST_IA_RDATA_PART1r_field_get(unit, &regval, 
        CFP_KEY3f, &tmpval);
    entry->cfp_key3 = tmpval & 15;
    soc_CB_IPP_KST_IA_RDATA_PART1r_field_get(unit, &regval, 
        CFP_KEY2f, &tmpval);
    entry->cfp_key2 = tmpval & 15;
    soc_CB_IPP_KST_IA_RDATA_PART1r_field_get(unit, &regval, 
        CFP_KEY1f, &tmpval);
    entry->cfp_key1 = tmpval & 15;
    soc_CB_IPP_KST_IA_RDATA_PART1r_field_get(unit, &regval, 
        DBID2f, &tmpval);
    entry->dbid2 = tmpval & 7;
    soc_CB_IPP_KST_IA_RDATA_PART1r_field_get(unit, &regval, 
        CFP_KEY0f, &tmpval);
    entry->cfp_key0 = tmpval & 15;
    soc_CB_IPP_KST_IA_RDATA_PART1r_field_get(unit, &regval, 
        DBID1f, &tmpval);
    entry->dbid1 = tmpval & 7;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_KST_ID) {
        sal_printf("LBH_KEYf = 0x%x\n", entry->lbh_key);
        sal_printf("LBH_ENf = 0x%x\n", entry->lbh_en);
        sal_printf("CFP_KEY_ENf = 0x%x\n", entry->cfp_key_en);
        sal_printf("DBID3f = 0x%x\n", entry->dbid3);
        sal_printf("DBID0f = 0x%x\n", entry->dbid0);
        sal_printf("CFP_KEY3f = 0x%x\n", entry->cfp_key3);
        sal_printf("CFP_KEY2f = 0x%x\n", entry->cfp_key2);
        sal_printf("CFP_KEY1f = 0x%x\n", entry->cfp_key1);
        sal_printf("DBID2f = 0x%x\n", entry->dbid2);
        sal_printf("CFP_KEY0f = 0x%x\n", entry->cfp_key0);
        sal_printf("DBID1f = 0x%x\n", entry->dbid1);
    }
    sal_mutex_give(kst_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pqm_bucket_get
 * @par Description:
 *      Perform a read on the pqm_bucket table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_bucket_get(int unit, int index, pqm_bucket_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_bucket_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_BUCKET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_get: Failed reading table %s index %d rc %d\n",
                "pqm_bucket", index, rc));
        sal_mutex_give(pqm_bucket_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_BUCKET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_get: Failed register "
                "CB_PQM_BUCKET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pqm_bucket_mutex);
        return rc;
    }
    soc_CB_PQM_BUCKET_IA_RDATA_PART0r_field_get(unit, &regval, 
        BKTEf, &tmpval);
    entry->bkte = tmpval & 134217727;
    rc = REG_READ_CB_PQM_BUCKET_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_get: Failed register "
                "CB_PQM_BUCKET_IA_WDATA_PART1 read\n"));
        sal_mutex_give(pqm_bucket_mutex);
        return rc;
    }
    soc_CB_PQM_BUCKET_IA_RDATA_PART1r_field_get(unit, &regval, 
        BKTCf, &tmpval);
    entry->bktc = tmpval & 134217727;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PQM_BUCKET_ID) {
        sal_printf("BKTEf = 0x%x\n", entry->bkte);
        sal_printf("BKTCf = 0x%x\n", entry->bktc);
    }
    sal_mutex_give(pqm_bucket_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ghst_get
 * @par Description:
 *      Perform a read on the ghst table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghst_get(int unit, int index, ghst_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ghst_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHST_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_get: Failed reading table %s index %d rc %d\n",
                "ghst", index, rc));
        sal_mutex_give(ghst_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ITM_GHST_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_get: Failed register "
                "CB_ITM_GHST_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ghst_mutex);
        return rc;
    }
    soc_CB_ITM_GHST_IA_RDATA_PART0r_field_get(unit, &regval, 
        SEED_31_0f, &entry->seed_31_0);
    rc = REG_READ_CB_ITM_GHST_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_get: Failed register "
                "CB_ITM_GHST_IA_WDATA_PART1 read\n"));
        sal_mutex_give(ghst_mutex);
        return rc;
    }
    soc_CB_ITM_GHST_IA_RDATA_PART1r_field_get(unit, &regval, 
        SEED_63_32f, &entry->seed_63_32);
    rc = REG_READ_CB_ITM_GHST_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_get: Failed register "
                "CB_ITM_GHST_IA_WDATA_PART2 read\n"));
        sal_mutex_give(ghst_mutex);
        return rc;
    }
    soc_CB_ITM_GHST_IA_RDATA_PART2r_field_get(unit, &regval, 
        SEED_95_64f, &entry->seed_95_64);
    rc = REG_READ_CB_ITM_GHST_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_get: Failed register "
                "CB_ITM_GHST_IA_WDATA_PART3 read\n"));
        sal_mutex_give(ghst_mutex);
        return rc;
    }
    soc_CB_ITM_GHST_IA_RDATA_PART3r_field_get(unit, &regval, 
        SEED_113_96f, &tmpval);
    entry->seed_113_96 = tmpval & 262143;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_GHST_ID) {
        sal_printf("SEED_31_0f = 0x%x\n", entry->seed_31_0);
        sal_printf("SEED_63_32f = 0x%x\n", entry->seed_63_32);
        sal_printf("SEED_95_64f = 0x%x\n", entry->seed_95_64);
        sal_printf("SEED_113_96f = 0x%x\n", entry->seed_113_96);
    }
    sal_mutex_give(ghst_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_lpg2pg_get
 * @par Description:
 *      Perform a read on the lpg2pg table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2pg_get(int unit, int index, lpg2pg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lpg2pg_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_get: Failed reading table %s index %d rc %d\n",
                "lpg2pg", index, rc));
        sal_mutex_give(lpg2pg_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_LPG2PG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_get: Failed register "
                "CB_PQM_LPG2PG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(lpg2pg_mutex);
        return rc;
    }
    soc_CB_PQM_LPG2PG_IA_RDATA_PART0r_field_get(unit, &regval, 
        PGf, &tmpval);
    entry->pg = tmpval & 31;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_LPG2PG_ID) {
        sal_printf("PGf = 0x%x\n", entry->pg);
    }
    sal_mutex_give(lpg2pg_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_epgt_get
 * @par Description:
 *      Perform a read on the epgt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_epgt_get(int unit, int index, epgt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(epgt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPGT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_get: Failed reading table %s index %d rc %d\n",
                "epgt", index, rc));
        sal_mutex_give(epgt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_EPP_EPGT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_get: Failed register "
                "CB_EPP_EPGT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(epgt_mutex);
        return rc;
    }
    soc_CB_EPP_EPGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        MIRROR_TCf, &tmpval);
    entry->mirror_tc = tmpval & 7;
    soc_CB_EPP_EPGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        MIRRORf, &tmpval);
    entry->mirror = tmpval & 63;
    soc_CB_EPP_EPGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SAMPLEf, &tmpval);
    entry->sample = tmpval & 1023;
    soc_CB_EPP_EPGT_IA_RDATA_PART0r_field_get(unit, &regval, 
        MIRROR_DPf, &tmpval);
    entry->mirror_dp = tmpval & 3;
    rc = REG_READ_CB_EPP_EPGT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_get: Failed register "
                "CB_EPP_EPGT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(epgt_mutex);
        return rc;
    }
    soc_CB_EPP_EPGT_IA_RDATA_PART1r_field_get(unit, &regval, 
        MTUf, &tmpval);
    entry->mtu = tmpval & 16383;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_EPGT_ID) {
        sal_printf("MIRROR_TCf = 0x%x\n", entry->mirror_tc);
        sal_printf("MIRRORf = 0x%x\n", entry->mirror);
        sal_printf("SAMPLEf = 0x%x\n", entry->sample);
        sal_printf("MIRROR_DPf = 0x%x\n", entry->mirror_dp);
        sal_printf("MTUf = 0x%x\n", entry->mtu);
    }
    sal_mutex_give(epgt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_bmu_rscale_get
 * @par Description:
 *      Perform a read on the bmu_rscale table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_rscale_get(int unit, int index, bmu_rscale_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_rscale_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_RSCALE_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_get: Failed reading table %s index %d rc %d\n",
                "bmu_rscale", index, rc));
        sal_mutex_give(bmu_rscale_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_RSCALE_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_get: Failed register "
                "CB_BMU_RSCALE_IA_WDATA_PART0 read\n"));
        sal_mutex_give(bmu_rscale_mutex);
        return rc;
    }
    soc_CB_BMU_RSCALE_IA_RDATA_PART0r_field_get(unit, &regval, 
        SCALEf, &tmpval);
    entry->scale = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_BMU_RSCALE_ID) {
        sal_printf("SCALEf = 0x%x\n", entry->scale);
    }
    sal_mutex_give(bmu_rscale_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_lpg2ppfov_get
 * @par Description:
 *      Perform a read on the lpg2ppfov table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ppfov_get(int unit, int index, lpg2ppfov_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lpg2ppfov_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PPFOV_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_get: Failed reading table %s index %d rc %d\n",
                "lpg2ppfov", index, rc));
        sal_mutex_give(lpg2ppfov_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_LPG2PPFOV_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_get: Failed register "
                "CB_PQM_LPG2PPFOV_IA_WDATA_PART0 read\n"));
        sal_mutex_give(lpg2ppfov_mutex);
        return rc;
    }
    soc_CB_PQM_LPG2PPFOV_IA_RDATA_PART0r_field_get(unit, &regval, 
        PPFOVf, &tmpval);
    entry->ppfov = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_LPG2PPFOV_ID) {
        sal_printf("PPFOVf = 0x%x\n", entry->ppfov);
    }
    sal_mutex_give(lpg2ppfov_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_vsit_get
 * @par Description:
 *      Perform a read on the vsit table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_vsit_get(int unit, int index, vsit_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(vsit_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VSIT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_get: Failed reading table %s index %d rc %d\n",
                "vsit", index, rc));
        sal_mutex_give(vsit_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_VSIT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_get: Failed register "
                "CB_IPP_VSIT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(vsit_mutex);
        return rc;
    }
    soc_CB_IPP_VSIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DROP_ULFf, &tmpval);
    entry->drop_ulf = tmpval & 1;
    soc_CB_IPP_VSIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        LEARNf, &tmpval);
    entry->learn = tmpval & 3;
    soc_CB_IPP_VSIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        RSVD0f, &tmpval);
    entry->rsvd0 = tmpval & 7;
    soc_CB_IPP_VSIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DROP_SLFf, &tmpval);
    entry->drop_slf = tmpval & 1;
    soc_CB_IPP_VSIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        HIT_SMAC_IF_DMAC_MCASTf, &tmpval);
    entry->hit_smac_if_dmac_mcast = tmpval & 1;
    soc_CB_IPP_VSIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DROP_MLFf, &tmpval);
    entry->drop_mlf = tmpval & 1;
    soc_CB_IPP_VSIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        RSVD1f, &tmpval);
    entry->rsvd1 = tmpval & 7;
    soc_CB_IPP_VSIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        STGIDf, &tmpval);
    entry->stgid = tmpval & 127;
    soc_CB_IPP_VSIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DROP_BCASTf, &tmpval);
    entry->drop_bcast = tmpval & 1;
    rc = REG_READ_CB_IPP_VSIT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_get: Failed register "
                "CB_IPP_VSIT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(vsit_mutex);
        return rc;
    }
    soc_CB_IPP_VSIT_IA_RDATA_PART1r_field_get(unit, &regval, 
        PG_MAPf, &tmpval);
    entry->pg_map = tmpval & 65535;
    rc = REG_READ_CB_IPP_VSIT_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_get: Failed register "
                "CB_IPP_VSIT_IA_WDATA_PART2 read\n"));
        sal_mutex_give(vsit_mutex);
        return rc;
    }
    soc_CB_IPP_VSIT_IA_RDATA_PART2r_field_get(unit, &regval, 
        DLLIID_DGIDf, &tmpval);
    entry->dlliid_dgid = tmpval & 4095;
    soc_CB_IPP_VSIT_IA_RDATA_PART2r_field_get(unit, &regval, 
        WRED_ENAf, &tmpval);
    entry->wred_ena = tmpval & 1;
    soc_CB_IPP_VSIT_IA_RDATA_PART2r_field_get(unit, &regval, 
        DEFAULT_IS_MULTICASTf, &tmpval);
    entry->default_is_multicast = tmpval & 1;
    soc_CB_IPP_VSIT_IA_RDATA_PART2r_field_get(unit, &regval, 
        SLI_LPBK_ENAf, &tmpval);
    entry->sli_lpbk_ena = tmpval & 1;
    soc_CB_IPP_VSIT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ISO_MAPf, &tmpval);
    entry->iso_map = tmpval & 15;
    rc = REG_READ_CB_IPP_VSIT_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_get: Failed register "
                "CB_IPP_VSIT_IA_WDATA_PART3 read\n"));
        sal_mutex_give(vsit_mutex);
        return rc;
    }
    soc_CB_IPP_VSIT_IA_RDATA_PART3r_field_get(unit, &regval, 
        FIDf, &tmpval);
    entry->fid = tmpval & 4095;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_VSIT_ID) {
        sal_printf("DROP_ULFf = 0x%x\n", entry->drop_ulf);
        sal_printf("LEARNf = 0x%x\n", entry->learn);
        sal_printf("RSVD0f = 0x%x\n", entry->rsvd0);
        sal_printf("DROP_SLFf = 0x%x\n", entry->drop_slf);
        sal_printf("HIT_SMAC_IF_DMAC_MCASTf = 0x%x\n", entry->hit_smac_if_dmac_mcast);
        sal_printf("DROP_MLFf = 0x%x\n", entry->drop_mlf);
        sal_printf("RSVD1f = 0x%x\n", entry->rsvd1);
        sal_printf("STGIDf = 0x%x\n", entry->stgid);
        sal_printf("DROP_BCASTf = 0x%x\n", entry->drop_bcast);
        sal_printf("PG_MAPf = 0x%x\n", entry->pg_map);
        sal_printf("DLLIID_DGIDf = 0x%x\n", entry->dlliid_dgid);
        sal_printf("WRED_ENAf = 0x%x\n", entry->wred_ena);
        sal_printf("DEFAULT_IS_MULTICASTf = 0x%x\n", entry->default_is_multicast);
        sal_printf("SLI_LPBK_ENAf = 0x%x\n", entry->sli_lpbk_ena);
        sal_printf("ISO_MAPf = 0x%x\n", entry->iso_map);
        sal_printf("FIDf = 0x%x\n", entry->fid);
    }
    sal_mutex_give(vsit_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_qfccredit_get
 * @par Description:
 *      Perform a read on the qfccredit table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfccredit_get(int unit, int index, qfccredit_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(qfccredit_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCCREDIT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_get: Failed reading table %s index %d rc %d\n",
                "qfccredit", index, rc));
        sal_mutex_give(qfccredit_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_QFCCREDIT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_get: Failed register "
                "CB_PQM_QFCCREDIT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(qfccredit_mutex);
        return rc;
    }
    soc_CB_PQM_QFCCREDIT_IA_RDATA_PART0r_field_get(unit, &regval, 
        QFC_CREDITf, &tmpval);
    entry->qfc_credit = tmpval & 1023;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_QFCCREDIT_ID) {
        sal_printf("QFC_CREDITf = 0x%x\n", entry->qfc_credit);
    }
    sal_mutex_give(qfccredit_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_tet_get
 * @par Description:
 *      Perform a read on the tet table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_tet_get(int unit, int index, tet_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(tet_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_get: Failed reading table %s index %d rc %d\n",
                "tet", index, rc));
        sal_mutex_give(tet_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_EPP_TET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_get: Failed register "
                "CB_EPP_TET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(tet_mutex);
        return rc;
    }
    soc_CB_EPP_TET_IA_RDATA_PART0r_field_get(unit, &regval, 
        TAGf, &tmpval);
    entry->tag = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_TET_ID) {
        sal_printf("TAGf = 0x%x\n", entry->tag);
    }
    sal_mutex_give(tet_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ipp_pp2lpg_get
 * @par Description:
 *      Perform a read on the ipp_pp2lpg table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pp2lpg_get(int unit, int index, ipp_pp2lpg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_pp2lpg_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PP2LPG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_get: Failed reading table %s index %d rc %d\n",
                "ipp_pp2lpg", index, rc));
        sal_mutex_give(ipp_pp2lpg_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_PP2LPG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_get: Failed register "
                "CB_IPP_PP2LPG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ipp_pp2lpg_mutex);
        return rc;
    }
    soc_CB_IPP_PP2LPG_IA_RDATA_PART0r_field_get(unit, &regval, 
        PGIDf, &tmpval);
    entry->pgid = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_IPP_PP2LPG_ID) {
        sal_printf("PGIDf = 0x%x\n", entry->pgid);
    }
    sal_mutex_give(ipp_pp2lpg_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pqm_pptr_get
 * @par Description:
 *      Perform a read on the pqm_pptr table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pptr_get(int unit, int index, pqm_pptr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_pptr_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PPTR_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_get: Failed reading table %s index %d rc %d\n",
                "pqm_pptr", index, rc));
        sal_mutex_give(pqm_pptr_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_PPTR_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_get: Failed register "
                "CB_PQM_PPTR_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pqm_pptr_mutex);
        return rc;
    }
    soc_CB_PQM_PPTR_IA_RDATA_PART0r_field_get(unit, &regval, 
        POINTERf, &tmpval);
    entry->pointer = tmpval & 255;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PQM_PPTR_ID) {
        sal_printf("POINTERf = 0x%x\n", entry->pointer);
    }
    sal_mutex_give(pqm_pptr_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_bmu_pmon_get
 * @par Description:
 *      Perform a read on the bmu_pmon table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pmon_get(int unit, int index, bmu_pmon_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_pmon_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PMON_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_get: Failed reading table %s index %d rc %d\n",
                "bmu_pmon", index, rc));
        sal_mutex_give(bmu_pmon_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_PMON_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_get: Failed register "
                "CB_BMU_PMON_IA_WDATA_PART0 read\n"));
        sal_mutex_give(bmu_pmon_mutex);
        return rc;
    }
    soc_CB_BMU_PMON_IA_RDATA_PART0r_field_get(unit, &regval, 
        COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_READ_CB_BMU_PMON_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_get: Failed register "
                "CB_BMU_PMON_IA_WDATA_PART1 read\n"));
        sal_mutex_give(bmu_pmon_mutex);
        return rc;
    }
    soc_CB_BMU_PMON_IA_RDATA_PART1r_field_get(unit, &regval, 
        COUNT_MSBSf, &entry->count_msbs);
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_BMU_PMON_ID) {
        sal_printf("COUNT_LSBSf = 0x%x\n", entry->count_lsbs);
        sal_printf("COUNT_MSBSf = 0x%x\n", entry->count_msbs);
    }
    sal_mutex_give(bmu_pmon_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_etct_get
 * @par Description:
 *      Perform a read on the etct table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_etct_get(int unit, int index, etct_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(etct_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ETCT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_get: Failed reading table %s index %d rc %d\n",
                "etct", index, rc));
        sal_mutex_give(etct_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ETM_ETCT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_get: Failed register "
                "CB_ETM_ETCT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(etct_mutex);
        return rc;
    }
    soc_CB_ETM_ETCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        PRIMAP_NDXf, &tmpval);
    entry->primap_ndx = tmpval & 31;
    soc_CB_ETM_ETCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        PCPf, &tmpval);
    entry->pcp = tmpval & 7;
    soc_CB_ETM_ETCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DEIf, &tmpval);
    entry->dei = tmpval & 1;
    soc_CB_ETM_ETCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        OPCODEf, &tmpval);
    entry->opcode = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ETCT_ID) {
        sal_printf("PRIMAP_NDXf = 0x%x\n", entry->primap_ndx);
        sal_printf("PCPf = 0x%x\n", entry->pcp);
        sal_printf("DEIf = 0x%x\n", entry->dei);
        sal_printf("OPCODEf = 0x%x\n", entry->opcode);
    }
    sal_mutex_give(etct_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h0_get
 * @par Description:
 *      Perform a read on the arlfm1_ght_h0 table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h0_get(int unit, int index, arlfm1_ght_h0_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(arlfm1_ght_h0_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H0_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_get: Failed reading table %s index %d rc %d\n",
                "arlfm1_ght_h0", index, rc));
        sal_mutex_give(arlfm1_ght_h0_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_get: Failed register "
                "CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART0 read\n"));
        sal_mutex_give(arlfm1_ght_h0_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART0r_field_get(unit, &regval, 
        GHT_KEY_31_0_ARLFM1_MAC_LOf, &entry->ght_key_31_0_arlfm1_mac_lo);
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_get: Failed register "
                "CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1 read\n"));
        sal_mutex_give(arlfm1_ght_h0_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART1r_field_get(unit, &regval, 
        GHT_KEY_47_32_ARLFM1_MAC_HI_15_0f, &tmpval);
    entry->ght_key_47_32_arlfm1_mac_hi_15_0 = tmpval & 65535;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART1r_field_get(unit, &regval, 
        GHT_KEY_59_48_ARLFM1_FID_11_0f, &tmpval);
    entry->ght_key_59_48_arlfm1_fid_11_0 = tmpval & 4095;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART1r_field_get(unit, &regval, 
        GHT_KEY_63_62_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    entry->ght_key_63_62_arlfm1_upd_ctrl_1_0 = tmpval & 3;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART1r_field_get(unit, &regval, 
        GHT_KEY_61_60_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    entry->ght_key_61_60_arlfm1_fwd_ctrl_1_0 = tmpval & 3;
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_get: Failed register "
                "CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART2 read\n"));
        sal_mutex_give(arlfm1_ght_h0_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART2r_field_get(unit, &regval, 
        GHT_KEY_95_64_ARLFM1_MAC_LOf, &entry->ght_key_95_64_arlfm1_mac_lo);
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_get: Failed register "
                "CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3 read\n"));
        sal_mutex_give(arlfm1_ght_h0_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART3r_field_get(unit, &regval, 
        GHT_KEY_111_96_ARLFM1_MAC_HIf, &tmpval);
    entry->ght_key_111_96_arlfm1_mac_hi = tmpval & 65535;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART3r_field_get(unit, &regval, 
        GHT_N_VSI_11_10_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    entry->ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0 = tmpval & 3;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART3r_field_get(unit, &regval, 
        GHT_N_VSI_9_0_KEY_113_112_ARLFM1_FIDf, &tmpval);
    entry->ght_n_vsi_9_0_key_113_112_arlfm1_fid = tmpval & 4095;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_RDATA_PART3r_field_get(unit, &regval, 
        GHT_VALID_LITYPE_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    entry->ght_valid_litype_arlfm1_upd_ctrl_1_0 = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ARLFM1_GHT_H0_ID) {
        sal_printf("GHT_KEY_31_0_ARLFM1_MAC_LOf = 0x%x\n", entry->ght_key_31_0_arlfm1_mac_lo);
        sal_printf("GHT_KEY_47_32_ARLFM1_MAC_HI_15_0f = 0x%x\n", entry->ght_key_47_32_arlfm1_mac_hi_15_0);
        sal_printf("GHT_KEY_59_48_ARLFM1_FID_11_0f = 0x%x\n", entry->ght_key_59_48_arlfm1_fid_11_0);
        sal_printf("GHT_KEY_63_62_ARLFM1_UPD_CTRL_1_0f = 0x%x\n", entry->ght_key_63_62_arlfm1_upd_ctrl_1_0);
        sal_printf("GHT_KEY_61_60_ARLFM1_FWD_CTRL_1_0f = 0x%x\n", entry->ght_key_61_60_arlfm1_fwd_ctrl_1_0);
        sal_printf("GHT_KEY_95_64_ARLFM1_MAC_LOf = 0x%x\n", entry->ght_key_95_64_arlfm1_mac_lo);
        sal_printf("GHT_KEY_111_96_ARLFM1_MAC_HIf = 0x%x\n", entry->ght_key_111_96_arlfm1_mac_hi);
        sal_printf("GHT_N_VSI_11_10_ARLFM1_FWD_CTRL_1_0f = 0x%x\n", entry->ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0);
        sal_printf("GHT_N_VSI_9_0_KEY_113_112_ARLFM1_FIDf = 0x%x\n", entry->ght_n_vsi_9_0_key_113_112_arlfm1_fid);
        sal_printf("GHT_VALID_LITYPE_ARLFM1_UPD_CTRL_1_0f = 0x%x\n", entry->ght_valid_litype_arlfm1_upd_ctrl_1_0);
    }
    sal_mutex_give(arlfm1_ght_h0_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_cfp_pmon_get
 * @par Description:
 *      Perform a read on the cfp_pmon table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pmon_get(int unit, int index, cfp_pmon_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_pmon_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PMON_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_get: Failed reading table %s index %d rc %d\n",
                "cfp_pmon", index, rc));
        sal_mutex_give(cfp_pmon_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_PMON_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_get: Failed register "
                "CB_CFP_PMON_IA_WDATA_PART0 read\n"));
        sal_mutex_give(cfp_pmon_mutex);
        return rc;
    }
    soc_CB_CFP_PMON_IA_RDATA_PART0r_field_get(unit, &regval, 
        COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_READ_CB_CFP_PMON_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_get: Failed register "
                "CB_CFP_PMON_IA_WDATA_PART1 read\n"));
        sal_mutex_give(cfp_pmon_mutex);
        return rc;
    }
    soc_CB_CFP_PMON_IA_RDATA_PART1r_field_get(unit, &regval, 
        COUNT_MSBSf, &entry->count_msbs);
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_CFP_PMON_ID) {
        sal_printf("COUNT_LSBSf = 0x%x\n", entry->count_lsbs);
        sal_printf("COUNT_MSBSf = 0x%x\n", entry->count_msbs);
    }
    sal_mutex_give(cfp_pmon_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_max_config_get
 * @par Description:
 *      Perform a read on the max_config table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_max_config_get(int unit, int index, max_config_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(max_config_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MAX_CONFIG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_get: Failed reading table %s index %d rc %d\n",
                "max_config", index, rc));
        sal_mutex_give(max_config_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQS_MAX_CONFIG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_get: Failed register "
                "CB_PQS_MAX_CONFIG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(max_config_mutex);
        return rc;
    }
    soc_CB_PQS_MAX_CONFIG_IA_RDATA_PART0r_field_get(unit, &regval, 
        MAX_TX_BYTESf, &tmpval);
    entry->max_tx_bytes = tmpval & 65535;
    soc_CB_PQS_MAX_CONFIG_IA_RDATA_PART0r_field_get(unit, &regval, 
        MAX_TX_PKTSf, &tmpval);
    entry->max_tx_pkts = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_MAX_CONFIG_ID) {
        sal_printf("MAX_TX_BYTESf = 0x%x\n", entry->max_tx_bytes);
        sal_printf("MAX_TX_PKTSf = 0x%x\n", entry->max_tx_pkts);
    }
    sal_mutex_give(max_config_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_bmu_profile_get
 * @par Description:
 *      Perform a read on the bmu_profile table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_profile_get(int unit, int index, bmu_profile_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_profile_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PROFILE_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_get: Failed reading table %s index %d rc %d\n",
                "bmu_profile", index, rc));
        sal_mutex_give(bmu_profile_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_PROFILE_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_get: Failed register "
                "CB_BMU_PROFILE_IA_WDATA_PART0 read\n"));
        sal_mutex_give(bmu_profile_mutex);
        return rc;
    }
    soc_CB_BMU_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CBS_EXPf, &tmpval);
    entry->cbs_exp = tmpval & 31;
    soc_CB_BMU_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CBS_MANTISSAf, &tmpval);
    entry->cbs_mantissa = tmpval & 127;
    soc_CB_BMU_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CIR_MANTISSAf, &tmpval);
    entry->cir_mantissa = tmpval & 2047;
    soc_CB_BMU_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CIR_EXPf, &tmpval);
    entry->cir_exp = tmpval & 31;
    rc = REG_READ_CB_BMU_PROFILE_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_get: Failed register "
                "CB_BMU_PROFILE_IA_WDATA_PART1 read\n"));
        sal_mutex_give(bmu_profile_mutex);
        return rc;
    }
    soc_CB_BMU_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EIR_EXPf, &tmpval);
    entry->eir_exp = tmpval & 31;
    soc_CB_BMU_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EBS_EXPf, &tmpval);
    entry->ebs_exp = tmpval & 31;
    soc_CB_BMU_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EIR_MANTISSAf, &tmpval);
    entry->eir_mantissa = tmpval & 2047;
    soc_CB_BMU_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EBS_MANTISSAf, &tmpval);
    entry->ebs_mantissa = tmpval & 127;
    rc = REG_READ_CB_BMU_PROFILE_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_get: Failed register "
                "CB_BMU_PROFILE_IA_WDATA_PART2 read\n"));
        sal_mutex_give(bmu_profile_mutex);
        return rc;
    }
    soc_CB_BMU_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        DROP_ON_REDf, &tmpval);
    entry->drop_on_red = tmpval & 1;
    soc_CB_BMU_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        PKT_MODEf, &tmpval);
    entry->pkt_mode = tmpval & 1;
    soc_CB_BMU_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BKTC_STRICTf, &tmpval);
    entry->bktc_strict = tmpval & 1;
    soc_CB_BMU_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BKTE_STRICTf, &tmpval);
    entry->bkte_strict = tmpval & 1;
    soc_CB_BMU_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        CFf, &tmpval);
    entry->cf = tmpval & 1;
    soc_CB_BMU_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        RFC2698f, &tmpval);
    entry->rfc2698 = tmpval & 1;
    soc_CB_BMU_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BLINDf, &tmpval);
    entry->blind = tmpval & 1;
    soc_CB_BMU_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        AVB_MODEf, &tmpval);
    entry->avb_mode = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_BMU_PROFILE_ID) {
        sal_printf("CBS_EXPf = 0x%x\n", entry->cbs_exp);
        sal_printf("CBS_MANTISSAf = 0x%x\n", entry->cbs_mantissa);
        sal_printf("CIR_MANTISSAf = 0x%x\n", entry->cir_mantissa);
        sal_printf("CIR_EXPf = 0x%x\n", entry->cir_exp);
        sal_printf("EIR_EXPf = 0x%x\n", entry->eir_exp);
        sal_printf("EBS_EXPf = 0x%x\n", entry->ebs_exp);
        sal_printf("EIR_MANTISSAf = 0x%x\n", entry->eir_mantissa);
        sal_printf("EBS_MANTISSAf = 0x%x\n", entry->ebs_mantissa);
        sal_printf("DROP_ON_REDf = 0x%x\n", entry->drop_on_red);
        sal_printf("PKT_MODEf = 0x%x\n", entry->pkt_mode);
        sal_printf("BKTC_STRICTf = 0x%x\n", entry->bktc_strict);
        sal_printf("BKTE_STRICTf = 0x%x\n", entry->bkte_strict);
        sal_printf("CFf = 0x%x\n", entry->cf);
        sal_printf("RFC2698f = 0x%x\n", entry->rfc2698);
        sal_printf("BLINDf = 0x%x\n", entry->blind);
        sal_printf("AVB_MODEf = 0x%x\n", entry->avb_mode);
    }
    sal_mutex_give(bmu_profile_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pv2li_get
 * @par Description:
 *      Perform a read on the pv2li table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pv2li_get(int unit, int index, pv2li_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pv2li_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PV2LI_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_get: Failed reading table %s index %d rc %d\n",
                "pv2li", index, rc));
        sal_mutex_give(pv2li_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_PV2LI_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_get: Failed register "
                "CB_IPP_PV2LI_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pv2li_mutex);
        return rc;
    }
    soc_CB_IPP_PV2LI_IA_RDATA_PART0r_field_get(unit, &regval, 
        PG_MAPf, &tmpval);
    entry->pg_map = tmpval & 65535;
    rc = REG_READ_CB_IPP_PV2LI_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_get: Failed register "
                "CB_IPP_PV2LI_IA_WDATA_PART1 read\n"));
        sal_mutex_give(pv2li_mutex);
        return rc;
    }
    soc_CB_IPP_PV2LI_IA_RDATA_PART1r_field_get(unit, &regval, 
        VSIf, &tmpval);
    entry->vsi = tmpval & 4095;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PV2LI_ID) {
        sal_printf("PG_MAPf = 0x%x\n", entry->pg_map);
        sal_printf("VSIf = 0x%x\n", entry->vsi);
    }
    sal_mutex_give(pv2li_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ipp_rscale_get
 * @par Description:
 *      Perform a read on the ipp_rscale table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_rscale_get(int unit, int index, ipp_rscale_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_rscale_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_RSCALE_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_get: Failed reading table %s index %d rc %d\n",
                "ipp_rscale", index, rc));
        sal_mutex_give(ipp_rscale_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_RSCALE_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_get: Failed register "
                "CB_IPP_RSCALE_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ipp_rscale_mutex);
        return rc;
    }
    soc_CB_IPP_RSCALE_IA_RDATA_PART0r_field_get(unit, &regval, 
        SCALEf, &tmpval);
    entry->scale = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_IPP_RSCALE_ID) {
        sal_printf("SCALEf = 0x%x\n", entry->scale);
    }
    sal_mutex_give(ipp_rscale_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pqm_pmon_get
 * @par Description:
 *      Perform a read on the pqm_pmon table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pmon_get(int unit, int index, pqm_pmon_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_pmon_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PMON_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_get: Failed reading table %s index %d rc %d\n",
                "pqm_pmon", index, rc));
        sal_mutex_give(pqm_pmon_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_PMON_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_get: Failed register "
                "CB_PQM_PMON_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pqm_pmon_mutex);
        return rc;
    }
    soc_CB_PQM_PMON_IA_RDATA_PART0r_field_get(unit, &regval, 
        COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_READ_CB_PQM_PMON_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_get: Failed register "
                "CB_PQM_PMON_IA_WDATA_PART1 read\n"));
        sal_mutex_give(pqm_pmon_mutex);
        return rc;
    }
    soc_CB_PQM_PMON_IA_RDATA_PART1r_field_get(unit, &regval, 
        COUNT_MSBSf, &entry->count_msbs);
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PQM_PMON_ID) {
        sal_printf("COUNT_LSBSf = 0x%x\n", entry->count_lsbs);
        sal_printf("COUNT_MSBSf = 0x%x\n", entry->count_msbs);
    }
    sal_mutex_give(pqm_pmon_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ikft_get
 * @par Description:
 *      Perform a read on the ikft table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ikft_get(int unit, int index, ikft_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ikft_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IKFT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_get: Failed reading table %s index %d rc %d\n",
                "ikft", index, rc));
        sal_mutex_give(ikft_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_IKFT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_get: Failed register "
                "CB_IPP_IKFT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ikft_mutex);
        return rc;
    }
    soc_CB_IPP_IKFT_IA_RDATA_PART0r_field_get(unit, &regval, 
        HTYPEf, &tmpval);
    entry->htype = tmpval & 255;
    rc = REG_READ_CB_IPP_IKFT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_get: Failed register "
                "CB_IPP_IKFT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(ikft_mutex);
        return rc;
    }
    soc_CB_IPP_IKFT_IA_RDATA_PART1r_field_get(unit, &regval, 
        HPOSNf, &tmpval);
    entry->hposn = tmpval & 3;
    soc_CB_IPP_IKFT_IA_RDATA_PART1r_field_get(unit, &regval, 
        OFFSETf, &tmpval);
    entry->offset = tmpval & 2047;
    soc_CB_IPP_IKFT_IA_RDATA_PART1r_field_get(unit, &regval, 
        LENGTHf, &tmpval);
    entry->length = tmpval & 127;
    rc = REG_READ_CB_IPP_IKFT_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_get: Failed register "
                "CB_IPP_IKFT_IA_WDATA_PART2 read\n"));
        sal_mutex_give(ikft_mutex);
        return rc;
    }
    soc_CB_IPP_IKFT_IA_RDATA_PART2r_field_get(unit, &regval, 
        KEYf, &tmpval);
    entry->key = tmpval & 65535;
    soc_CB_IPP_IKFT_IA_RDATA_PART2r_field_get(unit, &regval, 
        EXISTSf, &tmpval);
    entry->exists = tmpval & 65535;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_IKFT_ID) {
        sal_printf("HTYPEf = 0x%x\n", entry->htype);
        sal_printf("HPOSNf = 0x%x\n", entry->hposn);
        sal_printf("OFFSETf = 0x%x\n", entry->offset);
        sal_printf("LENGTHf = 0x%x\n", entry->length);
        sal_printf("KEYf = 0x%x\n", entry->key);
        sal_printf("EXISTSf = 0x%x\n", entry->exists);
    }
    sal_mutex_give(ikft_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h1_get
 * @par Description:
 *      Perform a read on the arlfm1_ght_h1 table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h1_get(int unit, int index, arlfm1_ght_h1_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(arlfm1_ght_h1_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H1_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_get: Failed reading table %s index %d rc %d\n",
                "arlfm1_ght_h1", index, rc));
        sal_mutex_give(arlfm1_ght_h1_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_get: Failed register "
                "CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART0 read\n"));
        sal_mutex_give(arlfm1_ght_h1_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART0r_field_get(unit, &regval, 
        GHT_KEY_31_0_ARLFM1_MAC_LOf, &entry->ght_key_31_0_arlfm1_mac_lo);
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_get: Failed register "
                "CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1 read\n"));
        sal_mutex_give(arlfm1_ght_h1_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART1r_field_get(unit, &regval, 
        GHT_KEY_47_32_ARLFM1_MAC_HI_15_0f, &tmpval);
    entry->ght_key_47_32_arlfm1_mac_hi_15_0 = tmpval & 65535;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART1r_field_get(unit, &regval, 
        GHT_KEY_59_48_ARLFM1_FID_11_0f, &tmpval);
    entry->ght_key_59_48_arlfm1_fid_11_0 = tmpval & 4095;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART1r_field_get(unit, &regval, 
        GHT_KEY_63_62_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    entry->ght_key_63_62_arlfm1_upd_ctrl_1_0 = tmpval & 3;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART1r_field_get(unit, &regval, 
        GHT_KEY_61_60_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    entry->ght_key_61_60_arlfm1_fwd_ctrl_1_0 = tmpval & 3;
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_get: Failed register "
                "CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART2 read\n"));
        sal_mutex_give(arlfm1_ght_h1_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART2r_field_get(unit, &regval, 
        GHT_KEY_95_64_ARLFM1_MAC_LOf, &entry->ght_key_95_64_arlfm1_mac_lo);
    rc = REG_READ_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_get: Failed register "
                "CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3 read\n"));
        sal_mutex_give(arlfm1_ght_h1_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART3r_field_get(unit, &regval, 
        GHT_KEY_111_96_ARLFM1_MAC_HIf, &tmpval);
    entry->ght_key_111_96_arlfm1_mac_hi = tmpval & 65535;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART3r_field_get(unit, &regval, 
        GHT_N_VSI_11_10_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    entry->ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0 = tmpval & 3;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART3r_field_get(unit, &regval, 
        GHT_N_VSI_9_0_KEY_113_112_ARLFM1_FIDf, &tmpval);
    entry->ght_n_vsi_9_0_key_113_112_arlfm1_fid = tmpval & 4095;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_RDATA_PART3r_field_get(unit, &regval, 
        GHT_VALID_LITYPE_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    entry->ght_valid_litype_arlfm1_upd_ctrl_1_0 = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ARLFM1_GHT_H1_ID) {
        sal_printf("GHT_KEY_31_0_ARLFM1_MAC_LOf = 0x%x\n", entry->ght_key_31_0_arlfm1_mac_lo);
        sal_printf("GHT_KEY_47_32_ARLFM1_MAC_HI_15_0f = 0x%x\n", entry->ght_key_47_32_arlfm1_mac_hi_15_0);
        sal_printf("GHT_KEY_59_48_ARLFM1_FID_11_0f = 0x%x\n", entry->ght_key_59_48_arlfm1_fid_11_0);
        sal_printf("GHT_KEY_63_62_ARLFM1_UPD_CTRL_1_0f = 0x%x\n", entry->ght_key_63_62_arlfm1_upd_ctrl_1_0);
        sal_printf("GHT_KEY_61_60_ARLFM1_FWD_CTRL_1_0f = 0x%x\n", entry->ght_key_61_60_arlfm1_fwd_ctrl_1_0);
        sal_printf("GHT_KEY_95_64_ARLFM1_MAC_LOf = 0x%x\n", entry->ght_key_95_64_arlfm1_mac_lo);
        sal_printf("GHT_KEY_111_96_ARLFM1_MAC_HIf = 0x%x\n", entry->ght_key_111_96_arlfm1_mac_hi);
        sal_printf("GHT_N_VSI_11_10_ARLFM1_FWD_CTRL_1_0f = 0x%x\n", entry->ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0);
        sal_printf("GHT_N_VSI_9_0_KEY_113_112_ARLFM1_FIDf = 0x%x\n", entry->ght_n_vsi_9_0_key_113_112_arlfm1_fid);
        sal_printf("GHT_VALID_LITYPE_ARLFM1_UPD_CTRL_1_0f = 0x%x\n", entry->ght_valid_litype_arlfm1_upd_ctrl_1_0);
    }
    sal_mutex_give(arlfm1_ght_h1_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_epmt_get
 * @par Description:
 *      Perform a read on the epmt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_epmt_get(int unit, int index, epmt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(epmt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPMT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_get: Failed reading table %s index %d rc %d\n",
                "epmt", index, rc));
        sal_mutex_give(epmt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_EPP_EPMT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_get: Failed register "
                "CB_EPP_EPMT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(epmt_mutex);
        return rc;
    }
    soc_CB_EPP_EPMT_IA_RDATA_PART0r_field_get(unit, &regval, 
        PMT_DATAf, &entry->pmt_data);
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_EPMT_ID) {
        sal_printf("PMT_DATAf = 0x%x\n", entry->pmt_data);
    }
    sal_mutex_give(epmt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_epp_bmu_tx_reorder_req_lmt_get
 * @par Description:
 *      Perform a read on the epp_bmu_tx_reorder_req_lmt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_bmu_tx_reorder_req_lmt_get(int unit, int index, epp_bmu_tx_reorder_req_lmt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(epp_bmu_tx_reorder_req_lmt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_get: Failed reading table %s index %d rc %d\n",
                "epp_bmu_tx_reorder_req_lmt", index, rc));
        sal_mutex_give(epp_bmu_tx_reorder_req_lmt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_get: Failed register "
                "CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(epp_bmu_tx_reorder_req_lmt_mutex);
        return rc;
    }
    soc_CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_RDATA_PART0r_field_get(unit, &regval, 
        PER_PORT_REQ_LIMITf, &tmpval);
    entry->per_port_req_limit = tmpval & 63;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID) {
        sal_printf("PER_PORT_REQ_LIMITf = 0x%x\n", entry->per_port_req_limit);
    }
    sal_mutex_give(epp_bmu_tx_reorder_req_lmt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_bmu_pptr_get
 * @par Description:
 *      Perform a read on the bmu_pptr table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pptr_get(int unit, int index, bmu_pptr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_pptr_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PPTR_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_get: Failed reading table %s index %d rc %d\n",
                "bmu_pptr", index, rc));
        sal_mutex_give(bmu_pptr_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_BMU_PPTR_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_get: Failed register "
                "CB_BMU_PPTR_IA_WDATA_PART0 read\n"));
        sal_mutex_give(bmu_pptr_mutex);
        return rc;
    }
    soc_CB_BMU_PPTR_IA_RDATA_PART0r_field_get(unit, &regval, 
        POINTERf, &tmpval);
    entry->pointer = tmpval & 255;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_BMU_PPTR_ID) {
        sal_printf("POINTERf = 0x%x\n", entry->pointer);
    }
    sal_mutex_give(bmu_pptr_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ert_get
 * @par Description:
 *      Perform a read on the ert table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ert_get(int unit, int index, ert_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ert_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ERT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_get: Failed reading table %s index %d rc %d\n",
                "ert", index, rc));
        sal_mutex_give(ert_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ETM_ERT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_get: Failed register "
                "CB_ETM_ERT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ert_mutex);
        return rc;
    }
    soc_CB_ETM_ERT_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP10f, &tmpval);
    entry->encap10 = tmpval & 255;
    soc_CB_ETM_ERT_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP9f, &tmpval);
    entry->encap9 = tmpval & 255;
    soc_CB_ETM_ERT_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP11f, &tmpval);
    entry->encap11 = tmpval & 255;
    soc_CB_ETM_ERT_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP8f, &tmpval);
    entry->encap8 = tmpval & 255;
    rc = REG_READ_CB_ETM_ERT_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_get: Failed register "
                "CB_ETM_ERT_IA_WDATA_PART1 read\n"));
        sal_mutex_give(ert_mutex);
        return rc;
    }
    soc_CB_ETM_ERT_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP4f, &tmpval);
    entry->encap4 = tmpval & 255;
    soc_CB_ETM_ERT_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP5f, &tmpval);
    entry->encap5 = tmpval & 255;
    soc_CB_ETM_ERT_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP7f, &tmpval);
    entry->encap7 = tmpval & 255;
    soc_CB_ETM_ERT_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP6f, &tmpval);
    entry->encap6 = tmpval & 255;
    rc = REG_READ_CB_ETM_ERT_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_get: Failed register "
                "CB_ETM_ERT_IA_WDATA_PART2 read\n"));
        sal_mutex_give(ert_mutex);
        return rc;
    }
    soc_CB_ETM_ERT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ENCAP2f, &tmpval);
    entry->encap2 = tmpval & 255;
    soc_CB_ETM_ERT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ENCAP3f, &tmpval);
    entry->encap3 = tmpval & 255;
    soc_CB_ETM_ERT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ENCAP0f, &tmpval);
    entry->encap0 = tmpval & 255;
    soc_CB_ETM_ERT_IA_RDATA_PART2r_field_get(unit, &regval, 
        ENCAP1f, &tmpval);
    entry->encap1 = tmpval & 255;
    rc = REG_READ_CB_ETM_ERT_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_get: Failed register "
                "CB_ETM_ERT_IA_WDATA_PART3 read\n"));
        sal_mutex_give(ert_mutex);
        return rc;
    }
    soc_CB_ETM_ERT_IA_RDATA_PART3r_field_get(unit, &regval, 
        FULLf, &tmpval);
    entry->full = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ERT_ID) {
        sal_printf("ENCAP10f = 0x%x\n", entry->encap10);
        sal_printf("ENCAP9f = 0x%x\n", entry->encap9);
        sal_printf("ENCAP11f = 0x%x\n", entry->encap11);
        sal_printf("ENCAP8f = 0x%x\n", entry->encap8);
        sal_printf("ENCAP4f = 0x%x\n", entry->encap4);
        sal_printf("ENCAP5f = 0x%x\n", entry->encap5);
        sal_printf("ENCAP7f = 0x%x\n", entry->encap7);
        sal_printf("ENCAP6f = 0x%x\n", entry->encap6);
        sal_printf("ENCAP2f = 0x%x\n", entry->encap2);
        sal_printf("ENCAP3f = 0x%x\n", entry->encap3);
        sal_printf("ENCAP0f = 0x%x\n", entry->encap0);
        sal_printf("ENCAP1f = 0x%x\n", entry->encap1);
        sal_printf("FULLf = 0x%x\n", entry->full);
    }
    sal_mutex_give(ert_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_action_get
 * @par Description:
 *      Perform a read on the action table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_action_get(int unit, int index, action_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(action_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ACTION_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_get: Failed reading table %s index %d rc %d\n",
                "action", index, rc));
        sal_mutex_give(action_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_ACTION_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_get: Failed register "
                "CB_CFP_ACTION_IA_WDATA_PART0 read\n"));
        sal_mutex_give(action_mutex);
        return rc;
    }
    soc_CB_CFP_ACTION_IA_RDATA_PART0r_field_get(unit, &regval, 
        IPF_LEARN_DISABLEf, &tmpval);
    entry->ipf_learn_disable = tmpval & 1;
    soc_CB_CFP_ACTION_IA_RDATA_PART0r_field_get(unit, &regval, 
        IPF_TRAP_OFFSETf, &tmpval);
    entry->ipf_trap_offset = tmpval & 15;
    soc_CB_CFP_ACTION_IA_RDATA_PART0r_field_get(unit, &regval, 
        IPF_MIRRORf, &tmpval);
    entry->ipf_mirror = tmpval & 63;
    soc_CB_CFP_ACTION_IA_RDATA_PART0r_field_get(unit, &regval, 
        IPF_CHANGE_TCf, &tmpval);
    entry->ipf_change_tc = tmpval & 1;
    soc_CB_CFP_ACTION_IA_RDATA_PART0r_field_get(unit, &regval, 
        IPF_TCf, &tmpval);
    entry->ipf_tc = tmpval & 7;
    rc = REG_READ_CB_CFP_ACTION_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_get: Failed register "
                "CB_CFP_ACTION_IA_WDATA_PART1 read\n"));
        sal_mutex_give(action_mutex);
        return rc;
    }
    soc_CB_CFP_ACTION_IA_RDATA_PART1r_field_get(unit, &regval, 
        IPF_DLIID_DGID_SLIIDf, &tmpval);
    entry->ipf_dliid_dgid_sliid = tmpval & 262143;
    soc_CB_CFP_ACTION_IA_RDATA_PART1r_field_get(unit, &regval, 
        IPF_CHANGE_FWDf, &tmpval);
    entry->ipf_change_fwd = tmpval & 7;
    soc_CB_CFP_ACTION_IA_RDATA_PART1r_field_get(unit, &regval, 
        IPF_CFP_DECAPf, &tmpval);
    entry->ipf_cfp_decap = tmpval & 15;
    rc = REG_READ_CB_CFP_ACTION_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_get: Failed register "
                "CB_CFP_ACTION_IA_WDATA_PART2 read\n"));
        sal_mutex_give(action_mutex);
        return rc;
    }
    soc_CB_CFP_ACTION_IA_RDATA_PART2r_field_get(unit, &regval, 
        OPF_TCf, &tmpval);
    entry->opf_tc = tmpval & 7;
    soc_CB_CFP_ACTION_IA_RDATA_PART2r_field_get(unit, &regval, 
        OPF_TRAP_OFFSETf, &tmpval);
    entry->opf_trap_offset = tmpval & 15;
    soc_CB_CFP_ACTION_IA_RDATA_PART2r_field_get(unit, &regval, 
        OPF_LEARN_DISABLEf, &tmpval);
    entry->opf_learn_disable = tmpval & 1;
    soc_CB_CFP_ACTION_IA_RDATA_PART2r_field_get(unit, &regval, 
        OPF_CHANGE_TCf, &tmpval);
    entry->opf_change_tc = tmpval & 1;
    soc_CB_CFP_ACTION_IA_RDATA_PART2r_field_get(unit, &regval, 
        OPF_MIRRORf, &tmpval);
    entry->opf_mirror = tmpval & 63;
    rc = REG_READ_CB_CFP_ACTION_IA_RDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_get: Failed register "
                "CB_CFP_ACTION_IA_WDATA_PART3 read\n"));
        sal_mutex_give(action_mutex);
        return rc;
    }
    soc_CB_CFP_ACTION_IA_RDATA_PART3r_field_get(unit, &regval, 
        OPF_CHANGE_FWDf, &tmpval);
    entry->opf_change_fwd = tmpval & 7;
    soc_CB_CFP_ACTION_IA_RDATA_PART3r_field_get(unit, &regval, 
        OPF_DLIID_DGID_SLIIDf, &tmpval);
    entry->opf_dliid_dgid_sliid = tmpval & 262143;
    soc_CB_CFP_ACTION_IA_RDATA_PART3r_field_get(unit, &regval, 
        OPF_CFP_DECAPf, &tmpval);
    entry->opf_cfp_decap = tmpval & 15;
    rc = REG_READ_CB_CFP_ACTION_IA_RDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_get: Failed register "
                "CB_CFP_ACTION_IA_WDATA_PART4 read\n"));
        sal_mutex_give(action_mutex);
        return rc;
    }
    soc_CB_CFP_ACTION_IA_RDATA_PART4r_field_get(unit, &regval, 
        DPf, &tmpval);
    entry->dp = tmpval & 3;
    soc_CB_CFP_ACTION_IA_RDATA_PART4r_field_get(unit, &regval, 
        COUNTER_MODEf, &tmpval);
    entry->counter_mode = tmpval & 3;
    soc_CB_CFP_ACTION_IA_RDATA_PART4r_field_get(unit, &regval, 
        METERf, &tmpval);
    entry->meter = tmpval & 511;
    soc_CB_CFP_ACTION_IA_RDATA_PART4r_field_get(unit, &regval, 
        OVERRIDEf, &tmpval);
    entry->override = tmpval & 1;
    soc_CB_CFP_ACTION_IA_RDATA_PART4r_field_get(unit, &regval, 
        CHANGE_DPf, &tmpval);
    entry->change_dp = tmpval & 1;
    soc_CB_CFP_ACTION_IA_RDATA_PART4r_field_get(unit, &regval, 
        SLI_LPBK_ENAf, &tmpval);
    entry->sli_lpbk_ena = tmpval & 1;
    soc_CB_CFP_ACTION_IA_RDATA_PART4r_field_get(unit, &regval, 
        DLF_OVERRIDEf, &tmpval);
    entry->dlf_override = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_ACTION_ID) {
        sal_printf("IPF_LEARN_DISABLEf = 0x%x\n", entry->ipf_learn_disable);
        sal_printf("IPF_TRAP_OFFSETf = 0x%x\n", entry->ipf_trap_offset);
        sal_printf("IPF_MIRRORf = 0x%x\n", entry->ipf_mirror);
        sal_printf("IPF_CHANGE_TCf = 0x%x\n", entry->ipf_change_tc);
        sal_printf("IPF_TCf = 0x%x\n", entry->ipf_tc);
        sal_printf("IPF_DLIID_DGID_SLIIDf = 0x%x\n", entry->ipf_dliid_dgid_sliid);
        sal_printf("IPF_CHANGE_FWDf = 0x%x\n", entry->ipf_change_fwd);
        sal_printf("IPF_CFP_DECAPf = 0x%x\n", entry->ipf_cfp_decap);
        sal_printf("OPF_TCf = 0x%x\n", entry->opf_tc);
        sal_printf("OPF_TRAP_OFFSETf = 0x%x\n", entry->opf_trap_offset);
        sal_printf("OPF_LEARN_DISABLEf = 0x%x\n", entry->opf_learn_disable);
        sal_printf("OPF_CHANGE_TCf = 0x%x\n", entry->opf_change_tc);
        sal_printf("OPF_MIRRORf = 0x%x\n", entry->opf_mirror);
        sal_printf("OPF_CHANGE_FWDf = 0x%x\n", entry->opf_change_fwd);
        sal_printf("OPF_DLIID_DGID_SLIIDf = 0x%x\n", entry->opf_dliid_dgid_sliid);
        sal_printf("OPF_CFP_DECAPf = 0x%x\n", entry->opf_cfp_decap);
        sal_printf("DPf = 0x%x\n", entry->dp);
        sal_printf("COUNTER_MODEf = 0x%x\n", entry->counter_mode);
        sal_printf("METERf = 0x%x\n", entry->meter);
        sal_printf("OVERRIDEf = 0x%x\n", entry->override);
        sal_printf("CHANGE_DPf = 0x%x\n", entry->change_dp);
        sal_printf("SLI_LPBK_ENAf = 0x%x\n", entry->sli_lpbk_ena);
        sal_printf("DLF_OVERRIDEf = 0x%x\n", entry->dlf_override);
    }
    sal_mutex_give(action_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_rpslict_get
 * @par Description:
 *      Perform a read on the rpslict table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpslict_get(int unit, int index, rpslict_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(rpslict_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPSLICT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_get: Failed reading table %s index %d rc %d\n",
                "rpslict", index, rc));
        sal_mutex_give(rpslict_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_RPSLICT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_get: Failed register "
                "CB_IPP_RPSLICT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(rpslict_mutex);
        return rc;
    }
    soc_CB_IPP_RPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        EARLY_ACKf, &tmpval);
    entry->early_ack = tmpval & 1;
    soc_CB_IPP_RPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        USE_TCf, &tmpval);
    entry->use_tc = tmpval & 3;
    soc_CB_IPP_RPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        USE_DPf, &tmpval);
    entry->use_dp = tmpval & 3;
    soc_CB_IPP_RPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DEFAULT_TCf, &tmpval);
    entry->default_tc = tmpval & 7;
    soc_CB_IPP_RPSLICT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DEFAULT_DPf, &tmpval);
    entry->default_dp = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_RPSLICT_ID) {
        sal_printf("EARLY_ACKf = 0x%x\n", entry->early_ack);
        sal_printf("USE_TCf = 0x%x\n", entry->use_tc);
        sal_printf("USE_DPf = 0x%x\n", entry->use_dp);
        sal_printf("DEFAULT_TCf = 0x%x\n", entry->default_tc);
        sal_printf("DEFAULT_DPf = 0x%x\n", entry->default_dp);
    }
    sal_mutex_give(rpslict_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_slictecc_get
 * @par Description:
 *      Perform a read on the slictecc table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_slictecc_get(int unit, int index, slictecc_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(slictecc_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICTECC_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_get: Failed reading table %s index %d rc %d\n",
                "slictecc", index, rc));
        sal_mutex_give(slictecc_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_SLICTECC_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_get: Failed register "
                "CB_IPP_SLICTECC_IA_WDATA_PART0 read\n"));
        sal_mutex_give(slictecc_mutex);
        return rc;
    }
    soc_CB_IPP_SLICTECC_IA_RDATA_PART0r_field_get(unit, &regval, 
        ECCf, &tmpval);
    entry->ecc = tmpval & 1023;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_SLICTECC_ID) {
        sal_printf("ECCf = 0x%x\n", entry->ecc);
    }
    sal_mutex_give(slictecc_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_litet_get
 * @par Description:
 *      Perform a read on the litet table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_litet_get(int unit, int index, litet_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(litet_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LITET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_get: Failed reading table %s index %d rc %d\n",
                "litet", index, rc));
        sal_mutex_give(litet_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_LITET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_get: Failed register "
                "CB_PQM_LITET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(litet_mutex);
        return rc;
    }
    soc_CB_PQM_LITET_IA_RDATA_PART0r_field_get(unit, &regval, 
        TX_ENAf, &tmpval);
    entry->tx_ena = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_LITET_ID) {
        sal_printf("TX_ENAf = 0x%x\n", entry->tx_ena);
    }
    sal_mutex_give(litet_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_tecc_get
 * @par Description:
 *      Perform a read on the tecc table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_tecc_get(int unit, int index, tecc_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(tecc_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TECC_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_get: Failed reading table %s index %d rc %d\n",
                "tecc", index, rc));
        sal_mutex_give(tecc_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_TECC_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_get: Failed register "
                "CB_CFP_TECC_IA_WDATA_PART0 read\n"));
        sal_mutex_give(tecc_mutex);
        return rc;
    }
    soc_CB_CFP_TECC_IA_RDATA_PART0r_field_get(unit, &regval, 
        ECCf, &tmpval);
    entry->ecc = tmpval & 511;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_TECC_ID) {
        sal_printf("ECCf = 0x%x\n", entry->ecc);
    }
    sal_mutex_give(tecc_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_cfp_pptr_get
 * @par Description:
 *      Perform a read on the cfp_pptr table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pptr_get(int unit, int index, cfp_pptr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_pptr_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PPTR_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_get: Failed reading table %s index %d rc %d\n",
                "cfp_pptr", index, rc));
        sal_mutex_give(cfp_pptr_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_PPTR_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_get: Failed register "
                "CB_CFP_PPTR_IA_WDATA_PART0 read\n"));
        sal_mutex_give(cfp_pptr_mutex);
        return rc;
    }
    soc_CB_CFP_PPTR_IA_RDATA_PART0r_field_get(unit, &regval, 
        POINTERf, &tmpval);
    entry->pointer = tmpval & 255;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_CFP_PPTR_ID) {
        sal_printf("POINTERf = 0x%x\n", entry->pointer);
    }
    sal_mutex_give(cfp_pptr_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_wrt_get
 * @par Description:
 *      Perform a read on the wrt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_wrt_get(int unit, int index, wrt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(wrt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WRT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_get: Failed reading table %s index %d rc %d\n",
                "wrt", index, rc));
        sal_mutex_give(wrt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_CFP_WRT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_get: Failed register "
                "CB_CFP_WRT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(wrt_mutex);
        return rc;
    }
    soc_CB_CFP_WRT_IA_RDATA_PART0r_field_get(unit, &regval, 
        WIDE_RULE_ENTRYf, &tmpval);
    entry->wide_rule_entry = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_WRT_ID) {
        sal_printf("WIDE_RULE_ENTRYf = 0x%x\n", entry->wide_rule_entry);
    }
    sal_mutex_give(wrt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_wpt_get
 * @par Description:
 *      Perform a read on the wpt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_wpt_get(int unit, int index, wpt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(wpt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WPT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_get: Failed reading table %s index %d rc %d\n",
                "wpt", index, rc));
        sal_mutex_give(wpt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_WPT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_get: Failed register "
                "CB_PQM_WPT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(wpt_mutex);
        return rc;
    }
    soc_CB_PQM_WPT_IA_RDATA_PART0r_field_get(unit, &regval, 
        GAINf, &tmpval);
    entry->gain = tmpval & 7;
    soc_CB_PQM_WPT_IA_RDATA_PART0r_field_get(unit, &regval, 
        SCALEf, &tmpval);
    entry->scale = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_WPT_ID) {
        sal_printf("GAINf = 0x%x\n", entry->gain);
        sal_printf("SCALEf = 0x%x\n", entry->scale);
    }
    sal_mutex_give(wpt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_dliet_get
 * @par Description:
 *      Perform a read on the dliet table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_dliet_get(int unit, int index, dliet_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(dliet_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLIET_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_get: Failed reading table %s index %d rc %d\n",
                "dliet", index, rc));
        sal_mutex_give(dliet_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ETM_DLIET_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_get: Failed register "
                "CB_ETM_DLIET_IA_WDATA_PART0 read\n"));
        sal_mutex_give(dliet_mutex);
        return rc;
    }
    soc_CB_ETM_DLIET_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP4f, &tmpval);
    entry->encap4 = tmpval & 255;
    soc_CB_ETM_DLIET_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP5f, &tmpval);
    entry->encap5 = tmpval & 255;
    soc_CB_ETM_DLIET_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP7f, &tmpval);
    entry->encap7 = tmpval & 255;
    soc_CB_ETM_DLIET_IA_RDATA_PART0r_field_get(unit, &regval, 
        ENCAP6f, &tmpval);
    entry->encap6 = tmpval & 255;
    rc = REG_READ_CB_ETM_DLIET_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_get: Failed register "
                "CB_ETM_DLIET_IA_WDATA_PART1 read\n"));
        sal_mutex_give(dliet_mutex);
        return rc;
    }
    soc_CB_ETM_DLIET_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP2f, &tmpval);
    entry->encap2 = tmpval & 255;
    soc_CB_ETM_DLIET_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP3f, &tmpval);
    entry->encap3 = tmpval & 255;
    soc_CB_ETM_DLIET_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP0f, &tmpval);
    entry->encap0 = tmpval & 255;
    soc_CB_ETM_DLIET_IA_RDATA_PART1r_field_get(unit, &regval, 
        ENCAP1f, &tmpval);
    entry->encap1 = tmpval & 255;
    rc = REG_READ_CB_ETM_DLIET_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_get: Failed register "
                "CB_ETM_DLIET_IA_WDATA_PART2 read\n"));
        sal_mutex_give(dliet_mutex);
        return rc;
    }
    soc_CB_ETM_DLIET_IA_RDATA_PART2r_field_get(unit, &regval, 
        UC_ENCAP_PTRf, &tmpval);
    entry->uc_encap_ptr = tmpval & 255;
    soc_CB_ETM_DLIET_IA_RDATA_PART2r_field_get(unit, &regval, 
        MC_ENCAP_PTRf, &tmpval);
    entry->mc_encap_ptr = tmpval & 255;
    soc_CB_ETM_DLIET_IA_RDATA_PART2r_field_get(unit, &regval, 
        FULLf, &tmpval);
    entry->full = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_DLIET_ID) {
        sal_printf("ENCAP4f = 0x%x\n", entry->encap4);
        sal_printf("ENCAP5f = 0x%x\n", entry->encap5);
        sal_printf("ENCAP7f = 0x%x\n", entry->encap7);
        sal_printf("ENCAP6f = 0x%x\n", entry->encap6);
        sal_printf("ENCAP2f = 0x%x\n", entry->encap2);
        sal_printf("ENCAP3f = 0x%x\n", entry->encap3);
        sal_printf("ENCAP0f = 0x%x\n", entry->encap0);
        sal_printf("ENCAP1f = 0x%x\n", entry->encap1);
        sal_printf("UC_ENCAP_PTRf = 0x%x\n", entry->uc_encap_ptr);
        sal_printf("MC_ENCAP_PTRf = 0x%x\n", entry->mc_encap_ptr);
        sal_printf("FULLf = 0x%x\n", entry->full);
    }
    sal_mutex_give(dliet_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pglct_get
 * @par Description:
 *      Perform a read on the pglct table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pglct_get(int unit, int index, pglct_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pglct_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGLCT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_get: Failed reading table %s index %d rc %d\n",
                "pglct", index, rc));
        sal_mutex_give(pglct_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ITM_PGLCT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_get: Failed register "
                "CB_ITM_PGLCT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pglct_mutex);
        return rc;
    }
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DISABLE_UPDATE_STATICf, &tmpval);
    entry->disable_update_static = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        COPY_UNKNOWN_SMACf, &tmpval);
    entry->copy_unknown_smac = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        PEND_LEARNf, &tmpval);
    entry->pend_learn = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        COPY_UPDATEf, &tmpval);
    entry->copy_update = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DISABLE_UPDATE_PENDINGf, &tmpval);
    entry->disable_update_pending = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        COPY_UPDATE_STATICf, &tmpval);
    entry->copy_update_static = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        COPY_OVERLIMITf, &tmpval);
    entry->copy_overlimit = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DISABLE_UPDATEf, &tmpval);
    entry->disable_update = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DISABLE_LEARNf, &tmpval);
    entry->disable_learn = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        LEARN_LIMITf, &tmpval);
    entry->learn_limit = tmpval & 32767;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        VALID_FOR_N_TYPEf, &tmpval);
    entry->valid_for_n_type = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DROP_OVERLIMITf, &tmpval);
    entry->drop_overlimit = tmpval & 1;
    soc_CB_ITM_PGLCT_IA_RDATA_PART0r_field_get(unit, &regval, 
        COPY_UPDATE_PENDINGf, &tmpval);
    entry->copy_update_pending = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PGLCT_ID) {
        sal_printf("DISABLE_UPDATE_STATICf = 0x%x\n", entry->disable_update_static);
        sal_printf("COPY_UNKNOWN_SMACf = 0x%x\n", entry->copy_unknown_smac);
        sal_printf("PEND_LEARNf = 0x%x\n", entry->pend_learn);
        sal_printf("COPY_UPDATEf = 0x%x\n", entry->copy_update);
        sal_printf("DISABLE_UPDATE_PENDINGf = 0x%x\n", entry->disable_update_pending);
        sal_printf("COPY_UPDATE_STATICf = 0x%x\n", entry->copy_update_static);
        sal_printf("COPY_OVERLIMITf = 0x%x\n", entry->copy_overlimit);
        sal_printf("DISABLE_UPDATEf = 0x%x\n", entry->disable_update);
        sal_printf("DISABLE_LEARNf = 0x%x\n", entry->disable_learn);
        sal_printf("LEARN_LIMITf = 0x%x\n", entry->learn_limit);
        sal_printf("VALID_FOR_N_TYPEf = 0x%x\n", entry->valid_for_n_type);
        sal_printf("DROP_OVERLIMITf = 0x%x\n", entry->drop_overlimit);
        sal_printf("COPY_UPDATE_PENDINGf = 0x%x\n", entry->copy_update_pending);
    }
    sal_mutex_give(pglct_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_lpg2ap_get
 * @par Description:
 *      Perform a read on the lpg2ap table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ap_get(int unit, int index, lpg2ap_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lpg2ap_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2AP_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_get: Failed reading table %s index %d rc %d\n",
                "lpg2ap", index, rc));
        sal_mutex_give(lpg2ap_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_LPG2AP_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_get: Failed register "
                "CB_PQM_LPG2AP_IA_WDATA_PART0 read\n"));
        sal_mutex_give(lpg2ap_mutex);
        return rc;
    }
    soc_CB_PQM_LPG2AP_IA_RDATA_PART0r_field_get(unit, &regval, 
        ADM_PROFILEf, &tmpval);
    entry->adm_profile = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_LPG2AP_ID) {
        sal_printf("ADM_PROFILEf = 0x%x\n", entry->adm_profile);
    }
    sal_mutex_give(lpg2ap_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pqm_profile_get
 * @par Description:
 *      Perform a read on the pqm_profile table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_profile_get(int unit, int index, pqm_profile_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_profile_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PROFILE_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_get: Failed reading table %s index %d rc %d\n",
                "pqm_profile", index, rc));
        sal_mutex_give(pqm_profile_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_PROFILE_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_get: Failed register "
                "CB_PQM_PROFILE_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pqm_profile_mutex);
        return rc;
    }
    soc_CB_PQM_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CBS_EXPf, &tmpval);
    entry->cbs_exp = tmpval & 31;
    soc_CB_PQM_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CBS_MANTISSAf, &tmpval);
    entry->cbs_mantissa = tmpval & 127;
    soc_CB_PQM_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CIR_MANTISSAf, &tmpval);
    entry->cir_mantissa = tmpval & 2047;
    soc_CB_PQM_PROFILE_IA_RDATA_PART0r_field_get(unit, &regval, 
        CIR_EXPf, &tmpval);
    entry->cir_exp = tmpval & 31;
    rc = REG_READ_CB_PQM_PROFILE_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_get: Failed register "
                "CB_PQM_PROFILE_IA_WDATA_PART1 read\n"));
        sal_mutex_give(pqm_profile_mutex);
        return rc;
    }
    soc_CB_PQM_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EIR_EXPf, &tmpval);
    entry->eir_exp = tmpval & 31;
    soc_CB_PQM_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EBS_EXPf, &tmpval);
    entry->ebs_exp = tmpval & 31;
    soc_CB_PQM_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EIR_MANTISSAf, &tmpval);
    entry->eir_mantissa = tmpval & 2047;
    soc_CB_PQM_PROFILE_IA_RDATA_PART1r_field_get(unit, &regval, 
        EBS_MANTISSAf, &tmpval);
    entry->ebs_mantissa = tmpval & 127;
    rc = REG_READ_CB_PQM_PROFILE_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_get: Failed register "
                "CB_PQM_PROFILE_IA_WDATA_PART2 read\n"));
        sal_mutex_give(pqm_profile_mutex);
        return rc;
    }
    soc_CB_PQM_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        DROP_ON_REDf, &tmpval);
    entry->drop_on_red = tmpval & 1;
    soc_CB_PQM_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        PKT_MODEf, &tmpval);
    entry->pkt_mode = tmpval & 1;
    soc_CB_PQM_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BKTC_STRICTf, &tmpval);
    entry->bktc_strict = tmpval & 1;
    soc_CB_PQM_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BKTE_STRICTf, &tmpval);
    entry->bkte_strict = tmpval & 1;
    soc_CB_PQM_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        CFf, &tmpval);
    entry->cf = tmpval & 1;
    soc_CB_PQM_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        RFC2698f, &tmpval);
    entry->rfc2698 = tmpval & 1;
    soc_CB_PQM_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        BLINDf, &tmpval);
    entry->blind = tmpval & 1;
    soc_CB_PQM_PROFILE_IA_RDATA_PART2r_field_get(unit, &regval, 
        AVB_MODEf, &tmpval);
    entry->avb_mode = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PQM_PROFILE_ID) {
        sal_printf("CBS_EXPf = 0x%x\n", entry->cbs_exp);
        sal_printf("CBS_MANTISSAf = 0x%x\n", entry->cbs_mantissa);
        sal_printf("CIR_MANTISSAf = 0x%x\n", entry->cir_mantissa);
        sal_printf("CIR_EXPf = 0x%x\n", entry->cir_exp);
        sal_printf("EIR_EXPf = 0x%x\n", entry->eir_exp);
        sal_printf("EBS_EXPf = 0x%x\n", entry->ebs_exp);
        sal_printf("EIR_MANTISSAf = 0x%x\n", entry->eir_mantissa);
        sal_printf("EBS_MANTISSAf = 0x%x\n", entry->ebs_mantissa);
        sal_printf("DROP_ON_REDf = 0x%x\n", entry->drop_on_red);
        sal_printf("PKT_MODEf = 0x%x\n", entry->pkt_mode);
        sal_printf("BKTC_STRICTf = 0x%x\n", entry->bktc_strict);
        sal_printf("BKTE_STRICTf = 0x%x\n", entry->bkte_strict);
        sal_printf("CFf = 0x%x\n", entry->cf);
        sal_printf("RFC2698f = 0x%x\n", entry->rfc2698);
        sal_printf("BLINDf = 0x%x\n", entry->blind);
        sal_printf("AVB_MODEf = 0x%x\n", entry->avb_mode);
    }
    sal_mutex_give(pqm_profile_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_cpmt_get
 * @par Description:
 *      Perform a read on the cpmt table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_cpmt_get(int unit, int index, cpmt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cpmt_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CPMT_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_get: Failed reading table %s index %d rc %d\n",
                "cpmt", index, rc));
        sal_mutex_give(cpmt_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_IPP_CPMT_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_get: Failed register "
                "CB_IPP_CPMT_IA_WDATA_PART0 read\n"));
        sal_mutex_give(cpmt_mutex);
        return rc;
    }
    soc_CB_IPP_CPMT_IA_RDATA_PART0r_field_get(unit, &regval, 
        TCf, &tmpval);
    entry->tc = tmpval & 7;
    soc_CB_IPP_CPMT_IA_RDATA_PART0r_field_get(unit, &regval, 
        DPf, &tmpval);
    entry->dp = tmpval & 3;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_CPMT_ID) {
        sal_printf("TCf = 0x%x\n", entry->tc);
        sal_printf("DPf = 0x%x\n", entry->dp);
    }
    sal_mutex_give(cpmt_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_pqm_pp2lpg_get
 * @par Description:
 *      Perform a read on the pqm_pp2lpg table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pp2lpg_get(int unit, int index, pqm_pp2lpg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_pp2lpg_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PP2LPG_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_get: Failed reading table %s index %d rc %d\n",
                "pqm_pp2lpg", index, rc));
        sal_mutex_give(pqm_pp2lpg_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_PQM_PP2LPG_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_get: Failed register "
                "CB_PQM_PP2LPG_IA_WDATA_PART0 read\n"));
        sal_mutex_give(pqm_pp2lpg_mutex);
        return rc;
    }
    soc_CB_PQM_PP2LPG_IA_RDATA_PART0r_field_get(unit, &regval, 
        PGIDf, &tmpval);
    entry->pgid = tmpval & 15;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_PQM_PP2LPG_ID) {
        sal_printf("PGIDf = 0x%x\n", entry->pgid);
    }
    sal_mutex_give(pqm_pp2lpg_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_ofarlfm_get
 * @par Description:
 *      Perform a read on the ofarlfm table, get the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index :  index of entry in table to be read
 *    @param [out] entry :  pointer to buffer where entry will be copied
 * 
 *     @return SOC_E_NONE on success
 *     @return SOC_E_xxxx on failure
 */
int
soc_robo2_ofarlfm_get(int unit, int index, ofarlfm_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status = 0;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_get: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ofarlfm_mutex, sal_mutex_FOREVER);

    /* Initiate table read */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_OFARLFM_ID,
             ROBO2_IA_OP_TABLE_READ, index, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_get: Failed reading table %s index %d rc %d\n",
                "ofarlfm", index, rc));
        sal_mutex_give(ofarlfm_mutex);
        return rc;
    }
    
    /* Parse and process entry */
    rc = REG_READ_CB_ITM_OFARLFM_IA_RDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_get: Failed register "
                "CB_ITM_OFARLFM_IA_WDATA_PART0 read\n"));
        sal_mutex_give(ofarlfm_mutex);
        return rc;
    }
    soc_CB_ITM_OFARLFM_IA_RDATA_PART0r_field_get(unit, &regval, 
        MAC_LOf, &entry->mac_lo);
    rc = REG_READ_CB_ITM_OFARLFM_IA_RDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_get: Failed register "
                "CB_ITM_OFARLFM_IA_WDATA_PART1 read\n"));
        sal_mutex_give(ofarlfm_mutex);
        return rc;
    }
    soc_CB_ITM_OFARLFM_IA_RDATA_PART1r_field_get(unit, &regval, 
        FIDf, &tmpval);
    entry->fid = tmpval & 4095;
    soc_CB_ITM_OFARLFM_IA_RDATA_PART1r_field_get(unit, &regval, 
        UPD_CTRLf, &tmpval);
    entry->upd_ctrl = tmpval & 3;
    soc_CB_ITM_OFARLFM_IA_RDATA_PART1r_field_get(unit, &regval, 
        MAC_HIf, &tmpval);
    entry->mac_hi = tmpval & 65535;
    soc_CB_ITM_OFARLFM_IA_RDATA_PART1r_field_get(unit, &regval, 
        FWD_CTRLf, &tmpval);
    entry->fwd_ctrl = tmpval & 3;
    rc = REG_READ_CB_ITM_OFARLFM_IA_RDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_get: Failed register "
                "CB_ITM_OFARLFM_IA_WDATA_PART2 read\n"));
        sal_mutex_give(ofarlfm_mutex);
        return rc;
    }
    soc_CB_ITM_OFARLFM_IA_RDATA_PART2r_field_get(unit, &regval, 
        VALIDf, &tmpval);
    entry->valid = tmpval & 3;
    soc_CB_ITM_OFARLFM_IA_RDATA_PART2r_field_get(unit, &regval, 
        DSTf, &tmpval);
    entry->dst = tmpval & 2047;
    soc_CB_ITM_OFARLFM_IA_RDATA_PART2r_field_get(unit, &regval, 
        DST_TYPEf, &tmpval);
    entry->dst_type = tmpval & 3;
    soc_CB_ITM_OFARLFM_IA_RDATA_PART2r_field_get(unit, &regval, 
        HITf, &tmpval);
    entry->hit = tmpval & 1;
    /* Put prints to dump */
    if (table_dump_tid == ROBO2_TABLE_OFARLFM_ID) {
        sal_printf("MAC_LOf = 0x%x\n", entry->mac_lo);
        sal_printf("FIDf = 0x%x\n", entry->fid);
        sal_printf("UPD_CTRLf = 0x%x\n", entry->upd_ctrl);
        sal_printf("MAC_HIf = 0x%x\n", entry->mac_hi);
        sal_printf("FWD_CTRLf = 0x%x\n", entry->fwd_ctrl);
        sal_printf("VALIDf = 0x%x\n", entry->valid);
        sal_printf("DSTf = 0x%x\n", entry->dst);
        sal_printf("DST_TYPEf = 0x%x\n", entry->dst_type);
        sal_printf("HITf = 0x%x\n", entry->hit);
    }
    sal_mutex_give(ofarlfm_mutex);
    return rc;
}


/**
 * @par Function: 
 *      soc_robo2_tct_set
 * @par Description:
 *      Perform a write on the tct table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tct_set(int unit, int index, tct_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(tct_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->drop;
    soc_CB_IPP_TCT_IA_WDATA_PART0r_field_set(unit, &regval,
        DROPf, &tmpval);
    tmpval = entry->term;
    soc_CB_IPP_TCT_IA_WDATA_PART0r_field_set(unit, &regval,
        TERMf, &tmpval);
    tmpval = entry->trap_group;
    soc_CB_IPP_TCT_IA_WDATA_PART0r_field_set(unit, &regval,
        TRAP_GROUPf, &tmpval);
    rc = REG_WRITE_CB_IPP_TCT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_set: Failed writing CB_IPP_TCT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(tct_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TCT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "tct", index, rc, *status));
    }
    sal_mutex_give(tct_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpt_set
 * @par Description:
 *      Perform a write on the rpt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpt_set(int unit, int index, rpt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(rpt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->source;
    soc_CB_IPP_RPT_IA_WDATA_PART0r_field_set(unit, &regval,
        SOURCEf, &tmpval);
    rc = REG_WRITE_CB_IPP_RPT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_set: Failed writing CB_IPP_RPT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(rpt_mutex);
        return rc;
    }
    tmpval = entry->hi;
    soc_CB_IPP_RPT_IA_WDATA_PART1r_field_set(unit, &regval,
        HIf, &tmpval);
    tmpval = entry->lo;
    soc_CB_IPP_RPT_IA_WDATA_PART1r_field_set(unit, &regval,
        LOf, &tmpval);
    rc = REG_WRITE_CB_IPP_RPT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_set: Failed writing CB_IPP_RPT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(rpt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "rpt", index, rc, *status));
    }
    sal_mutex_give(rpt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pgt_set
 * @par Description:
 *      Perform a write on the pgt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pgt_set(int unit, int index, pgt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pgt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->pppoe_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        PPPOE_ENf, &tmpval);
    tmpval = entry->itag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        ITAG_ENf, &tmpval);
    tmpval = entry->tag_parse_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        TAG_PARSE_ENf, &tmpval);
    tmpval = entry->ipv4_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        IPV4_ENf, &tmpval);
    tmpval = entry->slic_map_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        SLIC_MAP_ENf, &tmpval);
    tmpval = entry->ctag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        CTAG_ENf, &tmpval);
    tmpval = entry->soft_tag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        SOFT_TAG_ENf, &tmpval);
    tmpval = entry->mcmpls_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        MCMPLS_ENf, &tmpval);
    tmpval = entry->metadata_len;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        METADATA_LENf, &tmpval);
    tmpval = entry->llc_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        LLC_ENf, &tmpval);
    tmpval = entry->ptp_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        PTP_ENf, &tmpval);
    tmpval = entry->etag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        ETAG_ENf, &tmpval);
    tmpval = entry->stag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        STAG_ENf, &tmpval);
    tmpval = entry->ipv6_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        IPV6_ENf, &tmpval);
    tmpval = entry->tlv_parse_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        TLV_PARSE_ENf, &tmpval);
    tmpval = entry->arp_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        ARP_ENf, &tmpval);
    tmpval = entry->ucmpls_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        UCMPLS_ENf, &tmpval);
    tmpval = entry->hdr_words_m1;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
        HDR_WORDS_M1f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    tmpval = entry->len0;
    soc_CB_IPP_PGT_IA_WDATA_PART1r_field_set(unit, &regval,
        LEN0f, &tmpval);
    tmpval = entry->proto1;
    soc_CB_IPP_PGT_IA_WDATA_PART1r_field_set(unit, &regval,
        PROTO1f, &tmpval);
    tmpval = entry->proto0;
    soc_CB_IPP_PGT_IA_WDATA_PART1r_field_set(unit, &regval,
        PROTO0f, &tmpval);
    tmpval = entry->len1;
    soc_CB_IPP_PGT_IA_WDATA_PART1r_field_set(unit, &regval,
        LEN1f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    tmpval = entry->arb4;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        ARB4f, &tmpval);
    tmpval = entry->arb1;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        ARB1f, &tmpval);
    tmpval = entry->arb7;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        ARB7f, &tmpval);
    tmpval = entry->arb3;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        ARB3f, &tmpval);
    tmpval = entry->src2;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        SRC2f, &tmpval);
    tmpval = entry->arb2;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        ARB2f, &tmpval);
    tmpval = entry->src0;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        SRC0f, &tmpval);
    tmpval = entry->src1;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        SRC1f, &tmpval);
    tmpval = entry->arb0;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        ARB0f, &tmpval);
    tmpval = entry->arb6;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        ARB6f, &tmpval);
    tmpval = entry->arb5;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
        ARB5f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    tmpval = entry->pri_base0;
    soc_CB_IPP_PGT_IA_WDATA_PART3r_field_set(unit, &regval,
        PRI_BASE0f, &tmpval);
    tmpval = entry->default_tc;
    soc_CB_IPP_PGT_IA_WDATA_PART3r_field_set(unit, &regval,
        DEFAULT_TCf, &tmpval);
    tmpval = entry->default_dp;
    soc_CB_IPP_PGT_IA_WDATA_PART3r_field_set(unit, &regval,
        DEFAULT_DPf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    tmpval = entry->pri_base1;
    soc_CB_IPP_PGT_IA_WDATA_PART4r_field_set(unit, &regval,
        PRI_BASE1f, &tmpval);
    tmpval = entry->pri_base2;
    soc_CB_IPP_PGT_IA_WDATA_PART4r_field_set(unit, &regval,
        PRI_BASE2f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART4 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    tmpval = entry->fcd3;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
        FCD3f, &tmpval);
    tmpval = entry->fcd4;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
        FCD4f, &tmpval);
    tmpval = entry->fcd2;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
        FCD2f, &tmpval);
    tmpval = entry->fcd1;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
        FCD1f, &tmpval);
    tmpval = entry->fcd5;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
        FCD5f, &tmpval);
    tmpval = entry->fcd6;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
        FCD6f, &tmpval);
    tmpval = entry->fcd7;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
        FCD7f, &tmpval);
    tmpval = entry->fcd0;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
        FCD0f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART5 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    tmpval = entry->mirror;
    soc_CB_IPP_PGT_IA_WDATA_PART6r_field_set(unit, &regval,
        MIRRORf, &tmpval);
    tmpval = entry->pepper;
    soc_CB_IPP_PGT_IA_WDATA_PART6r_field_set(unit, &regval,
        PEPPERf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART6 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    tmpval = entry->vid_src;
    soc_CB_IPP_PGT_IA_WDATA_PART7r_field_set(unit, &regval,
        VID_SRCf, &tmpval);
    tmpval = entry->default_vid;
    soc_CB_IPP_PGT_IA_WDATA_PART7r_field_set(unit, &regval,
        DEFAULT_VIDf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART7r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART7 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    tmpval = entry->default_sli;
    soc_CB_IPP_PGT_IA_WDATA_PART8r_field_set(unit, &regval,
        DEFAULT_SLIf, &tmpval);
    tmpval = entry->default_slicid;
    soc_CB_IPP_PGT_IA_WDATA_PART8r_field_set(unit, &regval,
        DEFAULT_SLICIDf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART8r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART8 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }
    tmpval = entry->dfp_en;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
        DFP_ENf, &tmpval);
    tmpval = entry->drop_ulf;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
        DROP_ULFf, &tmpval);
    tmpval = entry->ipp_meter_sets_dp;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
        IPP_METER_SETS_DPf, &tmpval);
    tmpval = entry->spgid;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
        SPGIDf, &tmpval);
    tmpval = entry->drop_slf;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
        DROP_SLFf, &tmpval);
    tmpval = entry->drop_mlf;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
        DROP_MLFf, &tmpval);
    tmpval = entry->drop_bcast;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
        DROP_BCASTf, &tmpval);
    tmpval = entry->rp_extra;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
        RP_EXTRAf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART9r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set: Failed writing CB_IPP_PGT_IA_WDATA_PART9 register rc %d \n", rc));
        sal_mutex_give(pgt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pgt", index, rc, *status));
    }
    sal_mutex_give(pgt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pmipage_set
 * @par Description:
 *      Perform a write on the pmipage table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pmipage_set(int unit, int index, pmipage_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pmipage_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->phypagevld;
    soc_CB_PMI_PMIPAGE_IA_WDATA_PART0r_field_set(unit, &regval,
        PHYPAGEVLDf, &tmpval);
    tmpval = entry->phypage;
    soc_CB_PMI_PMIPAGE_IA_WDATA_PART0r_field_set(unit, &regval,
        PHYPAGEf, &tmpval);
    rc = REG_WRITE_CB_PMI_PMIPAGE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_set: Failed writing CB_PMI_PMIPAGE_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pmipage_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PMIPAGE_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pmipage", index, rc, *status));
    }
    sal_mutex_give(pmipage_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_config_set
 * @par Description:
 *      Perform a write on the gfcd_config table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_config_set(int unit, int index, gfcd_config_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(gfcd_config_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->thresh1;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
        THRESH1f, &tmpval);
    tmpval = entry->thresh0;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
        THRESH0f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_set: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    tmpval = entry->thresh3;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART1r_field_set(unit, &regval,
        THRESH3f, &tmpval);
    tmpval = entry->thresh2;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART1r_field_set(unit, &regval,
        THRESH2f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_set: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    tmpval = entry->counter_enable;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
        COUNTER_ENABLEf, &tmpval);
    tmpval = entry->gfc_enable;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
        GFC_ENABLEf, &tmpval);
    tmpval = entry->hysteresis;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
        HYSTERESISf, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_set: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    tmpval = entry->tc_pp_bmp_3;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r_field_set(unit, &regval,
        TC_PP_BMP_3f, &tmpval);
    tmpval = entry->tc_pp_bmp_2;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r_field_set(unit, &regval,
        TC_PP_BMP_2f, &tmpval);
    tmpval = entry->tc_pp_bmp_1;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r_field_set(unit, &regval,
        TC_PP_BMP_1f, &tmpval);
    tmpval = entry->tc_pp_bmp_0;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r_field_set(unit, &regval,
        TC_PP_BMP_0f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_set: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    tmpval = entry->tc_pp_bmp_5;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r_field_set(unit, &regval,
        TC_PP_BMP_5f, &tmpval);
    tmpval = entry->tc_pp_bmp_7;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r_field_set(unit, &regval,
        TC_PP_BMP_7f, &tmpval);
    tmpval = entry->tc_pp_bmp_4;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r_field_set(unit, &regval,
        TC_PP_BMP_4f, &tmpval);
    tmpval = entry->tc_pp_bmp_6;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r_field_set(unit, &regval,
        TC_PP_BMP_6f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_set: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART4 register rc %d \n", rc));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    tmpval = entry->tc_pp_bmp_9;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r_field_set(unit, &regval,
        TC_PP_BMP_9f, &tmpval);
    tmpval = entry->tc_pp_bmp_8;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r_field_set(unit, &regval,
        TC_PP_BMP_8f, &tmpval);
    tmpval = entry->tc_pp_bmp_10;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r_field_set(unit, &regval,
        TC_PP_BMP_10f, &tmpval);
    tmpval = entry->tc_pp_bmp_11;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r_field_set(unit, &regval,
        TC_PP_BMP_11f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_set: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART5 register rc %d \n", rc));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }
    tmpval = entry->tc_pp_bmp_14;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r_field_set(unit, &regval,
        TC_PP_BMP_14f, &tmpval);
    tmpval = entry->tc_pp_bmp_15;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r_field_set(unit, &regval,
        TC_PP_BMP_15f, &tmpval);
    tmpval = entry->tc_pp_bmp_13;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r_field_set(unit, &regval,
        TC_PP_BMP_13f, &tmpval);
    tmpval = entry->tc_pp_bmp_12;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r_field_set(unit, &regval,
        TC_PP_BMP_12f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_set: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART6 register rc %d \n", rc));
        sal_mutex_give(gfcd_config_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "gfcd_config", index, rc, *status));
    }
    sal_mutex_give(gfcd_config_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_apt_set
 * @par Description:
 *      Perform a write on the apt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_apt_set(int unit, int index, apt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(apt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->drop_thresh;
    soc_CB_PQM_APT_IA_WDATA_PART0r_field_set(unit, &regval,
        DROP_THRESHf, &tmpval);
    rc = REG_WRITE_CB_PQM_APT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_set: Failed writing CB_PQM_APT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(apt_mutex);
        return rc;
    }
    tmpval = entry->wred_m;
    soc_CB_PQM_APT_IA_WDATA_PART1r_field_set(unit, &regval,
        WRED_Mf, &tmpval);
    rc = REG_WRITE_CB_PQM_APT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_set: Failed writing CB_PQM_APT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(apt_mutex);
        return rc;
    }
    tmpval = entry->wred_c;
    soc_CB_PQM_APT_IA_WDATA_PART2r_field_set(unit, &regval,
        WRED_Cf, &tmpval);
    rc = REG_WRITE_CB_PQM_APT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_set: Failed writing CB_PQM_APT_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(apt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_APT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "apt", index, rc, *status));
    }
    sal_mutex_give(apt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_cntr_set
 * @par Description:
 *      Perform a write on the gfcd_cntr table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_cntr_set(int unit, int index, gfcd_cntr_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(gfcd_cntr_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->page_cnt;
    soc_CB_BMU_GFCD_CNTR_IA_WDATA_PART0r_field_set(unit, &regval,
        PAGE_CNTf, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CNTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_set: Failed writing CB_BMU_GFCD_CNTR_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(gfcd_cntr_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CNTR_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "gfcd_cntr", index, rc, *status));
    }
    sal_mutex_give(gfcd_cntr_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spg_pp_bmp_config_set
 * @par Description:
 *      Perform a write on the spg_pp_bmp_config table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spg_pp_bmp_config_set(int unit, int index, spg_pp_bmp_config_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(spg_pp_bmp_config_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->spg_pp_bmp;
    soc_CB_BMU_SPG_PP_BMP_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
        SPG_PP_BMPf, &tmpval);
    rc = REG_WRITE_CB_BMU_SPG_PP_BMP_CONFIG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_set: Failed writing CB_BMU_SPG_PP_BMP_CONFIG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(spg_pp_bmp_config_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "spg_pp_bmp_config", index, rc, *status));
    }
    sal_mutex_give(spg_pp_bmp_config_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dgt_set
 * @par Description:
 *      Perform a write on the dgt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dgt_set(int unit, int index, dgt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(dgt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->lilt_type;
    soc_CB_PQM_DGT_IA_WDATA_PART0r_field_set(unit, &regval,
        LILT_TYPEf, &tmpval);
    tmpval = entry->lilt_ndx;
    soc_CB_PQM_DGT_IA_WDATA_PART0r_field_set(unit, &regval,
        LILT_NDXf, &tmpval);
    rc = REG_WRITE_CB_PQM_DGT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_set: Failed writing CB_PQM_DGT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(dgt_mutex);
        return rc;
    }
    tmpval = entry->pgfov;
    soc_CB_PQM_DGT_IA_WDATA_PART1r_field_set(unit, &regval,
        PGFOVf, &tmpval);
    rc = REG_WRITE_CB_PQM_DGT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_set: Failed writing CB_PQM_DGT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(dgt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DGT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "dgt", index, rc, *status));
    }
    sal_mutex_give(dgt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gspg2ig_set
 * @par Description:
 *      Perform a write on the gspg2ig table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gspg2ig_set(int unit, int index, gspg2ig_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(gspg2ig_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->ig;
    soc_CB_IPP_GSPG2IG_IA_WDATA_PART0r_field_set(unit, &regval,
        IGf, &tmpval);
    rc = REG_WRITE_CB_IPP_GSPG2IG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_set: Failed writing CB_IPP_GSPG2IG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(gspg2ig_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GSPG2IG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "gspg2ig", index, rc, *status));
    }
    sal_mutex_give(gspg2ig_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_calendar_set
 * @par Description:
 *      Perform a write on the epp_calendar table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_calendar_set(int unit, int index, epp_calendar_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(epp_calendar_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->slot_port;
    soc_CB_EPP_EPP_CALENDAR_IA_WDATA_PART0r_field_set(unit, &regval,
        SLOT_PORTf, &tmpval);
    rc = REG_WRITE_CB_EPP_EPP_CALENDAR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_set: Failed writing CB_EPP_EPP_CALENDAR_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(epp_calendar_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_CALENDAR_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "epp_calendar", index, rc, *status));
    }
    sal_mutex_give(epp_calendar_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ght_set
 * @par Description:
 *      Perform a write on the ght table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ght_set(int unit, int index, ght_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ght_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_ITM_GHT_IA_WDATA_PART0r_field_set(unit, &regval,
        KEY_31_0f, &entry->key_31_0);
    rc = REG_WRITE_CB_ITM_GHT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_set: Failed writing CB_ITM_GHT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ght_mutex);
        return rc;
    }
    soc_CB_ITM_GHT_IA_WDATA_PART1r_field_set(unit, &regval,
        KEY_63_32f, &entry->key_63_32);
    rc = REG_WRITE_CB_ITM_GHT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_set: Failed writing CB_ITM_GHT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(ght_mutex);
        return rc;
    }
    soc_CB_ITM_GHT_IA_WDATA_PART2r_field_set(unit, &regval,
        KEY_95_64f, &entry->key_95_64);
    rc = REG_WRITE_CB_ITM_GHT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_set: Failed writing CB_ITM_GHT_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(ght_mutex);
        return rc;
    }
    tmpval = entry->n_or_vsi;
    soc_CB_ITM_GHT_IA_WDATA_PART3r_field_set(unit, &regval,
        N_OR_VSIf, &tmpval);
    tmpval = entry->valid;
    soc_CB_ITM_GHT_IA_WDATA_PART3r_field_set(unit, &regval,
        VALIDf, &tmpval);
    tmpval = entry->key_113_96;
    soc_CB_ITM_GHT_IA_WDATA_PART3r_field_set(unit, &regval,
        KEY_113_96f, &tmpval);
    tmpval = entry->li_type;
    soc_CB_ITM_GHT_IA_WDATA_PART3r_field_set(unit, &regval,
        LI_TYPEf, &tmpval);
    rc = REG_WRITE_CB_ITM_GHT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_set: Failed writing CB_ITM_GHT_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(ght_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ght", index, rc, *status));
    }
    sal_mutex_give(ght_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lin2vsi_set
 * @par Description:
 *      Perform a write on the lin2vsi table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lin2vsi_set(int unit, int index, lin2vsi_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lin2vsi_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->tc;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
        TCf, &tmpval);
    tmpval = entry->dp;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
        DPf, &tmpval);
    tmpval = entry->use_tc;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
        USE_TCf, &tmpval);
    tmpval = entry->use_dp;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
        USE_DPf, &tmpval);
    tmpval = entry->vsi;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
        VSIf, &tmpval);
    rc = REG_WRITE_CB_IPP_LIN2VSI_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_set: Failed writing CB_IPP_LIN2VSI_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(lin2vsi_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LIN2VSI_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "lin2vsi", index, rc, *status));
    }
    sal_mutex_give(lin2vsi_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_profile_set
 * @par Description:
 *      Perform a write on the cfp_profile table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_profile_set(int unit, int index, cfp_profile_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_profile_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->cbs_exp;
    soc_CB_CFP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CBS_EXPf, &tmpval);
    tmpval = entry->cbs_mantissa;
    soc_CB_CFP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CBS_MANTISSAf, &tmpval);
    tmpval = entry->cir_mantissa;
    soc_CB_CFP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CIR_MANTISSAf, &tmpval);
    tmpval = entry->cir_exp;
    soc_CB_CFP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CIR_EXPf, &tmpval);
    rc = REG_WRITE_CB_CFP_PROFILE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_set: Failed writing CB_CFP_PROFILE_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(cfp_profile_mutex);
        return rc;
    }
    tmpval = entry->eir_exp;
    soc_CB_CFP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EIR_EXPf, &tmpval);
    tmpval = entry->ebs_exp;
    soc_CB_CFP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EBS_EXPf, &tmpval);
    tmpval = entry->eir_mantissa;
    soc_CB_CFP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EIR_MANTISSAf, &tmpval);
    tmpval = entry->ebs_mantissa;
    soc_CB_CFP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EBS_MANTISSAf, &tmpval);
    rc = REG_WRITE_CB_CFP_PROFILE_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_set: Failed writing CB_CFP_PROFILE_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(cfp_profile_mutex);
        return rc;
    }
    tmpval = entry->drop_on_red;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        DROP_ON_REDf, &tmpval);
    tmpval = entry->pkt_mode;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        PKT_MODEf, &tmpval);
    tmpval = entry->bktc_strict;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BKTC_STRICTf, &tmpval);
    tmpval = entry->bkte_strict;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BKTE_STRICTf, &tmpval);
    tmpval = entry->cf;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        CFf, &tmpval);
    tmpval = entry->rfc2698;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        RFC2698f, &tmpval);
    tmpval = entry->blind;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BLINDf, &tmpval);
    tmpval = entry->avb_mode;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        AVB_MODEf, &tmpval);
    rc = REG_WRITE_CB_CFP_PROFILE_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_set: Failed writing CB_CFP_PROFILE_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(cfp_profile_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "cfp_profile", index, rc, *status));
    }
    sal_mutex_give(cfp_profile_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_bucket_set
 * @par Description:
 *      Perform a write on the cfp_bucket table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_bucket_set(int unit, int index, cfp_bucket_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_bucket_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->bkte;
    soc_CB_CFP_BUCKET_IA_WDATA_PART0r_field_set(unit, &regval,
        BKTEf, &tmpval);
    rc = REG_WRITE_CB_CFP_BUCKET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_set: Failed writing CB_CFP_BUCKET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(cfp_bucket_mutex);
        return rc;
    }
    tmpval = entry->bktc;
    soc_CB_CFP_BUCKET_IA_WDATA_PART1r_field_set(unit, &regval,
        BKTCf, &tmpval);
    rc = REG_WRITE_CB_CFP_BUCKET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_set: Failed writing CB_CFP_BUCKET_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(cfp_bucket_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "cfp_bucket", index, rc, *status));
    }
    sal_mutex_give(cfp_bucket_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_calendar_set
 * @par Description:
 *      Perform a write on the calendar table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_calendar_set(int unit, int index, calendar_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(calendar_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->slot_port_sel_en;
    soc_CB_PQS_CALENDAR_IA_WDATA_PART0r_field_set(unit, &regval,
        SLOT_PORT_SEL_ENf, &tmpval);
    tmpval = entry->slot_port;
    soc_CB_PQS_CALENDAR_IA_WDATA_PART0r_field_set(unit, &regval,
        SLOT_PORTf, &tmpval);
    rc = REG_WRITE_CB_PQS_CALENDAR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_set: Failed writing CB_PQS_CALENDAR_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(calendar_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CALENDAR_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "calendar", index, rc, *status));
    }
    sal_mutex_give(calendar_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pg2lpg_set
 * @par Description:
 *      Perform a write on the pg2lpg table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pg2lpg_set(int unit, int index, pg2lpg_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pg2lpg_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->lpg;
    soc_CB_PQM_PG2LPG_IA_WDATA_PART0r_field_set(unit, &regval,
        LPGf, &tmpval);
    rc = REG_WRITE_CB_PQM_PG2LPG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_set: Failed writing CB_PQM_PG2LPG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pg2lpg_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PG2LPG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pg2lpg", index, rc, *status));
    }
    sal_mutex_give(pg2lpg_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm_set
 * @par Description:
 *      Perform a write on the arlfm table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm_set(int unit, int index, arlfm_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(arlfm_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_ITM_ARLFM_IA_WDATA_PART0r_field_set(unit, &regval,
        MAC_LOf, &entry->mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_set: Failed writing CB_ITM_ARLFM_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(arlfm_mutex);
        return rc;
    }
    tmpval = entry->fid;
    soc_CB_ITM_ARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
        FIDf, &tmpval);
    tmpval = entry->upd_ctrl;
    soc_CB_ITM_ARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
        UPD_CTRLf, &tmpval);
    tmpval = entry->mac_hi;
    soc_CB_ITM_ARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
        MAC_HIf, &tmpval);
    tmpval = entry->fwd_ctrl;
    soc_CB_ITM_ARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
        FWD_CTRLf, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_set: Failed writing CB_ITM_ARLFM_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(arlfm_mutex);
        return rc;
    }
    tmpval = entry->valid;
    soc_CB_ITM_ARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
        VALIDf, &tmpval);
    tmpval = entry->dst;
    soc_CB_ITM_ARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
        DSTf, &tmpval);
    tmpval = entry->dst_type;
    soc_CB_ITM_ARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
        DST_TYPEf, &tmpval);
    tmpval = entry->hit;
    soc_CB_ITM_ARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
        HITf, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_set: Failed writing CB_ITM_ARLFM_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(arlfm_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "arlfm", index, rc, *status));
    }
    sal_mutex_give(arlfm_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm0_set
 * @par Description:
 *      Perform a write on the arlfm0 table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm0_set(int unit, int index, arlfm0_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(arlfm0_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->valid;
    soc_CB_ITM_ARLFM0_IA_WDATA_PART0r_field_set(unit, &regval,
        VALIDf, &tmpval);
    tmpval = entry->dst;
    soc_CB_ITM_ARLFM0_IA_WDATA_PART0r_field_set(unit, &regval,
        DSTf, &tmpval);
    tmpval = entry->dst_type;
    soc_CB_ITM_ARLFM0_IA_WDATA_PART0r_field_set(unit, &regval,
        DST_TYPEf, &tmpval);
    tmpval = entry->hit;
    soc_CB_ITM_ARLFM0_IA_WDATA_PART0r_field_set(unit, &regval,
        HITf, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM0_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_set: Failed writing CB_ITM_ARLFM0_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(arlfm0_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM0_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "arlfm0", index, rc, *status));
    }
    sal_mutex_give(arlfm0_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_bucket_set
 * @par Description:
 *      Perform a write on the ipp_bucket table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_bucket_set(int unit, int index, ipp_bucket_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_bucket_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->bkte;
    soc_CB_IPP_BUCKET_IA_WDATA_PART0r_field_set(unit, &regval,
        BKTEf, &tmpval);
    rc = REG_WRITE_CB_IPP_BUCKET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_set: Failed writing CB_IPP_BUCKET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ipp_bucket_mutex);
        return rc;
    }
    tmpval = entry->bktc;
    soc_CB_IPP_BUCKET_IA_WDATA_PART1r_field_set(unit, &regval,
        BKTCf, &tmpval);
    rc = REG_WRITE_CB_IPP_BUCKET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_set: Failed writing CB_IPP_BUCKET_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(ipp_bucket_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ipp_bucket", index, rc, *status));
    }
    sal_mutex_give(ipp_bucket_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_config_set
 * @par Description:
 *      Perform a write on the fcd_config table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_config_set(int unit, int index, fcd_config_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(fcd_config_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->thresh1;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
        THRESH1f, &tmpval);
    tmpval = entry->thresh0;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
        THRESH0f, &tmpval);
    rc = REG_WRITE_CB_BMU_FCD_CONFIG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_set: Failed writing CB_BMU_FCD_CONFIG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(fcd_config_mutex);
        return rc;
    }
    tmpval = entry->thresh3;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART1r_field_set(unit, &regval,
        THRESH3f, &tmpval);
    tmpval = entry->thresh2;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART1r_field_set(unit, &regval,
        THRESH2f, &tmpval);
    rc = REG_WRITE_CB_BMU_FCD_CONFIG_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_set: Failed writing CB_BMU_FCD_CONFIG_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(fcd_config_mutex);
        return rc;
    }
    tmpval = entry->counter_enable;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
        COUNTER_ENABLEf, &tmpval);
    tmpval = entry->tc_bmp;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
        TC_BMPf, &tmpval);
    tmpval = entry->fc_enable;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
        FC_ENABLEf, &tmpval);
    tmpval = entry->hysteresis;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
        HYSTERESISf, &tmpval);
    rc = REG_WRITE_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_set: Failed writing CB_BMU_FCD_CONFIG_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(fcd_config_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "fcd_config", index, rc, *status));
    }
    sal_mutex_give(fcd_config_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stat_set
 * @par Description:
 *      Perform a write on the stat table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stat_set(int unit, int index, stat_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(stat_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_CFP_STAT_IA_WDATA_PART0r_field_set(unit, &regval,
        STAT_COUNTER0_LOf, &entry->stat_counter0_lo);
    rc = REG_WRITE_CB_CFP_STAT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_set: Failed writing CB_CFP_STAT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(stat_mutex);
        return rc;
    }
    soc_CB_CFP_STAT_IA_WDATA_PART1r_field_set(unit, &regval,
        STAT_COUNTER0_HIf, &entry->stat_counter0_hi);
    rc = REG_WRITE_CB_CFP_STAT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_set: Failed writing CB_CFP_STAT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(stat_mutex);
        return rc;
    }
    soc_CB_CFP_STAT_IA_WDATA_PART2r_field_set(unit, &regval,
        STAT_COUNTER1_LOf, &entry->stat_counter1_lo);
    rc = REG_WRITE_CB_CFP_STAT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_set: Failed writing CB_CFP_STAT_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(stat_mutex);
        return rc;
    }
    soc_CB_CFP_STAT_IA_WDATA_PART3r_field_set(unit, &regval,
        STAT_COUNTER1_HIf, &entry->stat_counter1_hi);
    rc = REG_WRITE_CB_CFP_STAT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_set: Failed writing CB_CFP_STAT_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(stat_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STAT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "stat", index, rc, *status));
    }
    sal_mutex_give(stat_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_eeecfg_set
 * @par Description:
 *      Perform a write on the eeecfg table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_eeecfg_set(int unit, int index, eeecfg_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(eeecfg_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->eee_thresh;
    soc_CB_PQM_EEECFG_IA_WDATA_PART0r_field_set(unit, &regval,
        EEE_THRESHf, &tmpval);
    tmpval = entry->eee_timer;
    soc_CB_PQM_EEECFG_IA_WDATA_PART0r_field_set(unit, &regval,
        EEE_TIMERf, &tmpval);
    tmpval = entry->eee_en;
    soc_CB_PQM_EEECFG_IA_WDATA_PART0r_field_set(unit, &regval,
        EEE_ENf, &tmpval);
    rc = REG_WRITE_CB_PQM_EEECFG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_set: Failed writing CB_PQM_EEECFG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(eeecfg_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EEECFG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "eeecfg", index, rc, *status));
    }
    sal_mutex_give(eeecfg_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_hdt_set
 * @par Description:
 *      Perform a write on the hdt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_hdt_set(int unit, int index, hdt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(hdt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->type0;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
        TYPE0f, &tmpval);
    tmpval = entry->which0;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
        WHICH0f, &tmpval);
    tmpval = entry->uptill0;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
        UPTILL0f, &tmpval);
    tmpval = entry->type1;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
        TYPE1f, &tmpval);
    tmpval = entry->which1;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
        WHICH1f, &tmpval);
    tmpval = entry->uptill1;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
        UPTILL1f, &tmpval);
    rc = REG_WRITE_CB_IPP_HDT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_set: Failed writing CB_IPP_HDT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(hdt_mutex);
        return rc;
    }
    tmpval = entry->type2;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
        TYPE2f, &tmpval);
    tmpval = entry->uptill2;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
        UPTILL2f, &tmpval);
    tmpval = entry->uptill3;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
        UPTILL3f, &tmpval);
    tmpval = entry->which2;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
        WHICH2f, &tmpval);
    tmpval = entry->which3;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
        WHICH3f, &tmpval);
    tmpval = entry->type3;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
        TYPE3f, &tmpval);
    rc = REG_WRITE_CB_IPP_HDT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_set: Failed writing CB_IPP_HDT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(hdt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_HDT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "hdt", index, rc, *status));
    }
    sal_mutex_give(hdt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_estget_set
 * @par Description:
 *      Perform a write on the estget table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_estget_set(int unit, int index, estget_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(estget_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->tx_ena;
    soc_CB_PQM_ESTGET_IA_WDATA_PART0r_field_set(unit, &regval,
        TX_ENAf, &tmpval);
    rc = REG_WRITE_CB_PQM_ESTGET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_set: Failed writing CB_PQM_ESTGET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(estget_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ESTGET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "estget", index, rc, *status));
    }
    sal_mutex_give(estget_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stt_set
 * @par Description:
 *      Perform a write on the stt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stt_set(int unit, int index, stt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(stt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->etype;
    soc_CB_IPP_STT_IA_WDATA_PART0r_field_set(unit, &regval,
        ETYPEf, &tmpval);
    tmpval = entry->ntype;
    soc_CB_IPP_STT_IA_WDATA_PART0r_field_set(unit, &regval,
        NTYPEf, &tmpval);
    rc = REG_WRITE_CB_IPP_STT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_set: Failed writing CB_IPP_STT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(stt_mutex);
        return rc;
    }
    tmpval = entry->ekey_type;
    soc_CB_IPP_STT_IA_WDATA_PART1r_field_set(unit, &regval,
        EKEY_TYPEf, &tmpval);
    tmpval = entry->length;
    soc_CB_IPP_STT_IA_WDATA_PART1r_field_set(unit, &regval,
        LENGTHf, &tmpval);
    tmpval = entry->tci;
    soc_CB_IPP_STT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCIf, &tmpval);
    rc = REG_WRITE_CB_IPP_STT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_set: Failed writing CB_IPP_STT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(stt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "stt", index, rc, *status));
    }
    sal_mutex_give(stt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pet_set
 * @par Description:
 *      Perform a write on the pet table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pet_set(int unit, int index, pet_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pet_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->encap4;
    soc_CB_ETM_PET_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP4f, &tmpval);
    tmpval = entry->encap5;
    soc_CB_ETM_PET_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP5f, &tmpval);
    tmpval = entry->encap7;
    soc_CB_ETM_PET_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP7f, &tmpval);
    tmpval = entry->encap6;
    soc_CB_ETM_PET_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP6f, &tmpval);
    rc = REG_WRITE_CB_ETM_PET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_set: Failed writing CB_ETM_PET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pet_mutex);
        return rc;
    }
    tmpval = entry->encap2;
    soc_CB_ETM_PET_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP2f, &tmpval);
    tmpval = entry->encap3;
    soc_CB_ETM_PET_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP3f, &tmpval);
    tmpval = entry->encap0;
    soc_CB_ETM_PET_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP0f, &tmpval);
    tmpval = entry->encap1;
    soc_CB_ETM_PET_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP1f, &tmpval);
    rc = REG_WRITE_CB_ETM_PET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_set: Failed writing CB_ETM_PET_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(pet_mutex);
        return rc;
    }
    tmpval = entry->full;
    soc_CB_ETM_PET_IA_WDATA_PART2r_field_set(unit, &regval,
        FULLf, &tmpval);
    rc = REG_WRITE_CB_ETM_PET_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_set: Failed writing CB_ETM_PET_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(pet_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pet", index, rc, *status));
    }
    sal_mutex_give(pet_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_istget_set
 * @par Description:
 *      Perform a write on the istget table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_istget_set(int unit, int index, istget_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(istget_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->rx_ena;
    soc_CB_IPP_ISTGET_IA_WDATA_PART0r_field_set(unit, &regval,
        RX_ENAf, &tmpval);
    rc = REG_WRITE_CB_IPP_ISTGET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_set: Failed writing CB_IPP_ISTGET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(istget_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ISTGET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "istget", index, rc, *status));
    }
    sal_mutex_give(istget_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qdschcfg_set
 * @par Description:
 *      Perform a write on the qdschcfg table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qdschcfg_set(int unit, int index, qdschcfg_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(qdschcfg_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->sp_rr_sch;
    soc_CB_PQM_QDSCHCFG_IA_WDATA_PART0r_field_set(unit, &regval,
        SP_RR_SCHf, &tmpval);
    rc = REG_WRITE_CB_PQM_QDSCHCFG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_set: Failed writing CB_PQM_QDSCHCFG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(qdschcfg_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QDSCHCFG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "qdschcfg", index, rc, *status));
    }
    sal_mutex_give(qdschcfg_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_rscale_set
 * @par Description:
 *      Perform a write on the pqm_rscale table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_rscale_set(int unit, int index, pqm_rscale_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_rscale_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->scale;
    soc_CB_PQM_RSCALE_IA_WDATA_PART0r_field_set(unit, &regval,
        SCALEf, &tmpval);
    rc = REG_WRITE_CB_PQM_RSCALE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_set: Failed writing CB_PQM_RSCALE_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pqm_rscale_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pqm_rscale", index, rc, *status));
    }
    sal_mutex_give(pqm_rscale_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtr2tcb_set
 * @par Description:
 *      Perform a write on the mtr2tcb table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtr2tcb_set(int unit, int index, mtr2tcb_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(mtr2tcb_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->tc_bmp;
    soc_CB_BMU_MTR2TCB_IA_WDATA_PART0r_field_set(unit, &regval,
        TC_BMPf, &tmpval);
    tmpval = entry->shp_en;
    soc_CB_BMU_MTR2TCB_IA_WDATA_PART0r_field_set(unit, &regval,
        SHP_ENf, &tmpval);
    rc = REG_WRITE_CB_BMU_MTR2TCB_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_set: Failed writing CB_BMU_MTR2TCB_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(mtr2tcb_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTR2TCB_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "mtr2tcb", index, rc, *status));
    }
    sal_mutex_give(mtr2tcb_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dli2ldpg_set
 * @par Description:
 *      Perform a write on the dli2ldpg table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dli2ldpg_set(int unit, int index, dli2ldpg_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(dli2ldpg_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->ldpgid;
    soc_CB_PQM_DLI2LDPG_IA_WDATA_PART0r_field_set(unit, &regval,
        LDPGIDf, &tmpval);
    rc = REG_WRITE_CB_PQM_DLI2LDPG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_set: Failed writing CB_PQM_DLI2LDPG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(dli2ldpg_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLI2LDPG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "dli2ldpg", index, rc, *status));
    }
    sal_mutex_give(dli2ldpg_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tc2qd_set
 * @par Description:
 *      Perform a write on the tc2qd table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tc2qd_set(int unit, int index, tc2qd_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(tc2qd_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->qd;
    soc_CB_PQM_TC2QD_IA_WDATA_PART0r_field_set(unit, &regval,
        QDf, &tmpval);
    rc = REG_WRITE_CB_PQM_TC2QD_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_set: Failed writing CB_PQM_TC2QD_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(tc2qd_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TC2QD_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "tc2qd", index, rc, *status));
    }
    sal_mutex_give(tc2qd_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spldt_set
 * @par Description:
 *      Perform a write on the spldt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spldt_set(int unit, int index, spldt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(spldt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->link_delay;
    soc_CB_EPP_SPLDT_IA_WDATA_PART0r_field_set(unit, &regval,
        LINK_DELAYf, &tmpval);
    rc = REG_WRITE_CB_EPP_SPLDT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_set: Failed writing CB_EPP_SPLDT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(spldt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPLDT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "spldt", index, rc, *status));
    }
    sal_mutex_give(spldt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_rscale_set
 * @par Description:
 *      Perform a write on the cfp_rscale table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_rscale_set(int unit, int index, cfp_rscale_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_rscale_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->scale;
    soc_CB_CFP_RSCALE_IA_WDATA_PART0r_field_set(unit, &regval,
        SCALEf, &tmpval);
    rc = REG_WRITE_CB_CFP_RSCALE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_set: Failed writing CB_CFP_RSCALE_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(cfp_rscale_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "cfp_rscale", index, rc, *status));
    }
    sal_mutex_give(cfp_rscale_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghtdt_set
 * @par Description:
 *      Perform a write on the ghtdt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghtdt_set(int unit, int index, ghtdt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ghtdt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->seed1;
    soc_CB_ITM_GHTDT_IA_WDATA_PART0r_field_set(unit, &regval,
        SEED1f, &tmpval);
    tmpval = entry->base;
    soc_CB_ITM_GHTDT_IA_WDATA_PART0r_field_set(unit, &regval,
        BASEf, &tmpval);
    tmpval = entry->num_entries;
    soc_CB_ITM_GHTDT_IA_WDATA_PART0r_field_set(unit, &regval,
        NUM_ENTRIESf, &tmpval);
    tmpval = entry->seed0;
    soc_CB_ITM_GHTDT_IA_WDATA_PART0r_field_set(unit, &regval,
        SEED0f, &tmpval);
    rc = REG_WRITE_CB_ITM_GHTDT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_set: Failed writing CB_ITM_GHTDT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ghtdt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHTDT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ghtdt", index, rc, *status));
    }
    sal_mutex_give(ghtdt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_bucket_set
 * @par Description:
 *      Perform a write on the bmu_bucket table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_bucket_set(int unit, int index, bmu_bucket_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_bucket_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->bkte;
    soc_CB_BMU_BUCKET_IA_WDATA_PART0r_field_set(unit, &regval,
        BKTEf, &tmpval);
    rc = REG_WRITE_CB_BMU_BUCKET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_set: Failed writing CB_BMU_BUCKET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(bmu_bucket_mutex);
        return rc;
    }
    tmpval = entry->bktc;
    soc_CB_BMU_BUCKET_IA_WDATA_PART1r_field_set(unit, &regval,
        BKTCf, &tmpval);
    rc = REG_WRITE_CB_BMU_BUCKET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_set: Failed writing CB_BMU_BUCKET_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(bmu_bucket_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "bmu_bucket", index, rc, *status));
    }
    sal_mutex_give(bmu_bucket_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lilt_set
 * @par Description:
 *      Perform a write on the lilt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lilt_set(int unit, int index, lilt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lilt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_PQM_LILT_IA_WDATA_PART0r_field_set(unit, &regval,
        LILT_ENTRYf, &entry->lilt_entry);
    rc = REG_WRITE_CB_PQM_LILT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_set: Failed writing CB_PQM_LILT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(lilt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LILT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "lilt", index, rc, *status));
    }
    sal_mutex_give(lilt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_svt_set
 * @par Description:
 *      Perform a write on the svt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_svt_set(int unit, int index, svt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(svt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->svt_mask;
    soc_CB_PQM_SVT_IA_WDATA_PART0r_field_set(unit, &regval,
        SVT_MASKf, &tmpval);
    rc = REG_WRITE_CB_PQM_SVT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_set: Failed writing CB_PQM_SVT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(svt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SVT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "svt", index, rc, *status));
    }
    sal_mutex_give(svt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slicmap_set
 * @par Description:
 *      Perform a write on the slicmap table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slicmap_set(int unit, int index, slicmap_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(slicmap_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->tci5;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART0r_field_set(unit, &regval,
        TCI5f, &tmpval);
    tmpval = entry->tci4;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART0r_field_set(unit, &regval,
        TCI4f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    tmpval = entry->tci2;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART1r_field_set(unit, &regval,
        TCI2f, &tmpval);
    tmpval = entry->tci3;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART1r_field_set(unit, &regval,
        TCI3f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    tmpval = entry->tci1;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART2r_field_set(unit, &regval,
        TCI1f, &tmpval);
    tmpval = entry->tci0;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART2r_field_set(unit, &regval,
        TCI0f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    tmpval = entry->valid;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
        VALIDf, &tmpval);
    tmpval = entry->tpid0;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
        TPID0f, &tmpval);
    tmpval = entry->tpid1;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
        TPID1f, &tmpval);
    tmpval = entry->unusedb;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
        UNUSEDBf, &tmpval);
    tmpval = entry->tpid2;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
        TPID2f, &tmpval);
    tmpval = entry->tpid4;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
        TPID4f, &tmpval);
    tmpval = entry->etype;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
        ETYPEf, &tmpval);
    tmpval = entry->tpid3;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
        TPID3f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_WDATA_PART4r_field_set(unit, &regval,
        SMAC_LO32f, &entry->smac_lo32);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART4 register rc %d \n", rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    tmpval = entry->smac_hi16;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART5r_field_set(unit, &regval,
        SMAC_HI16f, &tmpval);
    tmpval = entry->dmac_lo16;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART5r_field_set(unit, &regval,
        DMAC_LO16f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART5 register rc %d \n", rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_WDATA_PART6r_field_set(unit, &regval,
        DMAC_HI32f, &entry->dmac_hi32);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART6 register rc %d \n", rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    tmpval = entry->pepper;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART7r_field_set(unit, &regval,
        PEPPERf, &tmpval);
    tmpval = entry->pg_map;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART7r_field_set(unit, &regval,
        PG_MAPf, &tmpval);
    tmpval = entry->unuseda;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART7r_field_set(unit, &regval,
        UNUSEDAf, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART7r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART7 register rc %d \n", rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }
    tmpval = entry->valid_key0;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART8r_field_set(unit, &regval,
        VALID_KEY0f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART8r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART8 register rc %d \n", rc));
        sal_mutex_give(slicmap_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICMAP_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "slicmap", index, rc, *status));
    }
    sal_mutex_give(slicmap_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_m2tk_set
 * @par Description:
 *      Perform a write on the m2tk table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_m2tk_set(int unit, int index, m2tk_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(m2tk_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->table_id;
    soc_CB_IPP_M2TK_IA_WDATA_PART0r_field_set(unit, &regval,
        TABLE_IDf, &tmpval);
    tmpval = entry->key_id;
    soc_CB_IPP_M2TK_IA_WDATA_PART0r_field_set(unit, &regval,
        KEY_IDf, &tmpval);
    rc = REG_WRITE_CB_IPP_M2TK_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_set: Failed writing CB_IPP_M2TK_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(m2tk_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_M2TK_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "m2tk", index, rc, *status));
    }
    sal_mutex_give(m2tk_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_art_set
 * @par Description:
 *      Perform a write on the art table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_art_set(int unit, int index, art_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(art_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->ndx;
    soc_CB_CFP_ART_IA_WDATA_PART0r_field_set(unit, &regval,
        NDXf, &tmpval);
    rc = REG_WRITE_CB_CFP_ART_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_set: Failed writing CB_CFP_ART_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(art_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ART_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "art", index, rc, *status));
    }
    sal_mutex_give(art_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ig_set
 * @par Description:
 *      Perform a write on the lpg2ig table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ig_set(int unit, int index, lpg2ig_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lpg2ig_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->ig;
    soc_CB_PQM_LPG2IG_IA_WDATA_PART0r_field_set(unit, &regval,
        IGf, &tmpval);
    rc = REG_WRITE_CB_PQM_LPG2IG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_set: Failed writing CB_PQM_LPG2IG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(lpg2ig_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2IG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "lpg2ig", index, rc, *status));
    }
    sal_mutex_give(lpg2ig_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_profile_set
 * @par Description:
 *      Perform a write on the ipp_profile table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_profile_set(int unit, int index, ipp_profile_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_profile_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->cbs_exp;
    soc_CB_IPP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CBS_EXPf, &tmpval);
    tmpval = entry->cbs_mantissa;
    soc_CB_IPP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CBS_MANTISSAf, &tmpval);
    tmpval = entry->cir_mantissa;
    soc_CB_IPP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CIR_MANTISSAf, &tmpval);
    tmpval = entry->cir_exp;
    soc_CB_IPP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CIR_EXPf, &tmpval);
    rc = REG_WRITE_CB_IPP_PROFILE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_set: Failed writing CB_IPP_PROFILE_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ipp_profile_mutex);
        return rc;
    }
    tmpval = entry->eir_exp;
    soc_CB_IPP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EIR_EXPf, &tmpval);
    tmpval = entry->ebs_exp;
    soc_CB_IPP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EBS_EXPf, &tmpval);
    tmpval = entry->eir_mantissa;
    soc_CB_IPP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EIR_MANTISSAf, &tmpval);
    tmpval = entry->ebs_mantissa;
    soc_CB_IPP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EBS_MANTISSAf, &tmpval);
    rc = REG_WRITE_CB_IPP_PROFILE_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_set: Failed writing CB_IPP_PROFILE_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(ipp_profile_mutex);
        return rc;
    }
    tmpval = entry->drop_on_red;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        DROP_ON_REDf, &tmpval);
    tmpval = entry->pkt_mode;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        PKT_MODEf, &tmpval);
    tmpval = entry->bktc_strict;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BKTC_STRICTf, &tmpval);
    tmpval = entry->bkte_strict;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BKTE_STRICTf, &tmpval);
    tmpval = entry->cf;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        CFf, &tmpval);
    tmpval = entry->rfc2698;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        RFC2698f, &tmpval);
    tmpval = entry->blind;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BLINDf, &tmpval);
    tmpval = entry->avb_mode;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        AVB_MODEf, &tmpval);
    rc = REG_WRITE_CB_IPP_PROFILE_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_set: Failed writing CB_IPP_PROFILE_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(ipp_profile_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ipp_profile", index, rc, *status));
    }
    sal_mutex_give(ipp_profile_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfcqdaddr_set
 * @par Description:
 *      Perform a write on the qfcqdaddr table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfcqdaddr_set(int unit, int index, qfcqdaddr_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(qfcqdaddr_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->qfc_addr;
    soc_CB_PQM_QFCQDADDR_IA_WDATA_PART0r_field_set(unit, &regval,
        QFC_ADDRf, &tmpval);
    rc = REG_WRITE_CB_PQM_QFCQDADDR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_set: Failed writing CB_PQM_QFCQDADDR_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(qfcqdaddr_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCQDADDR_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "qfcqdaddr", index, rc, *status));
    }
    sal_mutex_give(qfcqdaddr_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtgt_set
 * @par Description:
 *      Perform a write on the mtgt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtgt_set(int unit, int index, mtgt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(mtgt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->tc;
    soc_CB_PQM_MTGT_IA_WDATA_PART0r_field_set(unit, &regval,
        TCf, &tmpval);
    tmpval = entry->dp;
    soc_CB_PQM_MTGT_IA_WDATA_PART0r_field_set(unit, &regval,
        DPf, &tmpval);
    tmpval = entry->dli_n;
    soc_CB_PQM_MTGT_IA_WDATA_PART0r_field_set(unit, &regval,
        DLI_Nf, &tmpval);
    tmpval = entry->truncate;
    soc_CB_PQM_MTGT_IA_WDATA_PART0r_field_set(unit, &regval,
        TRUNCATEf, &tmpval);
    rc = REG_WRITE_CB_PQM_MTGT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_set: Failed writing CB_PQM_MTGT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(mtgt_mutex);
        return rc;
    }
    tmpval = entry->drop_prob;
    soc_CB_PQM_MTGT_IA_WDATA_PART1r_field_set(unit, &regval,
        DROP_PROBf, &tmpval);
    rc = REG_WRITE_CB_PQM_MTGT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_set: Failed writing CB_PQM_MTGT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(mtgt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTGT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "mtgt", index, rc, *status));
    }
    sal_mutex_give(mtgt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pptr_set
 * @par Description:
 *      Perform a write on the ipp_pptr table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pptr_set(int unit, int index, ipp_pptr_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_pptr_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->pointer;
    soc_CB_IPP_PPTR_IA_WDATA_PART0r_field_set(unit, &regval,
        POINTERf, &tmpval);
    rc = REG_WRITE_CB_IPP_PPTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_set: Failed writing CB_IPP_PPTR_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ipp_pptr_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PPTR_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ipp_pptr", index, rc, *status));
    }
    sal_mutex_give(ipp_pptr_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_set_set
 * @par Description:
 *      Perform a write on the set table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_set_set(int unit, int index, set_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(set_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_EPP_SET_IA_WDATA_PART0r_field_set(unit, &regval,
        SMAC_LSBf, &entry->smac_lsb);
    rc = REG_WRITE_CB_EPP_SET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_set: Failed writing CB_EPP_SET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(set_mutex);
        return rc;
    }
    tmpval = entry->smac_msb;
    soc_CB_EPP_SET_IA_WDATA_PART1r_field_set(unit, &regval,
        SMAC_MSBf, &tmpval);
    rc = REG_WRITE_CB_EPP_SET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_set: Failed writing CB_EPP_SET_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(set_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "set", index, rc, *status));
    }
    sal_mutex_give(set_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_srt_set
 * @par Description:
 *      Perform a write on the srt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_srt_set(int unit, int index, srt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(srt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->slicid;
    soc_CB_IPP_SRT_IA_WDATA_PART0r_field_set(unit, &regval,
        SLICIDf, &tmpval);
    tmpval = entry->trap_group;
    soc_CB_IPP_SRT_IA_WDATA_PART0r_field_set(unit, &regval,
        TRAP_GROUPf, &tmpval);
    rc = REG_WRITE_CB_IPP_SRT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_set: Failed writing CB_IPP_SRT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(srt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SRT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "srt", index, rc, *status));
    }
    sal_mutex_give(srt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pmon_set
 * @par Description:
 *      Perform a write on the ipp_pmon table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pmon_set(int unit, int index, ipp_pmon_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_pmon_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_IPP_PMON_IA_WDATA_PART0r_field_set(unit, &regval,
        COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_WRITE_CB_IPP_PMON_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_set: Failed writing CB_IPP_PMON_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ipp_pmon_mutex);
        return rc;
    }
    soc_CB_IPP_PMON_IA_WDATA_PART1r_field_set(unit, &regval,
        COUNT_MSBSf, &entry->count_msbs);
    rc = REG_WRITE_CB_IPP_PMON_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_set: Failed writing CB_IPP_PMON_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(ipp_pmon_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PMON_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ipp_pmon", index, rc, *status));
    }
    sal_mutex_give(ipp_pmon_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vtct_set
 * @par Description:
 *      Perform a write on the vtct table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vtct_set(int unit, int index, vtct_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(vtct_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->vid;
    soc_CB_ETM_VTCT_IA_WDATA_PART0r_field_set(unit, &regval,
        VIDf, &tmpval);
    rc = REG_WRITE_CB_ETM_VTCT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_set: Failed writing CB_ETM_VTCT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(vtct_mutex);
        return rc;
    }
    tmpval = entry->tca1;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA1f, &tmpval);
    tmpval = entry->tca2;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA2f, &tmpval);
    tmpval = entry->tca13;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA13f, &tmpval);
    tmpval = entry->tca4;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA4f, &tmpval);
    tmpval = entry->tca5;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA5f, &tmpval);
    tmpval = entry->tca8;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA8f, &tmpval);
    tmpval = entry->tca9;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA9f, &tmpval);
    tmpval = entry->tca3;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA3f, &tmpval);
    tmpval = entry->tca14;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA14f, &tmpval);
    tmpval = entry->tca12;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA12f, &tmpval);
    tmpval = entry->tca0;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA0f, &tmpval);
    tmpval = entry->tca10;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA10f, &tmpval);
    tmpval = entry->tca7;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA7f, &tmpval);
    tmpval = entry->tca6;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA6f, &tmpval);
    tmpval = entry->tca11;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA11f, &tmpval);
    tmpval = entry->tca15;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
        TCA15f, &tmpval);
    rc = REG_WRITE_CB_ETM_VTCT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_set: Failed writing CB_ETM_VTCT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(vtct_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VTCT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "vtct", index, rc, *status));
    }
    sal_mutex_give(vtct_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfpcam_set
 * @par Description:
 *      Perform a write on the cfpcam table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfpcam_set(int unit, int index, cfpcam_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfpcam_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_CFP_CFPCAM_IA_WDATA_PART0r_field_set(unit, &regval,
        TCAM_DATA0f, &entry->tcam_data0);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_set: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART1r_field_set(unit, &regval,
        TCAM_DATA1f, &entry->tcam_data1);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_set: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART2r_field_set(unit, &regval,
        TCAM_DATA2f, &entry->tcam_data2);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_set: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART3r_field_set(unit, &regval,
        TCAM_DATA3f, &entry->tcam_data3);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_set: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART4r_field_set(unit, &regval,
        TCAM_DATA4f, &entry->tcam_data4);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_set: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART4 register rc %d \n", rc));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART5r_field_set(unit, &regval,
        TCAM_DATA5f, &entry->tcam_data5);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_set: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART5 register rc %d \n", rc));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }
    tmpval = entry->tcam_valid;
    soc_CB_CFP_CFPCAM_IA_WDATA_PART6r_field_set(unit, &regval,
        TCAM_VALIDf, &tmpval);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_set: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART6 register rc %d \n", rc));
        sal_mutex_give(cfpcam_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFPCAM_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "cfpcam", index, rc, *status));
    }
    sal_mutex_give(cfpcam_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_cntr_set
 * @par Description:
 *      Perform a write on the fcd_cntr table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_cntr_set(int unit, int index, fcd_cntr_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(fcd_cntr_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->page_cnt;
    soc_CB_BMU_FCD_CNTR_IA_WDATA_PART0r_field_set(unit, &regval,
        PAGE_CNTf, &tmpval);
    rc = REG_WRITE_CB_BMU_FCD_CNTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_set: Failed writing CB_BMU_FCD_CNTR_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(fcd_cntr_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CNTR_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "fcd_cntr", index, rc, *status));
    }
    sal_mutex_give(fcd_cntr_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fpslict_set
 * @par Description:
 *      Perform a write on the fpslict table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fpslict_set(int unit, int index, fpslict_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(fpslict_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->dst_key;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        DST_KEYf, &tmpval);
    tmpval = entry->ipv6_keyset;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        IPV6_KEYSETf, &tmpval);
    tmpval = entry->ipv4_keyset;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        IPV4_KEYSETf, &tmpval);
    tmpval = entry->other_keyset;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        OTHER_KEYSETf, &tmpval);
    tmpval = entry->src_key;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        SRC_KEYf, &tmpval);
    rc = REG_WRITE_CB_IPP_FPSLICT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_set: Failed writing CB_IPP_FPSLICT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(fpslict_mutex);
        return rc;
    }
    tmpval = entry->rsvd;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART1r_field_set(unit, &regval,
        RSVDf, &tmpval);
    rc = REG_WRITE_CB_IPP_FPSLICT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_set: Failed writing CB_IPP_FPSLICT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(fpslict_mutex);
        return rc;
    }
    tmpval = entry->pv2li_map_en;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART2r_field_set(unit, &regval,
        PV2LI_MAP_ENf, &tmpval);
    tmpval = entry->default_sli;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART2r_field_set(unit, &regval,
        DEFAULT_SLIf, &tmpval);
    rc = REG_WRITE_CB_IPP_FPSLICT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_set: Failed writing CB_IPP_FPSLICT_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(fpslict_mutex);
        return rc;
    }
    tmpval = entry->li_map0;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
        LI_MAP0f, &tmpval);
    tmpval = entry->li_map0_en;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
        LI_MAP0_ENf, &tmpval);
    tmpval = entry->li_map1_en;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
        LI_MAP1_ENf, &tmpval);
    tmpval = entry->li_map0_decap;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
        LI_MAP0_DECAPf, &tmpval);
    tmpval = entry->li_map1_decap;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
        LI_MAP1_DECAPf, &tmpval);
    tmpval = entry->slic_decap;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
        SLIC_DECAPf, &tmpval);
    tmpval = entry->pv_decap;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
        PV_DECAPf, &tmpval);
    tmpval = entry->li_map1;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
        LI_MAP1f, &tmpval);
    rc = REG_WRITE_CB_IPP_FPSLICT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_set: Failed writing CB_IPP_FPSLICT_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(fpslict_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FPSLICT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "fpslict", index, rc, *status));
    }
    sal_mutex_give(fpslict_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_kst_set
 * @par Description:
 *      Perform a write on the kst table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_kst_set(int unit, int index, kst_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(kst_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->lbh_key;
    soc_CB_IPP_KST_IA_WDATA_PART0r_field_set(unit, &regval,
        LBH_KEYf, &tmpval);
    tmpval = entry->lbh_en;
    soc_CB_IPP_KST_IA_WDATA_PART0r_field_set(unit, &regval,
        LBH_ENf, &tmpval);
    tmpval = entry->cfp_key_en;
    soc_CB_IPP_KST_IA_WDATA_PART0r_field_set(unit, &regval,
        CFP_KEY_ENf, &tmpval);
    rc = REG_WRITE_CB_IPP_KST_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_set: Failed writing CB_IPP_KST_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(kst_mutex);
        return rc;
    }
    tmpval = entry->dbid3;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
        DBID3f, &tmpval);
    tmpval = entry->dbid0;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
        DBID0f, &tmpval);
    tmpval = entry->cfp_key3;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
        CFP_KEY3f, &tmpval);
    tmpval = entry->cfp_key2;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
        CFP_KEY2f, &tmpval);
    tmpval = entry->cfp_key1;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
        CFP_KEY1f, &tmpval);
    tmpval = entry->dbid2;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
        DBID2f, &tmpval);
    tmpval = entry->cfp_key0;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
        CFP_KEY0f, &tmpval);
    tmpval = entry->dbid1;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
        DBID1f, &tmpval);
    rc = REG_WRITE_CB_IPP_KST_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_set: Failed writing CB_IPP_KST_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(kst_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_KST_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "kst", index, rc, *status));
    }
    sal_mutex_give(kst_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_bucket_set
 * @par Description:
 *      Perform a write on the pqm_bucket table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_bucket_set(int unit, int index, pqm_bucket_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_bucket_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->bkte;
    soc_CB_PQM_BUCKET_IA_WDATA_PART0r_field_set(unit, &regval,
        BKTEf, &tmpval);
    rc = REG_WRITE_CB_PQM_BUCKET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_set: Failed writing CB_PQM_BUCKET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pqm_bucket_mutex);
        return rc;
    }
    tmpval = entry->bktc;
    soc_CB_PQM_BUCKET_IA_WDATA_PART1r_field_set(unit, &regval,
        BKTCf, &tmpval);
    rc = REG_WRITE_CB_PQM_BUCKET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_set: Failed writing CB_PQM_BUCKET_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(pqm_bucket_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pqm_bucket", index, rc, *status));
    }
    sal_mutex_give(pqm_bucket_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghst_set
 * @par Description:
 *      Perform a write on the ghst table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghst_set(int unit, int index, ghst_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ghst_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_ITM_GHST_IA_WDATA_PART0r_field_set(unit, &regval,
        SEED_31_0f, &entry->seed_31_0);
    rc = REG_WRITE_CB_ITM_GHST_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_set: Failed writing CB_ITM_GHST_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ghst_mutex);
        return rc;
    }
    soc_CB_ITM_GHST_IA_WDATA_PART1r_field_set(unit, &regval,
        SEED_63_32f, &entry->seed_63_32);
    rc = REG_WRITE_CB_ITM_GHST_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_set: Failed writing CB_ITM_GHST_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(ghst_mutex);
        return rc;
    }
    soc_CB_ITM_GHST_IA_WDATA_PART2r_field_set(unit, &regval,
        SEED_95_64f, &entry->seed_95_64);
    rc = REG_WRITE_CB_ITM_GHST_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_set: Failed writing CB_ITM_GHST_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(ghst_mutex);
        return rc;
    }
    tmpval = entry->seed_113_96;
    soc_CB_ITM_GHST_IA_WDATA_PART3r_field_set(unit, &regval,
        SEED_113_96f, &tmpval);
    rc = REG_WRITE_CB_ITM_GHST_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_set: Failed writing CB_ITM_GHST_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(ghst_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHST_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ghst", index, rc, *status));
    }
    sal_mutex_give(ghst_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2pg_set
 * @par Description:
 *      Perform a write on the lpg2pg table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2pg_set(int unit, int index, lpg2pg_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lpg2pg_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->pg;
    soc_CB_PQM_LPG2PG_IA_WDATA_PART0r_field_set(unit, &regval,
        PGf, &tmpval);
    rc = REG_WRITE_CB_PQM_LPG2PG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_set: Failed writing CB_PQM_LPG2PG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(lpg2pg_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "lpg2pg", index, rc, *status));
    }
    sal_mutex_give(lpg2pg_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epgt_set
 * @par Description:
 *      Perform a write on the epgt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epgt_set(int unit, int index, epgt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(epgt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->mirror_tc;
    soc_CB_EPP_EPGT_IA_WDATA_PART0r_field_set(unit, &regval,
        MIRROR_TCf, &tmpval);
    tmpval = entry->mirror;
    soc_CB_EPP_EPGT_IA_WDATA_PART0r_field_set(unit, &regval,
        MIRRORf, &tmpval);
    tmpval = entry->sample;
    soc_CB_EPP_EPGT_IA_WDATA_PART0r_field_set(unit, &regval,
        SAMPLEf, &tmpval);
    tmpval = entry->mirror_dp;
    soc_CB_EPP_EPGT_IA_WDATA_PART0r_field_set(unit, &regval,
        MIRROR_DPf, &tmpval);
    rc = REG_WRITE_CB_EPP_EPGT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_set: Failed writing CB_EPP_EPGT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(epgt_mutex);
        return rc;
    }
    tmpval = entry->mtu;
    soc_CB_EPP_EPGT_IA_WDATA_PART1r_field_set(unit, &regval,
        MTUf, &tmpval);
    rc = REG_WRITE_CB_EPP_EPGT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_set: Failed writing CB_EPP_EPGT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(epgt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPGT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "epgt", index, rc, *status));
    }
    sal_mutex_give(epgt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_rscale_set
 * @par Description:
 *      Perform a write on the bmu_rscale table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_rscale_set(int unit, int index, bmu_rscale_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_rscale_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->scale;
    soc_CB_BMU_RSCALE_IA_WDATA_PART0r_field_set(unit, &regval,
        SCALEf, &tmpval);
    rc = REG_WRITE_CB_BMU_RSCALE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_set: Failed writing CB_BMU_RSCALE_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(bmu_rscale_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "bmu_rscale", index, rc, *status));
    }
    sal_mutex_give(bmu_rscale_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ppfov_set
 * @par Description:
 *      Perform a write on the lpg2ppfov table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ppfov_set(int unit, int index, lpg2ppfov_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lpg2ppfov_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->ppfov;
    soc_CB_PQM_LPG2PPFOV_IA_WDATA_PART0r_field_set(unit, &regval,
        PPFOVf, &tmpval);
    rc = REG_WRITE_CB_PQM_LPG2PPFOV_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_set: Failed writing CB_PQM_LPG2PPFOV_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(lpg2ppfov_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PPFOV_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "lpg2ppfov", index, rc, *status));
    }
    sal_mutex_give(lpg2ppfov_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vsit_set
 * @par Description:
 *      Perform a write on the vsit table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vsit_set(int unit, int index, vsit_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(vsit_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->drop_ulf;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
        DROP_ULFf, &tmpval);
    tmpval = entry->learn;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
        LEARNf, &tmpval);
    tmpval = entry->rsvd0;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
        RSVD0f, &tmpval);
    tmpval = entry->drop_slf;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
        DROP_SLFf, &tmpval);
    tmpval = entry->hit_smac_if_dmac_mcast;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
        HIT_SMAC_IF_DMAC_MCASTf, &tmpval);
    tmpval = entry->drop_mlf;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
        DROP_MLFf, &tmpval);
    tmpval = entry->rsvd1;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
        RSVD1f, &tmpval);
    tmpval = entry->stgid;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
        STGIDf, &tmpval);
    tmpval = entry->drop_bcast;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
        DROP_BCASTf, &tmpval);
    rc = REG_WRITE_CB_IPP_VSIT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_set: Failed writing CB_IPP_VSIT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(vsit_mutex);
        return rc;
    }
    tmpval = entry->pg_map;
    soc_CB_IPP_VSIT_IA_WDATA_PART1r_field_set(unit, &regval,
        PG_MAPf, &tmpval);
    rc = REG_WRITE_CB_IPP_VSIT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_set: Failed writing CB_IPP_VSIT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(vsit_mutex);
        return rc;
    }
    tmpval = entry->dlliid_dgid;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
        DLLIID_DGIDf, &tmpval);
    tmpval = entry->wred_ena;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
        WRED_ENAf, &tmpval);
    tmpval = entry->default_is_multicast;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
        DEFAULT_IS_MULTICASTf, &tmpval);
    tmpval = entry->sli_lpbk_ena;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
        SLI_LPBK_ENAf, &tmpval);
    tmpval = entry->iso_map;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
        ISO_MAPf, &tmpval);
    rc = REG_WRITE_CB_IPP_VSIT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_set: Failed writing CB_IPP_VSIT_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(vsit_mutex);
        return rc;
    }
    tmpval = entry->fid;
    soc_CB_IPP_VSIT_IA_WDATA_PART3r_field_set(unit, &regval,
        FIDf, &tmpval);
    rc = REG_WRITE_CB_IPP_VSIT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_set: Failed writing CB_IPP_VSIT_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(vsit_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VSIT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "vsit", index, rc, *status));
    }
    sal_mutex_give(vsit_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfccredit_set
 * @par Description:
 *      Perform a write on the qfccredit table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfccredit_set(int unit, int index, qfccredit_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(qfccredit_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->qfc_credit;
    soc_CB_PQM_QFCCREDIT_IA_WDATA_PART0r_field_set(unit, &regval,
        QFC_CREDITf, &tmpval);
    rc = REG_WRITE_CB_PQM_QFCCREDIT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_set: Failed writing CB_PQM_QFCCREDIT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(qfccredit_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCCREDIT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "qfccredit", index, rc, *status));
    }
    sal_mutex_give(qfccredit_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tet_set
 * @par Description:
 *      Perform a write on the tet table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tet_set(int unit, int index, tet_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(tet_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->tag;
    soc_CB_EPP_TET_IA_WDATA_PART0r_field_set(unit, &regval,
        TAGf, &tmpval);
    rc = REG_WRITE_CB_EPP_TET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_set: Failed writing CB_EPP_TET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(tet_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "tet", index, rc, *status));
    }
    sal_mutex_give(tet_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pp2lpg_set
 * @par Description:
 *      Perform a write on the ipp_pp2lpg table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pp2lpg_set(int unit, int index, ipp_pp2lpg_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_pp2lpg_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->pgid;
    soc_CB_IPP_PP2LPG_IA_WDATA_PART0r_field_set(unit, &regval,
        PGIDf, &tmpval);
    rc = REG_WRITE_CB_IPP_PP2LPG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_set: Failed writing CB_IPP_PP2LPG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ipp_pp2lpg_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PP2LPG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ipp_pp2lpg", index, rc, *status));
    }
    sal_mutex_give(ipp_pp2lpg_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pptr_set
 * @par Description:
 *      Perform a write on the pqm_pptr table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pptr_set(int unit, int index, pqm_pptr_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_pptr_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->pointer;
    soc_CB_PQM_PPTR_IA_WDATA_PART0r_field_set(unit, &regval,
        POINTERf, &tmpval);
    rc = REG_WRITE_CB_PQM_PPTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_set: Failed writing CB_PQM_PPTR_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pqm_pptr_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PPTR_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pqm_pptr", index, rc, *status));
    }
    sal_mutex_give(pqm_pptr_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pmon_set
 * @par Description:
 *      Perform a write on the bmu_pmon table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pmon_set(int unit, int index, bmu_pmon_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_pmon_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_BMU_PMON_IA_WDATA_PART0r_field_set(unit, &regval,
        COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_WRITE_CB_BMU_PMON_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_set: Failed writing CB_BMU_PMON_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(bmu_pmon_mutex);
        return rc;
    }
    soc_CB_BMU_PMON_IA_WDATA_PART1r_field_set(unit, &regval,
        COUNT_MSBSf, &entry->count_msbs);
    rc = REG_WRITE_CB_BMU_PMON_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_set: Failed writing CB_BMU_PMON_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(bmu_pmon_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PMON_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "bmu_pmon", index, rc, *status));
    }
    sal_mutex_give(bmu_pmon_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_etct_set
 * @par Description:
 *      Perform a write on the etct table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_etct_set(int unit, int index, etct_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(etct_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->primap_ndx;
    soc_CB_ETM_ETCT_IA_WDATA_PART0r_field_set(unit, &regval,
        PRIMAP_NDXf, &tmpval);
    tmpval = entry->pcp;
    soc_CB_ETM_ETCT_IA_WDATA_PART0r_field_set(unit, &regval,
        PCPf, &tmpval);
    tmpval = entry->dei;
    soc_CB_ETM_ETCT_IA_WDATA_PART0r_field_set(unit, &regval,
        DEIf, &tmpval);
    tmpval = entry->opcode;
    soc_CB_ETM_ETCT_IA_WDATA_PART0r_field_set(unit, &regval,
        OPCODEf, &tmpval);
    rc = REG_WRITE_CB_ETM_ETCT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_set: Failed writing CB_ETM_ETCT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(etct_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ETCT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "etct", index, rc, *status));
    }
    sal_mutex_give(etct_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h0_set
 * @par Description:
 *      Perform a write on the arlfm1_ght_h0 table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h0_set(int unit, int index, arlfm1_ght_h0_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(arlfm1_ght_h0_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART0r_field_set(unit, &regval,
        GHT_KEY_31_0_ARLFM1_MAC_LOf, &entry->ght_key_31_0_arlfm1_mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_set: Failed writing CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(arlfm1_ght_h0_mutex);
        return rc;
    }
    tmpval = entry->ght_key_47_32_arlfm1_mac_hi_15_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r_field_set(unit, &regval,
        GHT_KEY_47_32_ARLFM1_MAC_HI_15_0f, &tmpval);
    tmpval = entry->ght_key_59_48_arlfm1_fid_11_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r_field_set(unit, &regval,
        GHT_KEY_59_48_ARLFM1_FID_11_0f, &tmpval);
    tmpval = entry->ght_key_63_62_arlfm1_upd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r_field_set(unit, &regval,
        GHT_KEY_63_62_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    tmpval = entry->ght_key_61_60_arlfm1_fwd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r_field_set(unit, &regval,
        GHT_KEY_61_60_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_set: Failed writing CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(arlfm1_ght_h0_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART2r_field_set(unit, &regval,
        GHT_KEY_95_64_ARLFM1_MAC_LOf, &entry->ght_key_95_64_arlfm1_mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_set: Failed writing CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(arlfm1_ght_h0_mutex);
        return rc;
    }
    tmpval = entry->ght_key_111_96_arlfm1_mac_hi;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r_field_set(unit, &regval,
        GHT_KEY_111_96_ARLFM1_MAC_HIf, &tmpval);
    tmpval = entry->ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r_field_set(unit, &regval,
        GHT_N_VSI_11_10_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    tmpval = entry->ght_n_vsi_9_0_key_113_112_arlfm1_fid;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r_field_set(unit, &regval,
        GHT_N_VSI_9_0_KEY_113_112_ARLFM1_FIDf, &tmpval);
    tmpval = entry->ght_valid_litype_arlfm1_upd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r_field_set(unit, &regval,
        GHT_VALID_LITYPE_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_set: Failed writing CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(arlfm1_ght_h0_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H0_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "arlfm1_ght_h0", index, rc, *status));
    }
    sal_mutex_give(arlfm1_ght_h0_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pmon_set
 * @par Description:
 *      Perform a write on the cfp_pmon table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pmon_set(int unit, int index, cfp_pmon_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_pmon_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_CFP_PMON_IA_WDATA_PART0r_field_set(unit, &regval,
        COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_WRITE_CB_CFP_PMON_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_set: Failed writing CB_CFP_PMON_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(cfp_pmon_mutex);
        return rc;
    }
    soc_CB_CFP_PMON_IA_WDATA_PART1r_field_set(unit, &regval,
        COUNT_MSBSf, &entry->count_msbs);
    rc = REG_WRITE_CB_CFP_PMON_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_set: Failed writing CB_CFP_PMON_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(cfp_pmon_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PMON_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "cfp_pmon", index, rc, *status));
    }
    sal_mutex_give(cfp_pmon_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_max_config_set
 * @par Description:
 *      Perform a write on the max_config table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_max_config_set(int unit, int index, max_config_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(max_config_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->max_tx_bytes;
    soc_CB_PQS_MAX_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
        MAX_TX_BYTESf, &tmpval);
    tmpval = entry->max_tx_pkts;
    soc_CB_PQS_MAX_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
        MAX_TX_PKTSf, &tmpval);
    rc = REG_WRITE_CB_PQS_MAX_CONFIG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_set: Failed writing CB_PQS_MAX_CONFIG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(max_config_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MAX_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "max_config", index, rc, *status));
    }
    sal_mutex_give(max_config_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_profile_set
 * @par Description:
 *      Perform a write on the bmu_profile table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_profile_set(int unit, int index, bmu_profile_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_profile_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->cbs_exp;
    soc_CB_BMU_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CBS_EXPf, &tmpval);
    tmpval = entry->cbs_mantissa;
    soc_CB_BMU_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CBS_MANTISSAf, &tmpval);
    tmpval = entry->cir_mantissa;
    soc_CB_BMU_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CIR_MANTISSAf, &tmpval);
    tmpval = entry->cir_exp;
    soc_CB_BMU_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CIR_EXPf, &tmpval);
    rc = REG_WRITE_CB_BMU_PROFILE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_set: Failed writing CB_BMU_PROFILE_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(bmu_profile_mutex);
        return rc;
    }
    tmpval = entry->eir_exp;
    soc_CB_BMU_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EIR_EXPf, &tmpval);
    tmpval = entry->ebs_exp;
    soc_CB_BMU_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EBS_EXPf, &tmpval);
    tmpval = entry->eir_mantissa;
    soc_CB_BMU_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EIR_MANTISSAf, &tmpval);
    tmpval = entry->ebs_mantissa;
    soc_CB_BMU_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EBS_MANTISSAf, &tmpval);
    rc = REG_WRITE_CB_BMU_PROFILE_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_set: Failed writing CB_BMU_PROFILE_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(bmu_profile_mutex);
        return rc;
    }
    tmpval = entry->drop_on_red;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        DROP_ON_REDf, &tmpval);
    tmpval = entry->pkt_mode;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        PKT_MODEf, &tmpval);
    tmpval = entry->bktc_strict;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BKTC_STRICTf, &tmpval);
    tmpval = entry->bkte_strict;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BKTE_STRICTf, &tmpval);
    tmpval = entry->cf;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        CFf, &tmpval);
    tmpval = entry->rfc2698;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        RFC2698f, &tmpval);
    tmpval = entry->blind;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BLINDf, &tmpval);
    tmpval = entry->avb_mode;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        AVB_MODEf, &tmpval);
    rc = REG_WRITE_CB_BMU_PROFILE_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_set: Failed writing CB_BMU_PROFILE_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(bmu_profile_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "bmu_profile", index, rc, *status));
    }
    sal_mutex_give(bmu_profile_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pv2li_set
 * @par Description:
 *      Perform a write on the pv2li table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pv2li_set(int unit, int index, pv2li_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pv2li_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->pg_map;
    soc_CB_IPP_PV2LI_IA_WDATA_PART0r_field_set(unit, &regval,
        PG_MAPf, &tmpval);
    rc = REG_WRITE_CB_IPP_PV2LI_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_set: Failed writing CB_IPP_PV2LI_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pv2li_mutex);
        return rc;
    }
    tmpval = entry->vsi;
    soc_CB_IPP_PV2LI_IA_WDATA_PART1r_field_set(unit, &regval,
        VSIf, &tmpval);
    rc = REG_WRITE_CB_IPP_PV2LI_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_set: Failed writing CB_IPP_PV2LI_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(pv2li_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PV2LI_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pv2li", index, rc, *status));
    }
    sal_mutex_give(pv2li_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_rscale_set
 * @par Description:
 *      Perform a write on the ipp_rscale table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_rscale_set(int unit, int index, ipp_rscale_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ipp_rscale_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->scale;
    soc_CB_IPP_RSCALE_IA_WDATA_PART0r_field_set(unit, &regval,
        SCALEf, &tmpval);
    rc = REG_WRITE_CB_IPP_RSCALE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_set: Failed writing CB_IPP_RSCALE_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ipp_rscale_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ipp_rscale", index, rc, *status));
    }
    sal_mutex_give(ipp_rscale_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pmon_set
 * @par Description:
 *      Perform a write on the pqm_pmon table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pmon_set(int unit, int index, pqm_pmon_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_pmon_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_PQM_PMON_IA_WDATA_PART0r_field_set(unit, &regval,
        COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_WRITE_CB_PQM_PMON_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_set: Failed writing CB_PQM_PMON_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pqm_pmon_mutex);
        return rc;
    }
    soc_CB_PQM_PMON_IA_WDATA_PART1r_field_set(unit, &regval,
        COUNT_MSBSf, &entry->count_msbs);
    rc = REG_WRITE_CB_PQM_PMON_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_set: Failed writing CB_PQM_PMON_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(pqm_pmon_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PMON_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pqm_pmon", index, rc, *status));
    }
    sal_mutex_give(pqm_pmon_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ikft_set
 * @par Description:
 *      Perform a write on the ikft table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ikft_set(int unit, int index, ikft_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ikft_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->htype;
    soc_CB_IPP_IKFT_IA_WDATA_PART0r_field_set(unit, &regval,
        HTYPEf, &tmpval);
    rc = REG_WRITE_CB_IPP_IKFT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_set: Failed writing CB_IPP_IKFT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ikft_mutex);
        return rc;
    }
    tmpval = entry->hposn;
    soc_CB_IPP_IKFT_IA_WDATA_PART1r_field_set(unit, &regval,
        HPOSNf, &tmpval);
    tmpval = entry->offset;
    soc_CB_IPP_IKFT_IA_WDATA_PART1r_field_set(unit, &regval,
        OFFSETf, &tmpval);
    tmpval = entry->length;
    soc_CB_IPP_IKFT_IA_WDATA_PART1r_field_set(unit, &regval,
        LENGTHf, &tmpval);
    rc = REG_WRITE_CB_IPP_IKFT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_set: Failed writing CB_IPP_IKFT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(ikft_mutex);
        return rc;
    }
    tmpval = entry->key;
    soc_CB_IPP_IKFT_IA_WDATA_PART2r_field_set(unit, &regval,
        KEYf, &tmpval);
    tmpval = entry->exists;
    soc_CB_IPP_IKFT_IA_WDATA_PART2r_field_set(unit, &regval,
        EXISTSf, &tmpval);
    rc = REG_WRITE_CB_IPP_IKFT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_set: Failed writing CB_IPP_IKFT_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(ikft_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IKFT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ikft", index, rc, *status));
    }
    sal_mutex_give(ikft_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h1_set
 * @par Description:
 *      Perform a write on the arlfm1_ght_h1 table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h1_set(int unit, int index, arlfm1_ght_h1_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(arlfm1_ght_h1_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART0r_field_set(unit, &regval,
        GHT_KEY_31_0_ARLFM1_MAC_LOf, &entry->ght_key_31_0_arlfm1_mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_set: Failed writing CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(arlfm1_ght_h1_mutex);
        return rc;
    }
    tmpval = entry->ght_key_47_32_arlfm1_mac_hi_15_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r_field_set(unit, &regval,
        GHT_KEY_47_32_ARLFM1_MAC_HI_15_0f, &tmpval);
    tmpval = entry->ght_key_59_48_arlfm1_fid_11_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r_field_set(unit, &regval,
        GHT_KEY_59_48_ARLFM1_FID_11_0f, &tmpval);
    tmpval = entry->ght_key_63_62_arlfm1_upd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r_field_set(unit, &regval,
        GHT_KEY_63_62_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    tmpval = entry->ght_key_61_60_arlfm1_fwd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r_field_set(unit, &regval,
        GHT_KEY_61_60_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_set: Failed writing CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(arlfm1_ght_h1_mutex);
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART2r_field_set(unit, &regval,
        GHT_KEY_95_64_ARLFM1_MAC_LOf, &entry->ght_key_95_64_arlfm1_mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_set: Failed writing CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(arlfm1_ght_h1_mutex);
        return rc;
    }
    tmpval = entry->ght_key_111_96_arlfm1_mac_hi;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r_field_set(unit, &regval,
        GHT_KEY_111_96_ARLFM1_MAC_HIf, &tmpval);
    tmpval = entry->ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r_field_set(unit, &regval,
        GHT_N_VSI_11_10_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    tmpval = entry->ght_n_vsi_9_0_key_113_112_arlfm1_fid;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r_field_set(unit, &regval,
        GHT_N_VSI_9_0_KEY_113_112_ARLFM1_FIDf, &tmpval);
    tmpval = entry->ght_valid_litype_arlfm1_upd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r_field_set(unit, &regval,
        GHT_VALID_LITYPE_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_set: Failed writing CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(arlfm1_ght_h1_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H1_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "arlfm1_ght_h1", index, rc, *status));
    }
    sal_mutex_give(arlfm1_ght_h1_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epmt_set
 * @par Description:
 *      Perform a write on the epmt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epmt_set(int unit, int index, epmt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(epmt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_EPP_EPMT_IA_WDATA_PART0r_field_set(unit, &regval,
        PMT_DATAf, &entry->pmt_data);
    rc = REG_WRITE_CB_EPP_EPMT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_set: Failed writing CB_EPP_EPMT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(epmt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPMT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "epmt", index, rc, *status));
    }
    sal_mutex_give(epmt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_bmu_tx_reorder_req_lmt_set
 * @par Description:
 *      Perform a write on the epp_bmu_tx_reorder_req_lmt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_bmu_tx_reorder_req_lmt_set(int unit, int index, epp_bmu_tx_reorder_req_lmt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(epp_bmu_tx_reorder_req_lmt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->per_port_req_limit;
    soc_CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_WDATA_PART0r_field_set(unit, &regval,
        PER_PORT_REQ_LIMITf, &tmpval);
    rc = REG_WRITE_CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_set: Failed writing CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(epp_bmu_tx_reorder_req_lmt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "epp_bmu_tx_reorder_req_lmt", index, rc, *status));
    }
    sal_mutex_give(epp_bmu_tx_reorder_req_lmt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pptr_set
 * @par Description:
 *      Perform a write on the bmu_pptr table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pptr_set(int unit, int index, bmu_pptr_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(bmu_pptr_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->pointer;
    soc_CB_BMU_PPTR_IA_WDATA_PART0r_field_set(unit, &regval,
        POINTERf, &tmpval);
    rc = REG_WRITE_CB_BMU_PPTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_set: Failed writing CB_BMU_PPTR_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(bmu_pptr_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PPTR_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "bmu_pptr", index, rc, *status));
    }
    sal_mutex_give(bmu_pptr_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ert_set
 * @par Description:
 *      Perform a write on the ert table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ert_set(int unit, int index, ert_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ert_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->encap10;
    soc_CB_ETM_ERT_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP10f, &tmpval);
    tmpval = entry->encap9;
    soc_CB_ETM_ERT_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP9f, &tmpval);
    tmpval = entry->encap11;
    soc_CB_ETM_ERT_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP11f, &tmpval);
    tmpval = entry->encap8;
    soc_CB_ETM_ERT_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP8f, &tmpval);
    rc = REG_WRITE_CB_ETM_ERT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_set: Failed writing CB_ETM_ERT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ert_mutex);
        return rc;
    }
    tmpval = entry->encap4;
    soc_CB_ETM_ERT_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP4f, &tmpval);
    tmpval = entry->encap5;
    soc_CB_ETM_ERT_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP5f, &tmpval);
    tmpval = entry->encap7;
    soc_CB_ETM_ERT_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP7f, &tmpval);
    tmpval = entry->encap6;
    soc_CB_ETM_ERT_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP6f, &tmpval);
    rc = REG_WRITE_CB_ETM_ERT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_set: Failed writing CB_ETM_ERT_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(ert_mutex);
        return rc;
    }
    tmpval = entry->encap2;
    soc_CB_ETM_ERT_IA_WDATA_PART2r_field_set(unit, &regval,
        ENCAP2f, &tmpval);
    tmpval = entry->encap3;
    soc_CB_ETM_ERT_IA_WDATA_PART2r_field_set(unit, &regval,
        ENCAP3f, &tmpval);
    tmpval = entry->encap0;
    soc_CB_ETM_ERT_IA_WDATA_PART2r_field_set(unit, &regval,
        ENCAP0f, &tmpval);
    tmpval = entry->encap1;
    soc_CB_ETM_ERT_IA_WDATA_PART2r_field_set(unit, &regval,
        ENCAP1f, &tmpval);
    rc = REG_WRITE_CB_ETM_ERT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_set: Failed writing CB_ETM_ERT_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(ert_mutex);
        return rc;
    }
    tmpval = entry->full;
    soc_CB_ETM_ERT_IA_WDATA_PART3r_field_set(unit, &regval,
        FULLf, &tmpval);
    rc = REG_WRITE_CB_ETM_ERT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_set: Failed writing CB_ETM_ERT_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(ert_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ERT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ert", index, rc, *status));
    }
    sal_mutex_give(ert_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_action_set
 * @par Description:
 *      Perform a write on the action table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_action_set(int unit, int index, action_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(action_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->ipf_learn_disable;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
        IPF_LEARN_DISABLEf, &tmpval);
    tmpval = entry->ipf_trap_offset;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
        IPF_TRAP_OFFSETf, &tmpval);
    tmpval = entry->ipf_mirror;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
        IPF_MIRRORf, &tmpval);
    tmpval = entry->ipf_change_tc;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
        IPF_CHANGE_TCf, &tmpval);
    tmpval = entry->ipf_tc;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
        IPF_TCf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_set: Failed writing CB_CFP_ACTION_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(action_mutex);
        return rc;
    }
    tmpval = entry->ipf_dliid_dgid_sliid;
    soc_CB_CFP_ACTION_IA_WDATA_PART1r_field_set(unit, &regval,
        IPF_DLIID_DGID_SLIIDf, &tmpval);
    tmpval = entry->ipf_change_fwd;
    soc_CB_CFP_ACTION_IA_WDATA_PART1r_field_set(unit, &regval,
        IPF_CHANGE_FWDf, &tmpval);
    tmpval = entry->ipf_cfp_decap;
    soc_CB_CFP_ACTION_IA_WDATA_PART1r_field_set(unit, &regval,
        IPF_CFP_DECAPf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_set: Failed writing CB_CFP_ACTION_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(action_mutex);
        return rc;
    }
    tmpval = entry->opf_tc;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
        OPF_TCf, &tmpval);
    tmpval = entry->opf_trap_offset;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
        OPF_TRAP_OFFSETf, &tmpval);
    tmpval = entry->opf_learn_disable;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
        OPF_LEARN_DISABLEf, &tmpval);
    tmpval = entry->opf_change_tc;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
        OPF_CHANGE_TCf, &tmpval);
    tmpval = entry->opf_mirror;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
        OPF_MIRRORf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_set: Failed writing CB_CFP_ACTION_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(action_mutex);
        return rc;
    }
    tmpval = entry->opf_change_fwd;
    soc_CB_CFP_ACTION_IA_WDATA_PART3r_field_set(unit, &regval,
        OPF_CHANGE_FWDf, &tmpval);
    tmpval = entry->opf_dliid_dgid_sliid;
    soc_CB_CFP_ACTION_IA_WDATA_PART3r_field_set(unit, &regval,
        OPF_DLIID_DGID_SLIIDf, &tmpval);
    tmpval = entry->opf_cfp_decap;
    soc_CB_CFP_ACTION_IA_WDATA_PART3r_field_set(unit, &regval,
        OPF_CFP_DECAPf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_set: Failed writing CB_CFP_ACTION_IA_WDATA_PART3 register rc %d \n", rc));
        sal_mutex_give(action_mutex);
        return rc;
    }
    tmpval = entry->dp;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
        DPf, &tmpval);
    tmpval = entry->counter_mode;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
        COUNTER_MODEf, &tmpval);
    tmpval = entry->meter;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
        METERf, &tmpval);
    tmpval = entry->override;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
        OVERRIDEf, &tmpval);
    tmpval = entry->change_dp;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
        CHANGE_DPf, &tmpval);
    tmpval = entry->sli_lpbk_ena;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
        SLI_LPBK_ENAf, &tmpval);
    tmpval = entry->dlf_override;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
        DLF_OVERRIDEf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_set: Failed writing CB_CFP_ACTION_IA_WDATA_PART4 register rc %d \n", rc));
        sal_mutex_give(action_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ACTION_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "action", index, rc, *status));
    }
    sal_mutex_give(action_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpslict_set
 * @par Description:
 *      Perform a write on the rpslict table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpslict_set(int unit, int index, rpslict_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(rpslict_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->early_ack;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        EARLY_ACKf, &tmpval);
    tmpval = entry->use_tc;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        USE_TCf, &tmpval);
    tmpval = entry->use_dp;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        USE_DPf, &tmpval);
    tmpval = entry->default_tc;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        DEFAULT_TCf, &tmpval);
    tmpval = entry->default_dp;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
        DEFAULT_DPf, &tmpval);
    rc = REG_WRITE_CB_IPP_RPSLICT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_set: Failed writing CB_IPP_RPSLICT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(rpslict_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPSLICT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "rpslict", index, rc, *status));
    }
    sal_mutex_give(rpslict_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slictecc_set
 * @par Description:
 *      Perform a write on the slictecc table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slictecc_set(int unit, int index, slictecc_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(slictecc_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->ecc;
    soc_CB_IPP_SLICTECC_IA_WDATA_PART0r_field_set(unit, &regval,
        ECCf, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICTECC_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_set: Failed writing CB_IPP_SLICTECC_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(slictecc_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICTECC_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "slictecc", index, rc, *status));
    }
    sal_mutex_give(slictecc_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_litet_set
 * @par Description:
 *      Perform a write on the litet table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_litet_set(int unit, int index, litet_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(litet_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->tx_ena;
    soc_CB_PQM_LITET_IA_WDATA_PART0r_field_set(unit, &regval,
        TX_ENAf, &tmpval);
    rc = REG_WRITE_CB_PQM_LITET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_set: Failed writing CB_PQM_LITET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(litet_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LITET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "litet", index, rc, *status));
    }
    sal_mutex_give(litet_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tecc_set
 * @par Description:
 *      Perform a write on the tecc table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tecc_set(int unit, int index, tecc_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(tecc_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->ecc;
    soc_CB_CFP_TECC_IA_WDATA_PART0r_field_set(unit, &regval,
        ECCf, &tmpval);
    rc = REG_WRITE_CB_CFP_TECC_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_set: Failed writing CB_CFP_TECC_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(tecc_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TECC_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "tecc", index, rc, *status));
    }
    sal_mutex_give(tecc_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pptr_set
 * @par Description:
 *      Perform a write on the cfp_pptr table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pptr_set(int unit, int index, cfp_pptr_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cfp_pptr_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->pointer;
    soc_CB_CFP_PPTR_IA_WDATA_PART0r_field_set(unit, &regval,
        POINTERf, &tmpval);
    rc = REG_WRITE_CB_CFP_PPTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_set: Failed writing CB_CFP_PPTR_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(cfp_pptr_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PPTR_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "cfp_pptr", index, rc, *status));
    }
    sal_mutex_give(cfp_pptr_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wrt_set
 * @par Description:
 *      Perform a write on the wrt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wrt_set(int unit, int index, wrt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(wrt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->wide_rule_entry;
    soc_CB_CFP_WRT_IA_WDATA_PART0r_field_set(unit, &regval,
        WIDE_RULE_ENTRYf, &tmpval);
    rc = REG_WRITE_CB_CFP_WRT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_set: Failed writing CB_CFP_WRT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(wrt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WRT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "wrt", index, rc, *status));
    }
    sal_mutex_give(wrt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wpt_set
 * @par Description:
 *      Perform a write on the wpt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wpt_set(int unit, int index, wpt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(wpt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->gain;
    soc_CB_PQM_WPT_IA_WDATA_PART0r_field_set(unit, &regval,
        GAINf, &tmpval);
    tmpval = entry->scale;
    soc_CB_PQM_WPT_IA_WDATA_PART0r_field_set(unit, &regval,
        SCALEf, &tmpval);
    rc = REG_WRITE_CB_PQM_WPT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_set: Failed writing CB_PQM_WPT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(wpt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WPT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "wpt", index, rc, *status));
    }
    sal_mutex_give(wpt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dliet_set
 * @par Description:
 *      Perform a write on the dliet table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dliet_set(int unit, int index, dliet_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(dliet_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->encap4;
    soc_CB_ETM_DLIET_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP4f, &tmpval);
    tmpval = entry->encap5;
    soc_CB_ETM_DLIET_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP5f, &tmpval);
    tmpval = entry->encap7;
    soc_CB_ETM_DLIET_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP7f, &tmpval);
    tmpval = entry->encap6;
    soc_CB_ETM_DLIET_IA_WDATA_PART0r_field_set(unit, &regval,
        ENCAP6f, &tmpval);
    rc = REG_WRITE_CB_ETM_DLIET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_set: Failed writing CB_ETM_DLIET_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(dliet_mutex);
        return rc;
    }
    tmpval = entry->encap2;
    soc_CB_ETM_DLIET_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP2f, &tmpval);
    tmpval = entry->encap3;
    soc_CB_ETM_DLIET_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP3f, &tmpval);
    tmpval = entry->encap0;
    soc_CB_ETM_DLIET_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP0f, &tmpval);
    tmpval = entry->encap1;
    soc_CB_ETM_DLIET_IA_WDATA_PART1r_field_set(unit, &regval,
        ENCAP1f, &tmpval);
    rc = REG_WRITE_CB_ETM_DLIET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_set: Failed writing CB_ETM_DLIET_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(dliet_mutex);
        return rc;
    }
    tmpval = entry->uc_encap_ptr;
    soc_CB_ETM_DLIET_IA_WDATA_PART2r_field_set(unit, &regval,
        UC_ENCAP_PTRf, &tmpval);
    tmpval = entry->mc_encap_ptr;
    soc_CB_ETM_DLIET_IA_WDATA_PART2r_field_set(unit, &regval,
        MC_ENCAP_PTRf, &tmpval);
    tmpval = entry->full;
    soc_CB_ETM_DLIET_IA_WDATA_PART2r_field_set(unit, &regval,
        FULLf, &tmpval);
    rc = REG_WRITE_CB_ETM_DLIET_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_set: Failed writing CB_ETM_DLIET_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(dliet_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLIET_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "dliet", index, rc, *status));
    }
    sal_mutex_give(dliet_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pglct_set
 * @par Description:
 *      Perform a write on the pglct table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pglct_set(int unit, int index, pglct_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pglct_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->disable_update_static;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        DISABLE_UPDATE_STATICf, &tmpval);
    tmpval = entry->copy_unknown_smac;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        COPY_UNKNOWN_SMACf, &tmpval);
    tmpval = entry->pend_learn;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        PEND_LEARNf, &tmpval);
    tmpval = entry->copy_update;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        COPY_UPDATEf, &tmpval);
    tmpval = entry->disable_update_pending;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        DISABLE_UPDATE_PENDINGf, &tmpval);
    tmpval = entry->copy_update_static;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        COPY_UPDATE_STATICf, &tmpval);
    tmpval = entry->copy_overlimit;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        COPY_OVERLIMITf, &tmpval);
    tmpval = entry->disable_update;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        DISABLE_UPDATEf, &tmpval);
    tmpval = entry->disable_learn;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        DISABLE_LEARNf, &tmpval);
    tmpval = entry->learn_limit;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        LEARN_LIMITf, &tmpval);
    tmpval = entry->valid_for_n_type;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        VALID_FOR_N_TYPEf, &tmpval);
    tmpval = entry->drop_overlimit;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        DROP_OVERLIMITf, &tmpval);
    tmpval = entry->copy_update_pending;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
        COPY_UPDATE_PENDINGf, &tmpval);
    rc = REG_WRITE_CB_ITM_PGLCT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_set: Failed writing CB_ITM_PGLCT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pglct_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGLCT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pglct", index, rc, *status));
    }
    sal_mutex_give(pglct_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ap_set
 * @par Description:
 *      Perform a write on the lpg2ap table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ap_set(int unit, int index, lpg2ap_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(lpg2ap_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->adm_profile;
    soc_CB_PQM_LPG2AP_IA_WDATA_PART0r_field_set(unit, &regval,
        ADM_PROFILEf, &tmpval);
    rc = REG_WRITE_CB_PQM_LPG2AP_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_set: Failed writing CB_PQM_LPG2AP_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(lpg2ap_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2AP_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "lpg2ap", index, rc, *status));
    }
    sal_mutex_give(lpg2ap_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_profile_set
 * @par Description:
 *      Perform a write on the pqm_profile table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_profile_set(int unit, int index, pqm_profile_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_profile_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->cbs_exp;
    soc_CB_PQM_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CBS_EXPf, &tmpval);
    tmpval = entry->cbs_mantissa;
    soc_CB_PQM_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CBS_MANTISSAf, &tmpval);
    tmpval = entry->cir_mantissa;
    soc_CB_PQM_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CIR_MANTISSAf, &tmpval);
    tmpval = entry->cir_exp;
    soc_CB_PQM_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
        CIR_EXPf, &tmpval);
    rc = REG_WRITE_CB_PQM_PROFILE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_set: Failed writing CB_PQM_PROFILE_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pqm_profile_mutex);
        return rc;
    }
    tmpval = entry->eir_exp;
    soc_CB_PQM_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EIR_EXPf, &tmpval);
    tmpval = entry->ebs_exp;
    soc_CB_PQM_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EBS_EXPf, &tmpval);
    tmpval = entry->eir_mantissa;
    soc_CB_PQM_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EIR_MANTISSAf, &tmpval);
    tmpval = entry->ebs_mantissa;
    soc_CB_PQM_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
        EBS_MANTISSAf, &tmpval);
    rc = REG_WRITE_CB_PQM_PROFILE_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_set: Failed writing CB_PQM_PROFILE_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(pqm_profile_mutex);
        return rc;
    }
    tmpval = entry->drop_on_red;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        DROP_ON_REDf, &tmpval);
    tmpval = entry->pkt_mode;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        PKT_MODEf, &tmpval);
    tmpval = entry->bktc_strict;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BKTC_STRICTf, &tmpval);
    tmpval = entry->bkte_strict;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BKTE_STRICTf, &tmpval);
    tmpval = entry->cf;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        CFf, &tmpval);
    tmpval = entry->rfc2698;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        RFC2698f, &tmpval);
    tmpval = entry->blind;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        BLINDf, &tmpval);
    tmpval = entry->avb_mode;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
        AVB_MODEf, &tmpval);
    rc = REG_WRITE_CB_PQM_PROFILE_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_set: Failed writing CB_PQM_PROFILE_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(pqm_profile_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pqm_profile", index, rc, *status));
    }
    sal_mutex_give(pqm_profile_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cpmt_set
 * @par Description:
 *      Perform a write on the cpmt table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cpmt_set(int unit, int index, cpmt_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(cpmt_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->tc;
    soc_CB_IPP_CPMT_IA_WDATA_PART0r_field_set(unit, &regval,
        TCf, &tmpval);
    tmpval = entry->dp;
    soc_CB_IPP_CPMT_IA_WDATA_PART0r_field_set(unit, &regval,
        DPf, &tmpval);
    rc = REG_WRITE_CB_IPP_CPMT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_set: Failed writing CB_IPP_CPMT_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(cpmt_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CPMT_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "cpmt", index, rc, *status));
    }
    sal_mutex_give(cpmt_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pp2lpg_set
 * @par Description:
 *      Perform a write on the pqm_pp2lpg table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pp2lpg_set(int unit, int index, pqm_pp2lpg_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(pqm_pp2lpg_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    tmpval = entry->pgid;
    soc_CB_PQM_PP2LPG_IA_WDATA_PART0r_field_set(unit, &regval,
        PGIDf, &tmpval);
    rc = REG_WRITE_CB_PQM_PP2LPG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_set: Failed writing CB_PQM_PP2LPG_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(pqm_pp2lpg_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PP2LPG_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "pqm_pp2lpg", index, rc, *status));
    }
    sal_mutex_give(pqm_pp2lpg_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ofarlfm_set
 * @par Description:
 *      Perform a write on the ofarlfm table, set the entry at given index
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  index  :  index of entry in table to be read
 *    @param [in]  entry :  pointer to entry to be written
 *    @param [out] status:  hardware status of the write operation
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ofarlfm_set(int unit, int index, ofarlfm_t *entry, uint32 *status)
{
    int rc = SOC_E_NONE;
    uint32 regval = 0;
    uint32 tmpval = 0;
   
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_set: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    sal_mutex_take(ofarlfm_mutex, sal_mutex_FOREVER);
    /* Set the wdata register with the fields */
    soc_CB_ITM_OFARLFM_IA_WDATA_PART0r_field_set(unit, &regval,
        MAC_LOf, &entry->mac_lo);
    rc = REG_WRITE_CB_ITM_OFARLFM_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_set: Failed writing CB_ITM_OFARLFM_IA_WDATA_PART0 register rc %d \n", rc));
        sal_mutex_give(ofarlfm_mutex);
        return rc;
    }
    tmpval = entry->fid;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
        FIDf, &tmpval);
    tmpval = entry->upd_ctrl;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
        UPD_CTRLf, &tmpval);
    tmpval = entry->mac_hi;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
        MAC_HIf, &tmpval);
    tmpval = entry->fwd_ctrl;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
        FWD_CTRLf, &tmpval);
    rc = REG_WRITE_CB_ITM_OFARLFM_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_set: Failed writing CB_ITM_OFARLFM_IA_WDATA_PART1 register rc %d \n", rc));
        sal_mutex_give(ofarlfm_mutex);
        return rc;
    }
    tmpval = entry->valid;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
        VALIDf, &tmpval);
    tmpval = entry->dst;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
        DSTf, &tmpval);
    tmpval = entry->dst_type;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
        DST_TYPEf, &tmpval);
    tmpval = entry->hit;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
        HITf, &tmpval);
    rc = REG_WRITE_CB_ITM_OFARLFM_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_set: Failed writing CB_ITM_OFARLFM_IA_WDATA_PART2 register rc %d \n", rc));
        sal_mutex_give(ofarlfm_mutex);
        return rc;
    }

    /* Initiate table write */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_OFARLFM_ID, 
             ROBO2_IA_OP_TABLE_WRITE, index, status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_set:"
                "Failed writing table %s index %d rc %d hwsts 0x%x\n",
                "ofarlfm", index, rc, *status));
    }
    sal_mutex_give(ofarlfm_mutex);
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tct_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tct_init(int unit, int start, int end, int inc, tct_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->drop;
    soc_CB_IPP_TCT_IA_WDATA_PART0r_field_set(unit, &regval,
             DROPf, &tmpval);
    tmpval = entry->term;
    soc_CB_IPP_TCT_IA_WDATA_PART0r_field_set(unit, &regval,
             TERMf, &tmpval);
    tmpval = entry->trap_group;
    soc_CB_IPP_TCT_IA_WDATA_PART0r_field_set(unit, &regval,
             TRAP_GROUPf, &tmpval);
    rc = REG_WRITE_CB_IPP_TCT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_init: Failed writing CB_IPP_TCT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TCT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_init: Failed setting start of table %s status %x\n", 
                "tct", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TCT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_init: Failed Initialize table %s status %x\n", 
                "tct", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpt_init(int unit, int start, int end, int inc, rpt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->source;
    soc_CB_IPP_RPT_IA_WDATA_PART0r_field_set(unit, &regval,
             SOURCEf, &tmpval);
    rc = REG_WRITE_CB_IPP_RPT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_init: Failed writing CB_IPP_RPT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->hi;
    soc_CB_IPP_RPT_IA_WDATA_PART1r_field_set(unit, &regval,
             HIf, &tmpval);
    tmpval = entry->lo;
    soc_CB_IPP_RPT_IA_WDATA_PART1r_field_set(unit, &regval,
             LOf, &tmpval);
    rc = REG_WRITE_CB_IPP_RPT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_init: Failed writing CB_IPP_RPT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_init: Failed setting start of table %s status %x\n", 
                "rpt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_init: Failed Initialize table %s status %x\n", 
                "rpt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pgt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pgt_init(int unit, int start, int end, int inc, pgt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->pppoe_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             PPPOE_ENf, &tmpval);
    tmpval = entry->itag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             ITAG_ENf, &tmpval);
    tmpval = entry->tag_parse_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             TAG_PARSE_ENf, &tmpval);
    tmpval = entry->ipv4_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             IPV4_ENf, &tmpval);
    tmpval = entry->slic_map_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             SLIC_MAP_ENf, &tmpval);
    tmpval = entry->ctag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             CTAG_ENf, &tmpval);
    tmpval = entry->soft_tag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             SOFT_TAG_ENf, &tmpval);
    tmpval = entry->mcmpls_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             MCMPLS_ENf, &tmpval);
    tmpval = entry->metadata_len;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             METADATA_LENf, &tmpval);
    tmpval = entry->llc_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             LLC_ENf, &tmpval);
    tmpval = entry->ptp_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             PTP_ENf, &tmpval);
    tmpval = entry->etag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             ETAG_ENf, &tmpval);
    tmpval = entry->stag_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             STAG_ENf, &tmpval);
    tmpval = entry->ipv6_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             IPV6_ENf, &tmpval);
    tmpval = entry->tlv_parse_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             TLV_PARSE_ENf, &tmpval);
    tmpval = entry->arp_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             ARP_ENf, &tmpval);
    tmpval = entry->ucmpls_en;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             UCMPLS_ENf, &tmpval);
    tmpval = entry->hdr_words_m1;
    soc_CB_IPP_PGT_IA_WDATA_PART0r_field_set(unit, &regval,
             HDR_WORDS_M1f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->len0;
    soc_CB_IPP_PGT_IA_WDATA_PART1r_field_set(unit, &regval,
             LEN0f, &tmpval);
    tmpval = entry->proto1;
    soc_CB_IPP_PGT_IA_WDATA_PART1r_field_set(unit, &regval,
             PROTO1f, &tmpval);
    tmpval = entry->proto0;
    soc_CB_IPP_PGT_IA_WDATA_PART1r_field_set(unit, &regval,
             PROTO0f, &tmpval);
    tmpval = entry->len1;
    soc_CB_IPP_PGT_IA_WDATA_PART1r_field_set(unit, &regval,
             LEN1f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->arb4;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             ARB4f, &tmpval);
    tmpval = entry->arb1;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             ARB1f, &tmpval);
    tmpval = entry->arb7;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             ARB7f, &tmpval);
    tmpval = entry->arb3;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             ARB3f, &tmpval);
    tmpval = entry->src2;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             SRC2f, &tmpval);
    tmpval = entry->arb2;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             ARB2f, &tmpval);
    tmpval = entry->src0;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             SRC0f, &tmpval);
    tmpval = entry->src1;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             SRC1f, &tmpval);
    tmpval = entry->arb0;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             ARB0f, &tmpval);
    tmpval = entry->arb6;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             ARB6f, &tmpval);
    tmpval = entry->arb5;
    soc_CB_IPP_PGT_IA_WDATA_PART2r_field_set(unit, &regval,
             ARB5f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->pri_base0;
    soc_CB_IPP_PGT_IA_WDATA_PART3r_field_set(unit, &regval,
             PRI_BASE0f, &tmpval);
    tmpval = entry->default_tc;
    soc_CB_IPP_PGT_IA_WDATA_PART3r_field_set(unit, &regval,
             DEFAULT_TCf, &tmpval);
    tmpval = entry->default_dp;
    soc_CB_IPP_PGT_IA_WDATA_PART3r_field_set(unit, &regval,
             DEFAULT_DPf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->pri_base1;
    soc_CB_IPP_PGT_IA_WDATA_PART4r_field_set(unit, &regval,
             PRI_BASE1f, &tmpval);
    tmpval = entry->pri_base2;
    soc_CB_IPP_PGT_IA_WDATA_PART4r_field_set(unit, &regval,
             PRI_BASE2f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART4 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->fcd3;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
             FCD3f, &tmpval);
    tmpval = entry->fcd4;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
             FCD4f, &tmpval);
    tmpval = entry->fcd2;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
             FCD2f, &tmpval);
    tmpval = entry->fcd1;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
             FCD1f, &tmpval);
    tmpval = entry->fcd5;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
             FCD5f, &tmpval);
    tmpval = entry->fcd6;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
             FCD6f, &tmpval);
    tmpval = entry->fcd7;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
             FCD7f, &tmpval);
    tmpval = entry->fcd0;
    soc_CB_IPP_PGT_IA_WDATA_PART5r_field_set(unit, &regval,
             FCD0f, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART5 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->mirror;
    soc_CB_IPP_PGT_IA_WDATA_PART6r_field_set(unit, &regval,
             MIRRORf, &tmpval);
    tmpval = entry->pepper;
    soc_CB_IPP_PGT_IA_WDATA_PART6r_field_set(unit, &regval,
             PEPPERf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART6 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->vid_src;
    soc_CB_IPP_PGT_IA_WDATA_PART7r_field_set(unit, &regval,
             VID_SRCf, &tmpval);
    tmpval = entry->default_vid;
    soc_CB_IPP_PGT_IA_WDATA_PART7r_field_set(unit, &regval,
             DEFAULT_VIDf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART7r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART7 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->default_sli;
    soc_CB_IPP_PGT_IA_WDATA_PART8r_field_set(unit, &regval,
             DEFAULT_SLIf, &tmpval);
    tmpval = entry->default_slicid;
    soc_CB_IPP_PGT_IA_WDATA_PART8r_field_set(unit, &regval,
             DEFAULT_SLICIDf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART8r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART8 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->dfp_en;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
             DFP_ENf, &tmpval);
    tmpval = entry->drop_ulf;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
             DROP_ULFf, &tmpval);
    tmpval = entry->ipp_meter_sets_dp;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
             IPP_METER_SETS_DPf, &tmpval);
    tmpval = entry->spgid;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
             SPGIDf, &tmpval);
    tmpval = entry->drop_slf;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
             DROP_SLFf, &tmpval);
    tmpval = entry->drop_mlf;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
             DROP_MLFf, &tmpval);
    tmpval = entry->drop_bcast;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
             DROP_BCASTf, &tmpval);
    tmpval = entry->rp_extra;
    soc_CB_IPP_PGT_IA_WDATA_PART9r_field_set(unit, &regval,
             RP_EXTRAf, &tmpval);
    rc = REG_WRITE_CB_IPP_PGT_IA_WDATA_PART9r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed writing CB_IPP_PGT_IA_WDATA_PART9 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed setting start of table %s status %x\n", 
                "pgt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_init: Failed Initialize table %s status %x\n", 
                "pgt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pmipage_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pmipage_init(int unit, int start, int end, int inc, pmipage_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->phypagevld;
    soc_CB_PMI_PMIPAGE_IA_WDATA_PART0r_field_set(unit, &regval,
             PHYPAGEVLDf, &tmpval);
    tmpval = entry->phypage;
    soc_CB_PMI_PMIPAGE_IA_WDATA_PART0r_field_set(unit, &regval,
             PHYPAGEf, &tmpval);
    rc = REG_WRITE_CB_PMI_PMIPAGE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_init: Failed writing CB_PMI_PMIPAGE_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PMIPAGE_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_init: Failed setting start of table %s status %x\n", 
                "pmipage", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PMIPAGE_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_init: Failed Initialize table %s status %x\n", 
                "pmipage", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_config_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_config_init(int unit, int start, int end, int inc, gfcd_config_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->thresh1;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
             THRESH1f, &tmpval);
    tmpval = entry->thresh0;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
             THRESH0f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->thresh3;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART1r_field_set(unit, &regval,
             THRESH3f, &tmpval);
    tmpval = entry->thresh2;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART1r_field_set(unit, &regval,
             THRESH2f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->counter_enable;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
             COUNTER_ENABLEf, &tmpval);
    tmpval = entry->gfc_enable;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
             GFC_ENABLEf, &tmpval);
    tmpval = entry->hysteresis;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
             HYSTERESISf, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->tc_pp_bmp_3;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r_field_set(unit, &regval,
             TC_PP_BMP_3f, &tmpval);
    tmpval = entry->tc_pp_bmp_2;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r_field_set(unit, &regval,
             TC_PP_BMP_2f, &tmpval);
    tmpval = entry->tc_pp_bmp_1;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r_field_set(unit, &regval,
             TC_PP_BMP_1f, &tmpval);
    tmpval = entry->tc_pp_bmp_0;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r_field_set(unit, &regval,
             TC_PP_BMP_0f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->tc_pp_bmp_5;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r_field_set(unit, &regval,
             TC_PP_BMP_5f, &tmpval);
    tmpval = entry->tc_pp_bmp_7;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r_field_set(unit, &regval,
             TC_PP_BMP_7f, &tmpval);
    tmpval = entry->tc_pp_bmp_4;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r_field_set(unit, &regval,
             TC_PP_BMP_4f, &tmpval);
    tmpval = entry->tc_pp_bmp_6;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r_field_set(unit, &regval,
             TC_PP_BMP_6f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART4 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->tc_pp_bmp_9;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r_field_set(unit, &regval,
             TC_PP_BMP_9f, &tmpval);
    tmpval = entry->tc_pp_bmp_8;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r_field_set(unit, &regval,
             TC_PP_BMP_8f, &tmpval);
    tmpval = entry->tc_pp_bmp_10;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r_field_set(unit, &regval,
             TC_PP_BMP_10f, &tmpval);
    tmpval = entry->tc_pp_bmp_11;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r_field_set(unit, &regval,
             TC_PP_BMP_11f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART5 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->tc_pp_bmp_14;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r_field_set(unit, &regval,
             TC_PP_BMP_14f, &tmpval);
    tmpval = entry->tc_pp_bmp_15;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r_field_set(unit, &regval,
             TC_PP_BMP_15f, &tmpval);
    tmpval = entry->tc_pp_bmp_13;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r_field_set(unit, &regval,
             TC_PP_BMP_13f, &tmpval);
    tmpval = entry->tc_pp_bmp_12;
    soc_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r_field_set(unit, &regval,
             TC_PP_BMP_12f, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CONFIG_IA_WDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Failed writing CB_BMU_GFCD_CONFIG_IA_WDATA_PART6 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CONFIG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Failed setting start of table %s status %x\n", 
                "gfcd_config", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CONFIG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_init: Failed Initialize table %s status %x\n", 
                "gfcd_config", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_apt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_apt_init(int unit, int start, int end, int inc, apt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->drop_thresh;
    soc_CB_PQM_APT_IA_WDATA_PART0r_field_set(unit, &regval,
             DROP_THRESHf, &tmpval);
    rc = REG_WRITE_CB_PQM_APT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_init: Failed writing CB_PQM_APT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->wred_m;
    soc_CB_PQM_APT_IA_WDATA_PART1r_field_set(unit, &regval,
             WRED_Mf, &tmpval);
    rc = REG_WRITE_CB_PQM_APT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_init: Failed writing CB_PQM_APT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->wred_c;
    soc_CB_PQM_APT_IA_WDATA_PART2r_field_set(unit, &regval,
             WRED_Cf, &tmpval);
    rc = REG_WRITE_CB_PQM_APT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_init: Failed writing CB_PQM_APT_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_APT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_init: Failed setting start of table %s status %x\n", 
                "apt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_APT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_init: Failed Initialize table %s status %x\n", 
                "apt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_cntr_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_cntr_init(int unit, int start, int end, int inc, gfcd_cntr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->page_cnt;
    soc_CB_BMU_GFCD_CNTR_IA_WDATA_PART0r_field_set(unit, &regval,
             PAGE_CNTf, &tmpval);
    rc = REG_WRITE_CB_BMU_GFCD_CNTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_init: Failed writing CB_BMU_GFCD_CNTR_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CNTR_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_init: Failed setting start of table %s status %x\n", 
                "gfcd_cntr", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CNTR_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_init: Failed Initialize table %s status %x\n", 
                "gfcd_cntr", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spg_pp_bmp_config_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spg_pp_bmp_config_init(int unit, int start, int end, int inc, spg_pp_bmp_config_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->spg_pp_bmp;
    soc_CB_BMU_SPG_PP_BMP_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
             SPG_PP_BMPf, &tmpval);
    rc = REG_WRITE_CB_BMU_SPG_PP_BMP_CONFIG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_init: Failed writing CB_BMU_SPG_PP_BMP_CONFIG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_init: Failed setting start of table %s status %x\n", 
                "spg_pp_bmp_config", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_init: Failed Initialize table %s status %x\n", 
                "spg_pp_bmp_config", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dgt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dgt_init(int unit, int start, int end, int inc, dgt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->lilt_type;
    soc_CB_PQM_DGT_IA_WDATA_PART0r_field_set(unit, &regval,
             LILT_TYPEf, &tmpval);
    tmpval = entry->lilt_ndx;
    soc_CB_PQM_DGT_IA_WDATA_PART0r_field_set(unit, &regval,
             LILT_NDXf, &tmpval);
    rc = REG_WRITE_CB_PQM_DGT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_init: Failed writing CB_PQM_DGT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->pgfov;
    soc_CB_PQM_DGT_IA_WDATA_PART1r_field_set(unit, &regval,
             PGFOVf, &tmpval);
    rc = REG_WRITE_CB_PQM_DGT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_init: Failed writing CB_PQM_DGT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DGT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_init: Failed setting start of table %s status %x\n", 
                "dgt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DGT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_init: Failed Initialize table %s status %x\n", 
                "dgt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gspg2ig_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gspg2ig_init(int unit, int start, int end, int inc, gspg2ig_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->ig;
    soc_CB_IPP_GSPG2IG_IA_WDATA_PART0r_field_set(unit, &regval,
             IGf, &tmpval);
    rc = REG_WRITE_CB_IPP_GSPG2IG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_init: Failed writing CB_IPP_GSPG2IG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GSPG2IG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_init: Failed setting start of table %s status %x\n", 
                "gspg2ig", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GSPG2IG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_init: Failed Initialize table %s status %x\n", 
                "gspg2ig", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_calendar_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_calendar_init(int unit, int start, int end, int inc, epp_calendar_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->slot_port;
    soc_CB_EPP_EPP_CALENDAR_IA_WDATA_PART0r_field_set(unit, &regval,
             SLOT_PORTf, &tmpval);
    rc = REG_WRITE_CB_EPP_EPP_CALENDAR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_init: Failed writing CB_EPP_EPP_CALENDAR_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_CALENDAR_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_init: Failed setting start of table %s status %x\n", 
                "epp_calendar", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_CALENDAR_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_init: Failed Initialize table %s status %x\n", 
                "epp_calendar", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ght_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ght_init(int unit, int start, int end, int inc, ght_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_ITM_GHT_IA_WDATA_PART0r_field_set(unit, &regval, 
             KEY_31_0f, &entry->key_31_0);
    rc = REG_WRITE_CB_ITM_GHT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_init: Failed writing CB_ITM_GHT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    soc_CB_ITM_GHT_IA_WDATA_PART1r_field_set(unit, &regval, 
             KEY_63_32f, &entry->key_63_32);
    rc = REG_WRITE_CB_ITM_GHT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_init: Failed writing CB_ITM_GHT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    soc_CB_ITM_GHT_IA_WDATA_PART2r_field_set(unit, &regval, 
             KEY_95_64f, &entry->key_95_64);
    rc = REG_WRITE_CB_ITM_GHT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_init: Failed writing CB_ITM_GHT_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->n_or_vsi;
    soc_CB_ITM_GHT_IA_WDATA_PART3r_field_set(unit, &regval,
             N_OR_VSIf, &tmpval);
    tmpval = entry->valid;
    soc_CB_ITM_GHT_IA_WDATA_PART3r_field_set(unit, &regval,
             VALIDf, &tmpval);
    tmpval = entry->key_113_96;
    soc_CB_ITM_GHT_IA_WDATA_PART3r_field_set(unit, &regval,
             KEY_113_96f, &tmpval);
    tmpval = entry->li_type;
    soc_CB_ITM_GHT_IA_WDATA_PART3r_field_set(unit, &regval,
             LI_TYPEf, &tmpval);
    rc = REG_WRITE_CB_ITM_GHT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_init: Failed writing CB_ITM_GHT_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_init: Failed setting start of table %s status %x\n", 
                "ght", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_init: Failed Initialize table %s status %x\n", 
                "ght", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lin2vsi_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lin2vsi_init(int unit, int start, int end, int inc, lin2vsi_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->tc;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
             TCf, &tmpval);
    tmpval = entry->dp;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
             DPf, &tmpval);
    tmpval = entry->use_tc;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
             USE_TCf, &tmpval);
    tmpval = entry->use_dp;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
             USE_DPf, &tmpval);
    tmpval = entry->vsi;
    soc_CB_IPP_LIN2VSI_IA_WDATA_PART0r_field_set(unit, &regval,
             VSIf, &tmpval);
    rc = REG_WRITE_CB_IPP_LIN2VSI_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_init: Failed writing CB_IPP_LIN2VSI_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LIN2VSI_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_init: Failed setting start of table %s status %x\n", 
                "lin2vsi", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LIN2VSI_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_init: Failed Initialize table %s status %x\n", 
                "lin2vsi", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_profile_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_profile_init(int unit, int start, int end, int inc, cfp_profile_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->cbs_exp;
    soc_CB_CFP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CBS_EXPf, &tmpval);
    tmpval = entry->cbs_mantissa;
    soc_CB_CFP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CBS_MANTISSAf, &tmpval);
    tmpval = entry->cir_mantissa;
    soc_CB_CFP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CIR_MANTISSAf, &tmpval);
    tmpval = entry->cir_exp;
    soc_CB_CFP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CIR_EXPf, &tmpval);
    rc = REG_WRITE_CB_CFP_PROFILE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_init: Failed writing CB_CFP_PROFILE_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->eir_exp;
    soc_CB_CFP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EIR_EXPf, &tmpval);
    tmpval = entry->ebs_exp;
    soc_CB_CFP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EBS_EXPf, &tmpval);
    tmpval = entry->eir_mantissa;
    soc_CB_CFP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EIR_MANTISSAf, &tmpval);
    tmpval = entry->ebs_mantissa;
    soc_CB_CFP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EBS_MANTISSAf, &tmpval);
    rc = REG_WRITE_CB_CFP_PROFILE_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_init: Failed writing CB_CFP_PROFILE_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->drop_on_red;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             DROP_ON_REDf, &tmpval);
    tmpval = entry->pkt_mode;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             PKT_MODEf, &tmpval);
    tmpval = entry->bktc_strict;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BKTC_STRICTf, &tmpval);
    tmpval = entry->bkte_strict;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BKTE_STRICTf, &tmpval);
    tmpval = entry->cf;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             CFf, &tmpval);
    tmpval = entry->rfc2698;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             RFC2698f, &tmpval);
    tmpval = entry->blind;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BLINDf, &tmpval);
    tmpval = entry->avb_mode;
    soc_CB_CFP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             AVB_MODEf, &tmpval);
    rc = REG_WRITE_CB_CFP_PROFILE_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_init: Failed writing CB_CFP_PROFILE_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PROFILE_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_init: Failed setting start of table %s status %x\n", 
                "cfp_profile", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PROFILE_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_init: Failed Initialize table %s status %x\n", 
                "cfp_profile", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_bucket_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_bucket_init(int unit, int start, int end, int inc, cfp_bucket_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->bkte;
    soc_CB_CFP_BUCKET_IA_WDATA_PART0r_field_set(unit, &regval,
             BKTEf, &tmpval);
    rc = REG_WRITE_CB_CFP_BUCKET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_init: Failed writing CB_CFP_BUCKET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->bktc;
    soc_CB_CFP_BUCKET_IA_WDATA_PART1r_field_set(unit, &regval,
             BKTCf, &tmpval);
    rc = REG_WRITE_CB_CFP_BUCKET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_init: Failed writing CB_CFP_BUCKET_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_BUCKET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_init: Failed setting start of table %s status %x\n", 
                "cfp_bucket", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_BUCKET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_init: Failed Initialize table %s status %x\n", 
                "cfp_bucket", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_calendar_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_calendar_init(int unit, int start, int end, int inc, calendar_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->slot_port_sel_en;
    soc_CB_PQS_CALENDAR_IA_WDATA_PART0r_field_set(unit, &regval,
             SLOT_PORT_SEL_ENf, &tmpval);
    tmpval = entry->slot_port;
    soc_CB_PQS_CALENDAR_IA_WDATA_PART0r_field_set(unit, &regval,
             SLOT_PORTf, &tmpval);
    rc = REG_WRITE_CB_PQS_CALENDAR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_init: Failed writing CB_PQS_CALENDAR_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CALENDAR_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_init: Failed setting start of table %s status %x\n", 
                "calendar", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CALENDAR_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_init: Failed Initialize table %s status %x\n", 
                "calendar", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pg2lpg_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pg2lpg_init(int unit, int start, int end, int inc, pg2lpg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->lpg;
    soc_CB_PQM_PG2LPG_IA_WDATA_PART0r_field_set(unit, &regval,
             LPGf, &tmpval);
    rc = REG_WRITE_CB_PQM_PG2LPG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_init: Failed writing CB_PQM_PG2LPG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PG2LPG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_init: Failed setting start of table %s status %x\n", 
                "pg2lpg", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PG2LPG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_init: Failed Initialize table %s status %x\n", 
                "pg2lpg", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm_init(int unit, int start, int end, int inc, arlfm_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_ITM_ARLFM_IA_WDATA_PART0r_field_set(unit, &regval, 
             MAC_LOf, &entry->mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_init: Failed writing CB_ITM_ARLFM_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->fid;
    soc_CB_ITM_ARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
             FIDf, &tmpval);
    tmpval = entry->upd_ctrl;
    soc_CB_ITM_ARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
             UPD_CTRLf, &tmpval);
    tmpval = entry->mac_hi;
    soc_CB_ITM_ARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
             MAC_HIf, &tmpval);
    tmpval = entry->fwd_ctrl;
    soc_CB_ITM_ARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
             FWD_CTRLf, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_init: Failed writing CB_ITM_ARLFM_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->valid;
    soc_CB_ITM_ARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
             VALIDf, &tmpval);
    tmpval = entry->dst;
    soc_CB_ITM_ARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
             DSTf, &tmpval);
    tmpval = entry->dst_type;
    soc_CB_ITM_ARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
             DST_TYPEf, &tmpval);
    tmpval = entry->hit;
    soc_CB_ITM_ARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
             HITf, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_init: Failed writing CB_ITM_ARLFM_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_init: Failed setting start of table %s status %x\n", 
                "arlfm", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_init: Failed Initialize table %s status %x\n", 
                "arlfm", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm0_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm0_init(int unit, int start, int end, int inc, arlfm0_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->valid;
    soc_CB_ITM_ARLFM0_IA_WDATA_PART0r_field_set(unit, &regval,
             VALIDf, &tmpval);
    tmpval = entry->dst;
    soc_CB_ITM_ARLFM0_IA_WDATA_PART0r_field_set(unit, &regval,
             DSTf, &tmpval);
    tmpval = entry->dst_type;
    soc_CB_ITM_ARLFM0_IA_WDATA_PART0r_field_set(unit, &regval,
             DST_TYPEf, &tmpval);
    tmpval = entry->hit;
    soc_CB_ITM_ARLFM0_IA_WDATA_PART0r_field_set(unit, &regval,
             HITf, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM0_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_init: Failed writing CB_ITM_ARLFM0_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM0_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_init: Failed setting start of table %s status %x\n", 
                "arlfm0", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM0_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_init: Failed Initialize table %s status %x\n", 
                "arlfm0", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_bucket_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_bucket_init(int unit, int start, int end, int inc, ipp_bucket_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->bkte;
    soc_CB_IPP_BUCKET_IA_WDATA_PART0r_field_set(unit, &regval,
             BKTEf, &tmpval);
    rc = REG_WRITE_CB_IPP_BUCKET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_init: Failed writing CB_IPP_BUCKET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->bktc;
    soc_CB_IPP_BUCKET_IA_WDATA_PART1r_field_set(unit, &regval,
             BKTCf, &tmpval);
    rc = REG_WRITE_CB_IPP_BUCKET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_init: Failed writing CB_IPP_BUCKET_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_BUCKET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_init: Failed setting start of table %s status %x\n", 
                "ipp_bucket", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_BUCKET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_init: Failed Initialize table %s status %x\n", 
                "ipp_bucket", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_config_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_config_init(int unit, int start, int end, int inc, fcd_config_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->thresh1;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
             THRESH1f, &tmpval);
    tmpval = entry->thresh0;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
             THRESH0f, &tmpval);
    rc = REG_WRITE_CB_BMU_FCD_CONFIG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_init: Failed writing CB_BMU_FCD_CONFIG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->thresh3;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART1r_field_set(unit, &regval,
             THRESH3f, &tmpval);
    tmpval = entry->thresh2;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART1r_field_set(unit, &regval,
             THRESH2f, &tmpval);
    rc = REG_WRITE_CB_BMU_FCD_CONFIG_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_init: Failed writing CB_BMU_FCD_CONFIG_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->counter_enable;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
             COUNTER_ENABLEf, &tmpval);
    tmpval = entry->tc_bmp;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
             TC_BMPf, &tmpval);
    tmpval = entry->fc_enable;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
             FC_ENABLEf, &tmpval);
    tmpval = entry->hysteresis;
    soc_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r_field_set(unit, &regval,
             HYSTERESISf, &tmpval);
    rc = REG_WRITE_CB_BMU_FCD_CONFIG_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_init: Failed writing CB_BMU_FCD_CONFIG_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CONFIG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_init: Failed setting start of table %s status %x\n", 
                "fcd_config", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CONFIG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_init: Failed Initialize table %s status %x\n", 
                "fcd_config", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stat_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stat_init(int unit, int start, int end, int inc, stat_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_CFP_STAT_IA_WDATA_PART0r_field_set(unit, &regval, 
             STAT_COUNTER0_LOf, &entry->stat_counter0_lo);
    rc = REG_WRITE_CB_CFP_STAT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_init: Failed writing CB_CFP_STAT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    soc_CB_CFP_STAT_IA_WDATA_PART1r_field_set(unit, &regval, 
             STAT_COUNTER0_HIf, &entry->stat_counter0_hi);
    rc = REG_WRITE_CB_CFP_STAT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_init: Failed writing CB_CFP_STAT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    soc_CB_CFP_STAT_IA_WDATA_PART2r_field_set(unit, &regval, 
             STAT_COUNTER1_LOf, &entry->stat_counter1_lo);
    rc = REG_WRITE_CB_CFP_STAT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_init: Failed writing CB_CFP_STAT_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    soc_CB_CFP_STAT_IA_WDATA_PART3r_field_set(unit, &regval, 
             STAT_COUNTER1_HIf, &entry->stat_counter1_hi);
    rc = REG_WRITE_CB_CFP_STAT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_init: Failed writing CB_CFP_STAT_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STAT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_init: Failed setting start of table %s status %x\n", 
                "stat", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STAT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_init: Failed Initialize table %s status %x\n", 
                "stat", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_eeecfg_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_eeecfg_init(int unit, int start, int end, int inc, eeecfg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->eee_thresh;
    soc_CB_PQM_EEECFG_IA_WDATA_PART0r_field_set(unit, &regval,
             EEE_THRESHf, &tmpval);
    tmpval = entry->eee_timer;
    soc_CB_PQM_EEECFG_IA_WDATA_PART0r_field_set(unit, &regval,
             EEE_TIMERf, &tmpval);
    tmpval = entry->eee_en;
    soc_CB_PQM_EEECFG_IA_WDATA_PART0r_field_set(unit, &regval,
             EEE_ENf, &tmpval);
    rc = REG_WRITE_CB_PQM_EEECFG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_init: Failed writing CB_PQM_EEECFG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EEECFG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_init: Failed setting start of table %s status %x\n", 
                "eeecfg", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EEECFG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_init: Failed Initialize table %s status %x\n", 
                "eeecfg", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_hdt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_hdt_init(int unit, int start, int end, int inc, hdt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->type0;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
             TYPE0f, &tmpval);
    tmpval = entry->which0;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
             WHICH0f, &tmpval);
    tmpval = entry->uptill0;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
             UPTILL0f, &tmpval);
    tmpval = entry->type1;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
             TYPE1f, &tmpval);
    tmpval = entry->which1;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
             WHICH1f, &tmpval);
    tmpval = entry->uptill1;
    soc_CB_IPP_HDT_IA_WDATA_PART0r_field_set(unit, &regval,
             UPTILL1f, &tmpval);
    rc = REG_WRITE_CB_IPP_HDT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_init: Failed writing CB_IPP_HDT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->type2;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
             TYPE2f, &tmpval);
    tmpval = entry->uptill2;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
             UPTILL2f, &tmpval);
    tmpval = entry->uptill3;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
             UPTILL3f, &tmpval);
    tmpval = entry->which2;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
             WHICH2f, &tmpval);
    tmpval = entry->which3;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
             WHICH3f, &tmpval);
    tmpval = entry->type3;
    soc_CB_IPP_HDT_IA_WDATA_PART1r_field_set(unit, &regval,
             TYPE3f, &tmpval);
    rc = REG_WRITE_CB_IPP_HDT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_init: Failed writing CB_IPP_HDT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_HDT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_init: Failed setting start of table %s status %x\n", 
                "hdt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_HDT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_init: Failed Initialize table %s status %x\n", 
                "hdt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_estget_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_estget_init(int unit, int start, int end, int inc, estget_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->tx_ena;
    soc_CB_PQM_ESTGET_IA_WDATA_PART0r_field_set(unit, &regval,
             TX_ENAf, &tmpval);
    rc = REG_WRITE_CB_PQM_ESTGET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_init: Failed writing CB_PQM_ESTGET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ESTGET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_init: Failed setting start of table %s status %x\n", 
                "estget", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ESTGET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_init: Failed Initialize table %s status %x\n", 
                "estget", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stt_init(int unit, int start, int end, int inc, stt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->etype;
    soc_CB_IPP_STT_IA_WDATA_PART0r_field_set(unit, &regval,
             ETYPEf, &tmpval);
    tmpval = entry->ntype;
    soc_CB_IPP_STT_IA_WDATA_PART0r_field_set(unit, &regval,
             NTYPEf, &tmpval);
    rc = REG_WRITE_CB_IPP_STT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_init: Failed writing CB_IPP_STT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->ekey_type;
    soc_CB_IPP_STT_IA_WDATA_PART1r_field_set(unit, &regval,
             EKEY_TYPEf, &tmpval);
    tmpval = entry->length;
    soc_CB_IPP_STT_IA_WDATA_PART1r_field_set(unit, &regval,
             LENGTHf, &tmpval);
    tmpval = entry->tci;
    soc_CB_IPP_STT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCIf, &tmpval);
    rc = REG_WRITE_CB_IPP_STT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_init: Failed writing CB_IPP_STT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_init: Failed setting start of table %s status %x\n", 
                "stt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_init: Failed Initialize table %s status %x\n", 
                "stt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pet_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pet_init(int unit, int start, int end, int inc, pet_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->encap4;
    soc_CB_ETM_PET_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP4f, &tmpval);
    tmpval = entry->encap5;
    soc_CB_ETM_PET_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP5f, &tmpval);
    tmpval = entry->encap7;
    soc_CB_ETM_PET_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP7f, &tmpval);
    tmpval = entry->encap6;
    soc_CB_ETM_PET_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP6f, &tmpval);
    rc = REG_WRITE_CB_ETM_PET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_init: Failed writing CB_ETM_PET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->encap2;
    soc_CB_ETM_PET_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP2f, &tmpval);
    tmpval = entry->encap3;
    soc_CB_ETM_PET_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP3f, &tmpval);
    tmpval = entry->encap0;
    soc_CB_ETM_PET_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP0f, &tmpval);
    tmpval = entry->encap1;
    soc_CB_ETM_PET_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP1f, &tmpval);
    rc = REG_WRITE_CB_ETM_PET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_init: Failed writing CB_ETM_PET_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->full;
    soc_CB_ETM_PET_IA_WDATA_PART2r_field_set(unit, &regval,
             FULLf, &tmpval);
    rc = REG_WRITE_CB_ETM_PET_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_init: Failed writing CB_ETM_PET_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_init: Failed setting start of table %s status %x\n", 
                "pet", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_init: Failed Initialize table %s status %x\n", 
                "pet", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_istget_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_istget_init(int unit, int start, int end, int inc, istget_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->rx_ena;
    soc_CB_IPP_ISTGET_IA_WDATA_PART0r_field_set(unit, &regval,
             RX_ENAf, &tmpval);
    rc = REG_WRITE_CB_IPP_ISTGET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_init: Failed writing CB_IPP_ISTGET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ISTGET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_init: Failed setting start of table %s status %x\n", 
                "istget", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ISTGET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_init: Failed Initialize table %s status %x\n", 
                "istget", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qdschcfg_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qdschcfg_init(int unit, int start, int end, int inc, qdschcfg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->sp_rr_sch;
    soc_CB_PQM_QDSCHCFG_IA_WDATA_PART0r_field_set(unit, &regval,
             SP_RR_SCHf, &tmpval);
    rc = REG_WRITE_CB_PQM_QDSCHCFG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_init: Failed writing CB_PQM_QDSCHCFG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QDSCHCFG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_init: Failed setting start of table %s status %x\n", 
                "qdschcfg", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QDSCHCFG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_init: Failed Initialize table %s status %x\n", 
                "qdschcfg", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_rscale_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_rscale_init(int unit, int start, int end, int inc, pqm_rscale_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->scale;
    soc_CB_PQM_RSCALE_IA_WDATA_PART0r_field_set(unit, &regval,
             SCALEf, &tmpval);
    rc = REG_WRITE_CB_PQM_RSCALE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_init: Failed writing CB_PQM_RSCALE_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_RSCALE_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_init: Failed setting start of table %s status %x\n", 
                "pqm_rscale", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_RSCALE_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_init: Failed Initialize table %s status %x\n", 
                "pqm_rscale", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtr2tcb_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtr2tcb_init(int unit, int start, int end, int inc, mtr2tcb_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->tc_bmp;
    soc_CB_BMU_MTR2TCB_IA_WDATA_PART0r_field_set(unit, &regval,
             TC_BMPf, &tmpval);
    tmpval = entry->shp_en;
    soc_CB_BMU_MTR2TCB_IA_WDATA_PART0r_field_set(unit, &regval,
             SHP_ENf, &tmpval);
    rc = REG_WRITE_CB_BMU_MTR2TCB_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_init: Failed writing CB_BMU_MTR2TCB_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTR2TCB_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_init: Failed setting start of table %s status %x\n", 
                "mtr2tcb", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTR2TCB_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_init: Failed Initialize table %s status %x\n", 
                "mtr2tcb", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dli2ldpg_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dli2ldpg_init(int unit, int start, int end, int inc, dli2ldpg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->ldpgid;
    soc_CB_PQM_DLI2LDPG_IA_WDATA_PART0r_field_set(unit, &regval,
             LDPGIDf, &tmpval);
    rc = REG_WRITE_CB_PQM_DLI2LDPG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_init: Failed writing CB_PQM_DLI2LDPG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLI2LDPG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_init: Failed setting start of table %s status %x\n", 
                "dli2ldpg", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLI2LDPG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_init: Failed Initialize table %s status %x\n", 
                "dli2ldpg", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tc2qd_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tc2qd_init(int unit, int start, int end, int inc, tc2qd_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->qd;
    soc_CB_PQM_TC2QD_IA_WDATA_PART0r_field_set(unit, &regval,
             QDf, &tmpval);
    rc = REG_WRITE_CB_PQM_TC2QD_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_init: Failed writing CB_PQM_TC2QD_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TC2QD_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_init: Failed setting start of table %s status %x\n", 
                "tc2qd", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TC2QD_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_init: Failed Initialize table %s status %x\n", 
                "tc2qd", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spldt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spldt_init(int unit, int start, int end, int inc, spldt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->link_delay;
    soc_CB_EPP_SPLDT_IA_WDATA_PART0r_field_set(unit, &regval,
             LINK_DELAYf, &tmpval);
    rc = REG_WRITE_CB_EPP_SPLDT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_init: Failed writing CB_EPP_SPLDT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPLDT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_init: Failed setting start of table %s status %x\n", 
                "spldt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPLDT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_init: Failed Initialize table %s status %x\n", 
                "spldt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_rscale_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_rscale_init(int unit, int start, int end, int inc, cfp_rscale_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->scale;
    soc_CB_CFP_RSCALE_IA_WDATA_PART0r_field_set(unit, &regval,
             SCALEf, &tmpval);
    rc = REG_WRITE_CB_CFP_RSCALE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_init: Failed writing CB_CFP_RSCALE_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_RSCALE_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_init: Failed setting start of table %s status %x\n", 
                "cfp_rscale", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_RSCALE_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_init: Failed Initialize table %s status %x\n", 
                "cfp_rscale", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghtdt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghtdt_init(int unit, int start, int end, int inc, ghtdt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->seed1;
    soc_CB_ITM_GHTDT_IA_WDATA_PART0r_field_set(unit, &regval,
             SEED1f, &tmpval);
    tmpval = entry->base;
    soc_CB_ITM_GHTDT_IA_WDATA_PART0r_field_set(unit, &regval,
             BASEf, &tmpval);
    tmpval = entry->num_entries;
    soc_CB_ITM_GHTDT_IA_WDATA_PART0r_field_set(unit, &regval,
             NUM_ENTRIESf, &tmpval);
    tmpval = entry->seed0;
    soc_CB_ITM_GHTDT_IA_WDATA_PART0r_field_set(unit, &regval,
             SEED0f, &tmpval);
    rc = REG_WRITE_CB_ITM_GHTDT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_init: Failed writing CB_ITM_GHTDT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHTDT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_init: Failed setting start of table %s status %x\n", 
                "ghtdt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHTDT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_init: Failed Initialize table %s status %x\n", 
                "ghtdt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_bucket_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_bucket_init(int unit, int start, int end, int inc, bmu_bucket_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->bkte;
    soc_CB_BMU_BUCKET_IA_WDATA_PART0r_field_set(unit, &regval,
             BKTEf, &tmpval);
    rc = REG_WRITE_CB_BMU_BUCKET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_init: Failed writing CB_BMU_BUCKET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->bktc;
    soc_CB_BMU_BUCKET_IA_WDATA_PART1r_field_set(unit, &regval,
             BKTCf, &tmpval);
    rc = REG_WRITE_CB_BMU_BUCKET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_init: Failed writing CB_BMU_BUCKET_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_BUCKET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_init: Failed setting start of table %s status %x\n", 
                "bmu_bucket", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_BUCKET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_init: Failed Initialize table %s status %x\n", 
                "bmu_bucket", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lilt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lilt_init(int unit, int start, int end, int inc, lilt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_PQM_LILT_IA_WDATA_PART0r_field_set(unit, &regval, 
             LILT_ENTRYf, &entry->lilt_entry);
    rc = REG_WRITE_CB_PQM_LILT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_init: Failed writing CB_PQM_LILT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LILT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_init: Failed setting start of table %s status %x\n", 
                "lilt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LILT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_init: Failed Initialize table %s status %x\n", 
                "lilt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_svt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_svt_init(int unit, int start, int end, int inc, svt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->svt_mask;
    soc_CB_PQM_SVT_IA_WDATA_PART0r_field_set(unit, &regval,
             SVT_MASKf, &tmpval);
    rc = REG_WRITE_CB_PQM_SVT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_init: Failed writing CB_PQM_SVT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SVT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_init: Failed setting start of table %s status %x\n", 
                "svt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SVT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_init: Failed Initialize table %s status %x\n", 
                "svt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slicmap_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slicmap_init(int unit, int start, int end, int inc, slicmap_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->tci5;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART0r_field_set(unit, &regval,
             TCI5f, &tmpval);
    tmpval = entry->tci4;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART0r_field_set(unit, &regval,
             TCI4f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->tci2;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART1r_field_set(unit, &regval,
             TCI2f, &tmpval);
    tmpval = entry->tci3;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART1r_field_set(unit, &regval,
             TCI3f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->tci1;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART2r_field_set(unit, &regval,
             TCI1f, &tmpval);
    tmpval = entry->tci0;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART2r_field_set(unit, &regval,
             TCI0f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->valid;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
             VALIDf, &tmpval);
    tmpval = entry->tpid0;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
             TPID0f, &tmpval);
    tmpval = entry->tpid1;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
             TPID1f, &tmpval);
    tmpval = entry->unusedb;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
             UNUSEDBf, &tmpval);
    tmpval = entry->tpid2;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
             TPID2f, &tmpval);
    tmpval = entry->tpid4;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
             TPID4f, &tmpval);
    tmpval = entry->etype;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
             ETYPEf, &tmpval);
    tmpval = entry->tpid3;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART3r_field_set(unit, &regval,
             TPID3f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_WDATA_PART4r_field_set(unit, &regval, 
             SMAC_LO32f, &entry->smac_lo32);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART4 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->smac_hi16;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART5r_field_set(unit, &regval,
             SMAC_HI16f, &tmpval);
    tmpval = entry->dmac_lo16;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART5r_field_set(unit, &regval,
             DMAC_LO16f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART5 register rc %d \n", rc));
        return rc;
    }
    soc_CB_IPP_SLICMAP_IA_WDATA_PART6r_field_set(unit, &regval, 
             DMAC_HI32f, &entry->dmac_hi32);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART6 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->pepper;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART7r_field_set(unit, &regval,
             PEPPERf, &tmpval);
    tmpval = entry->pg_map;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART7r_field_set(unit, &regval,
             PG_MAPf, &tmpval);
    tmpval = entry->unuseda;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART7r_field_set(unit, &regval,
             UNUSEDAf, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART7r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART7 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->valid_key0;
    soc_CB_IPP_SLICMAP_IA_WDATA_PART8r_field_set(unit, &regval,
             VALID_KEY0f, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICMAP_IA_WDATA_PART8r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed writing CB_IPP_SLICMAP_IA_WDATA_PART8 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICMAP_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed setting start of table %s status %x\n", 
                "slicmap", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICMAP_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_init: Failed Initialize table %s status %x\n", 
                "slicmap", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_m2tk_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_m2tk_init(int unit, int start, int end, int inc, m2tk_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->table_id;
    soc_CB_IPP_M2TK_IA_WDATA_PART0r_field_set(unit, &regval,
             TABLE_IDf, &tmpval);
    tmpval = entry->key_id;
    soc_CB_IPP_M2TK_IA_WDATA_PART0r_field_set(unit, &regval,
             KEY_IDf, &tmpval);
    rc = REG_WRITE_CB_IPP_M2TK_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_init: Failed writing CB_IPP_M2TK_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_M2TK_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_init: Failed setting start of table %s status %x\n", 
                "m2tk", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_M2TK_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_init: Failed Initialize table %s status %x\n", 
                "m2tk", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_art_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_art_init(int unit, int start, int end, int inc, art_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->ndx;
    soc_CB_CFP_ART_IA_WDATA_PART0r_field_set(unit, &regval,
             NDXf, &tmpval);
    rc = REG_WRITE_CB_CFP_ART_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_init: Failed writing CB_CFP_ART_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ART_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_init: Failed setting start of table %s status %x\n", 
                "art", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ART_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_init: Failed Initialize table %s status %x\n", 
                "art", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ig_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ig_init(int unit, int start, int end, int inc, lpg2ig_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->ig;
    soc_CB_PQM_LPG2IG_IA_WDATA_PART0r_field_set(unit, &regval,
             IGf, &tmpval);
    rc = REG_WRITE_CB_PQM_LPG2IG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_init: Failed writing CB_PQM_LPG2IG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2IG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_init: Failed setting start of table %s status %x\n", 
                "lpg2ig", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2IG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_init: Failed Initialize table %s status %x\n", 
                "lpg2ig", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_profile_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_profile_init(int unit, int start, int end, int inc, ipp_profile_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->cbs_exp;
    soc_CB_IPP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CBS_EXPf, &tmpval);
    tmpval = entry->cbs_mantissa;
    soc_CB_IPP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CBS_MANTISSAf, &tmpval);
    tmpval = entry->cir_mantissa;
    soc_CB_IPP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CIR_MANTISSAf, &tmpval);
    tmpval = entry->cir_exp;
    soc_CB_IPP_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CIR_EXPf, &tmpval);
    rc = REG_WRITE_CB_IPP_PROFILE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_init: Failed writing CB_IPP_PROFILE_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->eir_exp;
    soc_CB_IPP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EIR_EXPf, &tmpval);
    tmpval = entry->ebs_exp;
    soc_CB_IPP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EBS_EXPf, &tmpval);
    tmpval = entry->eir_mantissa;
    soc_CB_IPP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EIR_MANTISSAf, &tmpval);
    tmpval = entry->ebs_mantissa;
    soc_CB_IPP_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EBS_MANTISSAf, &tmpval);
    rc = REG_WRITE_CB_IPP_PROFILE_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_init: Failed writing CB_IPP_PROFILE_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->drop_on_red;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             DROP_ON_REDf, &tmpval);
    tmpval = entry->pkt_mode;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             PKT_MODEf, &tmpval);
    tmpval = entry->bktc_strict;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BKTC_STRICTf, &tmpval);
    tmpval = entry->bkte_strict;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BKTE_STRICTf, &tmpval);
    tmpval = entry->cf;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             CFf, &tmpval);
    tmpval = entry->rfc2698;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             RFC2698f, &tmpval);
    tmpval = entry->blind;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BLINDf, &tmpval);
    tmpval = entry->avb_mode;
    soc_CB_IPP_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             AVB_MODEf, &tmpval);
    rc = REG_WRITE_CB_IPP_PROFILE_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_init: Failed writing CB_IPP_PROFILE_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PROFILE_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_init: Failed setting start of table %s status %x\n", 
                "ipp_profile", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PROFILE_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_init: Failed Initialize table %s status %x\n", 
                "ipp_profile", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfcqdaddr_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfcqdaddr_init(int unit, int start, int end, int inc, qfcqdaddr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->qfc_addr;
    soc_CB_PQM_QFCQDADDR_IA_WDATA_PART0r_field_set(unit, &regval,
             QFC_ADDRf, &tmpval);
    rc = REG_WRITE_CB_PQM_QFCQDADDR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_init: Failed writing CB_PQM_QFCQDADDR_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCQDADDR_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_init: Failed setting start of table %s status %x\n", 
                "qfcqdaddr", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCQDADDR_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_init: Failed Initialize table %s status %x\n", 
                "qfcqdaddr", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtgt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtgt_init(int unit, int start, int end, int inc, mtgt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->tc;
    soc_CB_PQM_MTGT_IA_WDATA_PART0r_field_set(unit, &regval,
             TCf, &tmpval);
    tmpval = entry->dp;
    soc_CB_PQM_MTGT_IA_WDATA_PART0r_field_set(unit, &regval,
             DPf, &tmpval);
    tmpval = entry->dli_n;
    soc_CB_PQM_MTGT_IA_WDATA_PART0r_field_set(unit, &regval,
             DLI_Nf, &tmpval);
    tmpval = entry->truncate;
    soc_CB_PQM_MTGT_IA_WDATA_PART0r_field_set(unit, &regval,
             TRUNCATEf, &tmpval);
    rc = REG_WRITE_CB_PQM_MTGT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_init: Failed writing CB_PQM_MTGT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->drop_prob;
    soc_CB_PQM_MTGT_IA_WDATA_PART1r_field_set(unit, &regval,
             DROP_PROBf, &tmpval);
    rc = REG_WRITE_CB_PQM_MTGT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_init: Failed writing CB_PQM_MTGT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTGT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_init: Failed setting start of table %s status %x\n", 
                "mtgt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTGT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_init: Failed Initialize table %s status %x\n", 
                "mtgt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pptr_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pptr_init(int unit, int start, int end, int inc, ipp_pptr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->pointer;
    soc_CB_IPP_PPTR_IA_WDATA_PART0r_field_set(unit, &regval,
             POINTERf, &tmpval);
    rc = REG_WRITE_CB_IPP_PPTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_init: Failed writing CB_IPP_PPTR_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PPTR_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_init: Failed setting start of table %s status %x\n", 
                "ipp_pptr", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PPTR_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_init: Failed Initialize table %s status %x\n", 
                "ipp_pptr", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_set_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_set_init(int unit, int start, int end, int inc, set_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_EPP_SET_IA_WDATA_PART0r_field_set(unit, &regval, 
             SMAC_LSBf, &entry->smac_lsb);
    rc = REG_WRITE_CB_EPP_SET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_init: Failed writing CB_EPP_SET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->smac_msb;
    soc_CB_EPP_SET_IA_WDATA_PART1r_field_set(unit, &regval,
             SMAC_MSBf, &tmpval);
    rc = REG_WRITE_CB_EPP_SET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_init: Failed writing CB_EPP_SET_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_init: Failed setting start of table %s status %x\n", 
                "set", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_init: Failed Initialize table %s status %x\n", 
                "set", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_srt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_srt_init(int unit, int start, int end, int inc, srt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->slicid;
    soc_CB_IPP_SRT_IA_WDATA_PART0r_field_set(unit, &regval,
             SLICIDf, &tmpval);
    tmpval = entry->trap_group;
    soc_CB_IPP_SRT_IA_WDATA_PART0r_field_set(unit, &regval,
             TRAP_GROUPf, &tmpval);
    rc = REG_WRITE_CB_IPP_SRT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_init: Failed writing CB_IPP_SRT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SRT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_init: Failed setting start of table %s status %x\n", 
                "srt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SRT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_init: Failed Initialize table %s status %x\n", 
                "srt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pmon_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pmon_init(int unit, int start, int end, int inc, ipp_pmon_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_IPP_PMON_IA_WDATA_PART0r_field_set(unit, &regval, 
             COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_WRITE_CB_IPP_PMON_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_init: Failed writing CB_IPP_PMON_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    soc_CB_IPP_PMON_IA_WDATA_PART1r_field_set(unit, &regval, 
             COUNT_MSBSf, &entry->count_msbs);
    rc = REG_WRITE_CB_IPP_PMON_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_init: Failed writing CB_IPP_PMON_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PMON_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_init: Failed setting start of table %s status %x\n", 
                "ipp_pmon", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PMON_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_init: Failed Initialize table %s status %x\n", 
                "ipp_pmon", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vtct_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vtct_init(int unit, int start, int end, int inc, vtct_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->vid;
    soc_CB_ETM_VTCT_IA_WDATA_PART0r_field_set(unit, &regval,
             VIDf, &tmpval);
    rc = REG_WRITE_CB_ETM_VTCT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_init: Failed writing CB_ETM_VTCT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->tca1;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA1f, &tmpval);
    tmpval = entry->tca2;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA2f, &tmpval);
    tmpval = entry->tca13;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA13f, &tmpval);
    tmpval = entry->tca4;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA4f, &tmpval);
    tmpval = entry->tca5;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA5f, &tmpval);
    tmpval = entry->tca8;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA8f, &tmpval);
    tmpval = entry->tca9;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA9f, &tmpval);
    tmpval = entry->tca3;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA3f, &tmpval);
    tmpval = entry->tca14;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA14f, &tmpval);
    tmpval = entry->tca12;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA12f, &tmpval);
    tmpval = entry->tca0;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA0f, &tmpval);
    tmpval = entry->tca10;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA10f, &tmpval);
    tmpval = entry->tca7;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA7f, &tmpval);
    tmpval = entry->tca6;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA6f, &tmpval);
    tmpval = entry->tca11;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA11f, &tmpval);
    tmpval = entry->tca15;
    soc_CB_ETM_VTCT_IA_WDATA_PART1r_field_set(unit, &regval,
             TCA15f, &tmpval);
    rc = REG_WRITE_CB_ETM_VTCT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_init: Failed writing CB_ETM_VTCT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VTCT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_init: Failed setting start of table %s status %x\n", 
                "vtct", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VTCT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_init: Failed Initialize table %s status %x\n", 
                "vtct", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfpcam_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfpcam_init(int unit, int start, int end, int inc, cfpcam_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_CFP_CFPCAM_IA_WDATA_PART0r_field_set(unit, &regval, 
             TCAM_DATA0f, &entry->tcam_data0);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART1r_field_set(unit, &regval, 
             TCAM_DATA1f, &entry->tcam_data1);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART2r_field_set(unit, &regval, 
             TCAM_DATA2f, &entry->tcam_data2);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART3r_field_set(unit, &regval, 
             TCAM_DATA3f, &entry->tcam_data3);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART4r_field_set(unit, &regval, 
             TCAM_DATA4f, &entry->tcam_data4);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART4 register rc %d \n", rc));
        return rc;
    }
    soc_CB_CFP_CFPCAM_IA_WDATA_PART5r_field_set(unit, &regval, 
             TCAM_DATA5f, &entry->tcam_data5);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART5r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART5 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->tcam_valid;
    soc_CB_CFP_CFPCAM_IA_WDATA_PART6r_field_set(unit, &regval,
             TCAM_VALIDf, &tmpval);
    rc = REG_WRITE_CB_CFP_CFPCAM_IA_WDATA_PART6r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Failed writing CB_CFP_CFPCAM_IA_WDATA_PART6 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFPCAM_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Failed setting start of table %s status %x\n", 
                "cfpcam", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFPCAM_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_init: Failed Initialize table %s status %x\n", 
                "cfpcam", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_cntr_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_cntr_init(int unit, int start, int end, int inc, fcd_cntr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->page_cnt;
    soc_CB_BMU_FCD_CNTR_IA_WDATA_PART0r_field_set(unit, &regval,
             PAGE_CNTf, &tmpval);
    rc = REG_WRITE_CB_BMU_FCD_CNTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_init: Failed writing CB_BMU_FCD_CNTR_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CNTR_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_init: Failed setting start of table %s status %x\n", 
                "fcd_cntr", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CNTR_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_init: Failed Initialize table %s status %x\n", 
                "fcd_cntr", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fpslict_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fpslict_init(int unit, int start, int end, int inc, fpslict_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->dst_key;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             DST_KEYf, &tmpval);
    tmpval = entry->ipv6_keyset;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             IPV6_KEYSETf, &tmpval);
    tmpval = entry->ipv4_keyset;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             IPV4_KEYSETf, &tmpval);
    tmpval = entry->other_keyset;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             OTHER_KEYSETf, &tmpval);
    tmpval = entry->src_key;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             SRC_KEYf, &tmpval);
    rc = REG_WRITE_CB_IPP_FPSLICT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_init: Failed writing CB_IPP_FPSLICT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->rsvd;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART1r_field_set(unit, &regval,
             RSVDf, &tmpval);
    rc = REG_WRITE_CB_IPP_FPSLICT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_init: Failed writing CB_IPP_FPSLICT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->pv2li_map_en;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART2r_field_set(unit, &regval,
             PV2LI_MAP_ENf, &tmpval);
    tmpval = entry->default_sli;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART2r_field_set(unit, &regval,
             DEFAULT_SLIf, &tmpval);
    rc = REG_WRITE_CB_IPP_FPSLICT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_init: Failed writing CB_IPP_FPSLICT_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->li_map0;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
             LI_MAP0f, &tmpval);
    tmpval = entry->li_map0_en;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
             LI_MAP0_ENf, &tmpval);
    tmpval = entry->li_map1_en;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
             LI_MAP1_ENf, &tmpval);
    tmpval = entry->li_map0_decap;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
             LI_MAP0_DECAPf, &tmpval);
    tmpval = entry->li_map1_decap;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
             LI_MAP1_DECAPf, &tmpval);
    tmpval = entry->slic_decap;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
             SLIC_DECAPf, &tmpval);
    tmpval = entry->pv_decap;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
             PV_DECAPf, &tmpval);
    tmpval = entry->li_map1;
    soc_CB_IPP_FPSLICT_IA_WDATA_PART3r_field_set(unit, &regval,
             LI_MAP1f, &tmpval);
    rc = REG_WRITE_CB_IPP_FPSLICT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_init: Failed writing CB_IPP_FPSLICT_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FPSLICT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_init: Failed setting start of table %s status %x\n", 
                "fpslict", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FPSLICT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_init: Failed Initialize table %s status %x\n", 
                "fpslict", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_kst_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_kst_init(int unit, int start, int end, int inc, kst_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->lbh_key;
    soc_CB_IPP_KST_IA_WDATA_PART0r_field_set(unit, &regval,
             LBH_KEYf, &tmpval);
    tmpval = entry->lbh_en;
    soc_CB_IPP_KST_IA_WDATA_PART0r_field_set(unit, &regval,
             LBH_ENf, &tmpval);
    tmpval = entry->cfp_key_en;
    soc_CB_IPP_KST_IA_WDATA_PART0r_field_set(unit, &regval,
             CFP_KEY_ENf, &tmpval);
    rc = REG_WRITE_CB_IPP_KST_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_init: Failed writing CB_IPP_KST_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->dbid3;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
             DBID3f, &tmpval);
    tmpval = entry->dbid0;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
             DBID0f, &tmpval);
    tmpval = entry->cfp_key3;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
             CFP_KEY3f, &tmpval);
    tmpval = entry->cfp_key2;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
             CFP_KEY2f, &tmpval);
    tmpval = entry->cfp_key1;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
             CFP_KEY1f, &tmpval);
    tmpval = entry->dbid2;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
             DBID2f, &tmpval);
    tmpval = entry->cfp_key0;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
             CFP_KEY0f, &tmpval);
    tmpval = entry->dbid1;
    soc_CB_IPP_KST_IA_WDATA_PART1r_field_set(unit, &regval,
             DBID1f, &tmpval);
    rc = REG_WRITE_CB_IPP_KST_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_init: Failed writing CB_IPP_KST_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_KST_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_init: Failed setting start of table %s status %x\n", 
                "kst", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_KST_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_init: Failed Initialize table %s status %x\n", 
                "kst", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_bucket_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_bucket_init(int unit, int start, int end, int inc, pqm_bucket_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->bkte;
    soc_CB_PQM_BUCKET_IA_WDATA_PART0r_field_set(unit, &regval,
             BKTEf, &tmpval);
    rc = REG_WRITE_CB_PQM_BUCKET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_init: Failed writing CB_PQM_BUCKET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->bktc;
    soc_CB_PQM_BUCKET_IA_WDATA_PART1r_field_set(unit, &regval,
             BKTCf, &tmpval);
    rc = REG_WRITE_CB_PQM_BUCKET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_init: Failed writing CB_PQM_BUCKET_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_BUCKET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_init: Failed setting start of table %s status %x\n", 
                "pqm_bucket", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_BUCKET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_init: Failed Initialize table %s status %x\n", 
                "pqm_bucket", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghst_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghst_init(int unit, int start, int end, int inc, ghst_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_ITM_GHST_IA_WDATA_PART0r_field_set(unit, &regval, 
             SEED_31_0f, &entry->seed_31_0);
    rc = REG_WRITE_CB_ITM_GHST_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_init: Failed writing CB_ITM_GHST_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    soc_CB_ITM_GHST_IA_WDATA_PART1r_field_set(unit, &regval, 
             SEED_63_32f, &entry->seed_63_32);
    rc = REG_WRITE_CB_ITM_GHST_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_init: Failed writing CB_ITM_GHST_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    soc_CB_ITM_GHST_IA_WDATA_PART2r_field_set(unit, &regval, 
             SEED_95_64f, &entry->seed_95_64);
    rc = REG_WRITE_CB_ITM_GHST_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_init: Failed writing CB_ITM_GHST_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->seed_113_96;
    soc_CB_ITM_GHST_IA_WDATA_PART3r_field_set(unit, &regval,
             SEED_113_96f, &tmpval);
    rc = REG_WRITE_CB_ITM_GHST_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_init: Failed writing CB_ITM_GHST_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHST_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_init: Failed setting start of table %s status %x\n", 
                "ghst", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHST_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_init: Failed Initialize table %s status %x\n", 
                "ghst", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2pg_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2pg_init(int unit, int start, int end, int inc, lpg2pg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->pg;
    soc_CB_PQM_LPG2PG_IA_WDATA_PART0r_field_set(unit, &regval,
             PGf, &tmpval);
    rc = REG_WRITE_CB_PQM_LPG2PG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_init: Failed writing CB_PQM_LPG2PG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_init: Failed setting start of table %s status %x\n", 
                "lpg2pg", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_init: Failed Initialize table %s status %x\n", 
                "lpg2pg", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epgt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epgt_init(int unit, int start, int end, int inc, epgt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->mirror_tc;
    soc_CB_EPP_EPGT_IA_WDATA_PART0r_field_set(unit, &regval,
             MIRROR_TCf, &tmpval);
    tmpval = entry->mirror;
    soc_CB_EPP_EPGT_IA_WDATA_PART0r_field_set(unit, &regval,
             MIRRORf, &tmpval);
    tmpval = entry->sample;
    soc_CB_EPP_EPGT_IA_WDATA_PART0r_field_set(unit, &regval,
             SAMPLEf, &tmpval);
    tmpval = entry->mirror_dp;
    soc_CB_EPP_EPGT_IA_WDATA_PART0r_field_set(unit, &regval,
             MIRROR_DPf, &tmpval);
    rc = REG_WRITE_CB_EPP_EPGT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_init: Failed writing CB_EPP_EPGT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->mtu;
    soc_CB_EPP_EPGT_IA_WDATA_PART1r_field_set(unit, &regval,
             MTUf, &tmpval);
    rc = REG_WRITE_CB_EPP_EPGT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_init: Failed writing CB_EPP_EPGT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPGT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_init: Failed setting start of table %s status %x\n", 
                "epgt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPGT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_init: Failed Initialize table %s status %x\n", 
                "epgt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_rscale_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_rscale_init(int unit, int start, int end, int inc, bmu_rscale_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->scale;
    soc_CB_BMU_RSCALE_IA_WDATA_PART0r_field_set(unit, &regval,
             SCALEf, &tmpval);
    rc = REG_WRITE_CB_BMU_RSCALE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_init: Failed writing CB_BMU_RSCALE_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_RSCALE_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_init: Failed setting start of table %s status %x\n", 
                "bmu_rscale", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_RSCALE_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_init: Failed Initialize table %s status %x\n", 
                "bmu_rscale", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ppfov_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ppfov_init(int unit, int start, int end, int inc, lpg2ppfov_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->ppfov;
    soc_CB_PQM_LPG2PPFOV_IA_WDATA_PART0r_field_set(unit, &regval,
             PPFOVf, &tmpval);
    rc = REG_WRITE_CB_PQM_LPG2PPFOV_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_init: Failed writing CB_PQM_LPG2PPFOV_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PPFOV_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_init: Failed setting start of table %s status %x\n", 
                "lpg2ppfov", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PPFOV_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_init: Failed Initialize table %s status %x\n", 
                "lpg2ppfov", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vsit_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vsit_init(int unit, int start, int end, int inc, vsit_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->drop_ulf;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
             DROP_ULFf, &tmpval);
    tmpval = entry->learn;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
             LEARNf, &tmpval);
    tmpval = entry->rsvd0;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
             RSVD0f, &tmpval);
    tmpval = entry->drop_slf;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
             DROP_SLFf, &tmpval);
    tmpval = entry->hit_smac_if_dmac_mcast;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
             HIT_SMAC_IF_DMAC_MCASTf, &tmpval);
    tmpval = entry->drop_mlf;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
             DROP_MLFf, &tmpval);
    tmpval = entry->rsvd1;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
             RSVD1f, &tmpval);
    tmpval = entry->stgid;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
             STGIDf, &tmpval);
    tmpval = entry->drop_bcast;
    soc_CB_IPP_VSIT_IA_WDATA_PART0r_field_set(unit, &regval,
             DROP_BCASTf, &tmpval);
    rc = REG_WRITE_CB_IPP_VSIT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_init: Failed writing CB_IPP_VSIT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->pg_map;
    soc_CB_IPP_VSIT_IA_WDATA_PART1r_field_set(unit, &regval,
             PG_MAPf, &tmpval);
    rc = REG_WRITE_CB_IPP_VSIT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_init: Failed writing CB_IPP_VSIT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->dlliid_dgid;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
             DLLIID_DGIDf, &tmpval);
    tmpval = entry->wred_ena;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
             WRED_ENAf, &tmpval);
    tmpval = entry->default_is_multicast;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
             DEFAULT_IS_MULTICASTf, &tmpval);
    tmpval = entry->sli_lpbk_ena;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
             SLI_LPBK_ENAf, &tmpval);
    tmpval = entry->iso_map;
    soc_CB_IPP_VSIT_IA_WDATA_PART2r_field_set(unit, &regval,
             ISO_MAPf, &tmpval);
    rc = REG_WRITE_CB_IPP_VSIT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_init: Failed writing CB_IPP_VSIT_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->fid;
    soc_CB_IPP_VSIT_IA_WDATA_PART3r_field_set(unit, &regval,
             FIDf, &tmpval);
    rc = REG_WRITE_CB_IPP_VSIT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_init: Failed writing CB_IPP_VSIT_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VSIT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_init: Failed setting start of table %s status %x\n", 
                "vsit", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VSIT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_init: Failed Initialize table %s status %x\n", 
                "vsit", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfccredit_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfccredit_init(int unit, int start, int end, int inc, qfccredit_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->qfc_credit;
    soc_CB_PQM_QFCCREDIT_IA_WDATA_PART0r_field_set(unit, &regval,
             QFC_CREDITf, &tmpval);
    rc = REG_WRITE_CB_PQM_QFCCREDIT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_init: Failed writing CB_PQM_QFCCREDIT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCCREDIT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_init: Failed setting start of table %s status %x\n", 
                "qfccredit", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCCREDIT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_init: Failed Initialize table %s status %x\n", 
                "qfccredit", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tet_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tet_init(int unit, int start, int end, int inc, tet_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->tag;
    soc_CB_EPP_TET_IA_WDATA_PART0r_field_set(unit, &regval,
             TAGf, &tmpval);
    rc = REG_WRITE_CB_EPP_TET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_init: Failed writing CB_EPP_TET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_init: Failed setting start of table %s status %x\n", 
                "tet", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_init: Failed Initialize table %s status %x\n", 
                "tet", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pp2lpg_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pp2lpg_init(int unit, int start, int end, int inc, ipp_pp2lpg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->pgid;
    soc_CB_IPP_PP2LPG_IA_WDATA_PART0r_field_set(unit, &regval,
             PGIDf, &tmpval);
    rc = REG_WRITE_CB_IPP_PP2LPG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_init: Failed writing CB_IPP_PP2LPG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PP2LPG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_init: Failed setting start of table %s status %x\n", 
                "ipp_pp2lpg", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PP2LPG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_init: Failed Initialize table %s status %x\n", 
                "ipp_pp2lpg", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pptr_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pptr_init(int unit, int start, int end, int inc, pqm_pptr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->pointer;
    soc_CB_PQM_PPTR_IA_WDATA_PART0r_field_set(unit, &regval,
             POINTERf, &tmpval);
    rc = REG_WRITE_CB_PQM_PPTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_init: Failed writing CB_PQM_PPTR_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PPTR_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_init: Failed setting start of table %s status %x\n", 
                "pqm_pptr", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PPTR_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_init: Failed Initialize table %s status %x\n", 
                "pqm_pptr", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pmon_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pmon_init(int unit, int start, int end, int inc, bmu_pmon_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_BMU_PMON_IA_WDATA_PART0r_field_set(unit, &regval, 
             COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_WRITE_CB_BMU_PMON_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_init: Failed writing CB_BMU_PMON_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    soc_CB_BMU_PMON_IA_WDATA_PART1r_field_set(unit, &regval, 
             COUNT_MSBSf, &entry->count_msbs);
    rc = REG_WRITE_CB_BMU_PMON_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_init: Failed writing CB_BMU_PMON_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PMON_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_init: Failed setting start of table %s status %x\n", 
                "bmu_pmon", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PMON_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_init: Failed Initialize table %s status %x\n", 
                "bmu_pmon", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_etct_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_etct_init(int unit, int start, int end, int inc, etct_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->primap_ndx;
    soc_CB_ETM_ETCT_IA_WDATA_PART0r_field_set(unit, &regval,
             PRIMAP_NDXf, &tmpval);
    tmpval = entry->pcp;
    soc_CB_ETM_ETCT_IA_WDATA_PART0r_field_set(unit, &regval,
             PCPf, &tmpval);
    tmpval = entry->dei;
    soc_CB_ETM_ETCT_IA_WDATA_PART0r_field_set(unit, &regval,
             DEIf, &tmpval);
    tmpval = entry->opcode;
    soc_CB_ETM_ETCT_IA_WDATA_PART0r_field_set(unit, &regval,
             OPCODEf, &tmpval);
    rc = REG_WRITE_CB_ETM_ETCT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_init: Failed writing CB_ETM_ETCT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ETCT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_init: Failed setting start of table %s status %x\n", 
                "etct", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ETCT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_init: Failed Initialize table %s status %x\n", 
                "etct", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h0_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h0_init(int unit, int start, int end, int inc, arlfm1_ght_h0_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART0r_field_set(unit, &regval, 
             GHT_KEY_31_0_ARLFM1_MAC_LOf, &entry->ght_key_31_0_arlfm1_mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_init: Failed writing CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->ght_key_47_32_arlfm1_mac_hi_15_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r_field_set(unit, &regval,
             GHT_KEY_47_32_ARLFM1_MAC_HI_15_0f, &tmpval);
    tmpval = entry->ght_key_59_48_arlfm1_fid_11_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r_field_set(unit, &regval,
             GHT_KEY_59_48_ARLFM1_FID_11_0f, &tmpval);
    tmpval = entry->ght_key_63_62_arlfm1_upd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r_field_set(unit, &regval,
             GHT_KEY_63_62_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    tmpval = entry->ght_key_61_60_arlfm1_fwd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r_field_set(unit, &regval,
             GHT_KEY_61_60_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_init: Failed writing CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART2r_field_set(unit, &regval, 
             GHT_KEY_95_64_ARLFM1_MAC_LOf, &entry->ght_key_95_64_arlfm1_mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_init: Failed writing CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->ght_key_111_96_arlfm1_mac_hi;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r_field_set(unit, &regval,
             GHT_KEY_111_96_ARLFM1_MAC_HIf, &tmpval);
    tmpval = entry->ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r_field_set(unit, &regval,
             GHT_N_VSI_11_10_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    tmpval = entry->ght_n_vsi_9_0_key_113_112_arlfm1_fid;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r_field_set(unit, &regval,
             GHT_N_VSI_9_0_KEY_113_112_ARLFM1_FIDf, &tmpval);
    tmpval = entry->ght_valid_litype_arlfm1_upd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r_field_set(unit, &regval,
             GHT_VALID_LITYPE_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_init: Failed writing CB_ITM_ARLFM1_GHT_H0_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H0_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_init: Failed setting start of table %s status %x\n", 
                "arlfm1_ght_h0", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H0_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_init: Failed Initialize table %s status %x\n", 
                "arlfm1_ght_h0", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pmon_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pmon_init(int unit, int start, int end, int inc, cfp_pmon_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_CFP_PMON_IA_WDATA_PART0r_field_set(unit, &regval, 
             COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_WRITE_CB_CFP_PMON_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_init: Failed writing CB_CFP_PMON_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    soc_CB_CFP_PMON_IA_WDATA_PART1r_field_set(unit, &regval, 
             COUNT_MSBSf, &entry->count_msbs);
    rc = REG_WRITE_CB_CFP_PMON_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_init: Failed writing CB_CFP_PMON_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PMON_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_init: Failed setting start of table %s status %x\n", 
                "cfp_pmon", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PMON_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_init: Failed Initialize table %s status %x\n", 
                "cfp_pmon", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_max_config_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_max_config_init(int unit, int start, int end, int inc, max_config_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->max_tx_bytes;
    soc_CB_PQS_MAX_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
             MAX_TX_BYTESf, &tmpval);
    tmpval = entry->max_tx_pkts;
    soc_CB_PQS_MAX_CONFIG_IA_WDATA_PART0r_field_set(unit, &regval,
             MAX_TX_PKTSf, &tmpval);
    rc = REG_WRITE_CB_PQS_MAX_CONFIG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_init: Failed writing CB_PQS_MAX_CONFIG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MAX_CONFIG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_init: Failed setting start of table %s status %x\n", 
                "max_config", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MAX_CONFIG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_init: Failed Initialize table %s status %x\n", 
                "max_config", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_profile_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_profile_init(int unit, int start, int end, int inc, bmu_profile_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->cbs_exp;
    soc_CB_BMU_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CBS_EXPf, &tmpval);
    tmpval = entry->cbs_mantissa;
    soc_CB_BMU_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CBS_MANTISSAf, &tmpval);
    tmpval = entry->cir_mantissa;
    soc_CB_BMU_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CIR_MANTISSAf, &tmpval);
    tmpval = entry->cir_exp;
    soc_CB_BMU_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CIR_EXPf, &tmpval);
    rc = REG_WRITE_CB_BMU_PROFILE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_init: Failed writing CB_BMU_PROFILE_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->eir_exp;
    soc_CB_BMU_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EIR_EXPf, &tmpval);
    tmpval = entry->ebs_exp;
    soc_CB_BMU_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EBS_EXPf, &tmpval);
    tmpval = entry->eir_mantissa;
    soc_CB_BMU_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EIR_MANTISSAf, &tmpval);
    tmpval = entry->ebs_mantissa;
    soc_CB_BMU_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EBS_MANTISSAf, &tmpval);
    rc = REG_WRITE_CB_BMU_PROFILE_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_init: Failed writing CB_BMU_PROFILE_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->drop_on_red;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             DROP_ON_REDf, &tmpval);
    tmpval = entry->pkt_mode;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             PKT_MODEf, &tmpval);
    tmpval = entry->bktc_strict;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BKTC_STRICTf, &tmpval);
    tmpval = entry->bkte_strict;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BKTE_STRICTf, &tmpval);
    tmpval = entry->cf;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             CFf, &tmpval);
    tmpval = entry->rfc2698;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             RFC2698f, &tmpval);
    tmpval = entry->blind;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BLINDf, &tmpval);
    tmpval = entry->avb_mode;
    soc_CB_BMU_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             AVB_MODEf, &tmpval);
    rc = REG_WRITE_CB_BMU_PROFILE_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_init: Failed writing CB_BMU_PROFILE_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PROFILE_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_init: Failed setting start of table %s status %x\n", 
                "bmu_profile", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PROFILE_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_init: Failed Initialize table %s status %x\n", 
                "bmu_profile", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pv2li_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pv2li_init(int unit, int start, int end, int inc, pv2li_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->pg_map;
    soc_CB_IPP_PV2LI_IA_WDATA_PART0r_field_set(unit, &regval,
             PG_MAPf, &tmpval);
    rc = REG_WRITE_CB_IPP_PV2LI_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_init: Failed writing CB_IPP_PV2LI_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->vsi;
    soc_CB_IPP_PV2LI_IA_WDATA_PART1r_field_set(unit, &regval,
             VSIf, &tmpval);
    rc = REG_WRITE_CB_IPP_PV2LI_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_init: Failed writing CB_IPP_PV2LI_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PV2LI_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_init: Failed setting start of table %s status %x\n", 
                "pv2li", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PV2LI_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_init: Failed Initialize table %s status %x\n", 
                "pv2li", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_rscale_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_rscale_init(int unit, int start, int end, int inc, ipp_rscale_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->scale;
    soc_CB_IPP_RSCALE_IA_WDATA_PART0r_field_set(unit, &regval,
             SCALEf, &tmpval);
    rc = REG_WRITE_CB_IPP_RSCALE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_init: Failed writing CB_IPP_RSCALE_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_RSCALE_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_init: Failed setting start of table %s status %x\n", 
                "ipp_rscale", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_RSCALE_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_init: Failed Initialize table %s status %x\n", 
                "ipp_rscale", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pmon_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pmon_init(int unit, int start, int end, int inc, pqm_pmon_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_PQM_PMON_IA_WDATA_PART0r_field_set(unit, &regval, 
             COUNT_LSBSf, &entry->count_lsbs);
    rc = REG_WRITE_CB_PQM_PMON_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_init: Failed writing CB_PQM_PMON_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    soc_CB_PQM_PMON_IA_WDATA_PART1r_field_set(unit, &regval, 
             COUNT_MSBSf, &entry->count_msbs);
    rc = REG_WRITE_CB_PQM_PMON_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_init: Failed writing CB_PQM_PMON_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PMON_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_init: Failed setting start of table %s status %x\n", 
                "pqm_pmon", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PMON_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_init: Failed Initialize table %s status %x\n", 
                "pqm_pmon", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ikft_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ikft_init(int unit, int start, int end, int inc, ikft_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->htype;
    soc_CB_IPP_IKFT_IA_WDATA_PART0r_field_set(unit, &regval,
             HTYPEf, &tmpval);
    rc = REG_WRITE_CB_IPP_IKFT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_init: Failed writing CB_IPP_IKFT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->hposn;
    soc_CB_IPP_IKFT_IA_WDATA_PART1r_field_set(unit, &regval,
             HPOSNf, &tmpval);
    tmpval = entry->offset;
    soc_CB_IPP_IKFT_IA_WDATA_PART1r_field_set(unit, &regval,
             OFFSETf, &tmpval);
    tmpval = entry->length;
    soc_CB_IPP_IKFT_IA_WDATA_PART1r_field_set(unit, &regval,
             LENGTHf, &tmpval);
    rc = REG_WRITE_CB_IPP_IKFT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_init: Failed writing CB_IPP_IKFT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->key;
    soc_CB_IPP_IKFT_IA_WDATA_PART2r_field_set(unit, &regval,
             KEYf, &tmpval);
    tmpval = entry->exists;
    soc_CB_IPP_IKFT_IA_WDATA_PART2r_field_set(unit, &regval,
             EXISTSf, &tmpval);
    rc = REG_WRITE_CB_IPP_IKFT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_init: Failed writing CB_IPP_IKFT_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IKFT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_init: Failed setting start of table %s status %x\n", 
                "ikft", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IKFT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_init: Failed Initialize table %s status %x\n", 
                "ikft", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h1_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h1_init(int unit, int start, int end, int inc, arlfm1_ght_h1_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART0r_field_set(unit, &regval, 
             GHT_KEY_31_0_ARLFM1_MAC_LOf, &entry->ght_key_31_0_arlfm1_mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_init: Failed writing CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->ght_key_47_32_arlfm1_mac_hi_15_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r_field_set(unit, &regval,
             GHT_KEY_47_32_ARLFM1_MAC_HI_15_0f, &tmpval);
    tmpval = entry->ght_key_59_48_arlfm1_fid_11_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r_field_set(unit, &regval,
             GHT_KEY_59_48_ARLFM1_FID_11_0f, &tmpval);
    tmpval = entry->ght_key_63_62_arlfm1_upd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r_field_set(unit, &regval,
             GHT_KEY_63_62_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    tmpval = entry->ght_key_61_60_arlfm1_fwd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r_field_set(unit, &regval,
             GHT_KEY_61_60_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_init: Failed writing CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART2r_field_set(unit, &regval, 
             GHT_KEY_95_64_ARLFM1_MAC_LOf, &entry->ght_key_95_64_arlfm1_mac_lo);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_init: Failed writing CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->ght_key_111_96_arlfm1_mac_hi;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r_field_set(unit, &regval,
             GHT_KEY_111_96_ARLFM1_MAC_HIf, &tmpval);
    tmpval = entry->ght_n_vsi_11_10_arlfm1_fwd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r_field_set(unit, &regval,
             GHT_N_VSI_11_10_ARLFM1_FWD_CTRL_1_0f, &tmpval);
    tmpval = entry->ght_n_vsi_9_0_key_113_112_arlfm1_fid;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r_field_set(unit, &regval,
             GHT_N_VSI_9_0_KEY_113_112_ARLFM1_FIDf, &tmpval);
    tmpval = entry->ght_valid_litype_arlfm1_upd_ctrl_1_0;
    soc_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r_field_set(unit, &regval,
             GHT_VALID_LITYPE_ARLFM1_UPD_CTRL_1_0f, &tmpval);
    rc = REG_WRITE_CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_init: Failed writing CB_ITM_ARLFM1_GHT_H1_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H1_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_init: Failed setting start of table %s status %x\n", 
                "arlfm1_ght_h1", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H1_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_init: Failed Initialize table %s status %x\n", 
                "arlfm1_ght_h1", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epmt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epmt_init(int unit, int start, int end, int inc, epmt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_EPP_EPMT_IA_WDATA_PART0r_field_set(unit, &regval, 
             PMT_DATAf, &entry->pmt_data);
    rc = REG_WRITE_CB_EPP_EPMT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_init: Failed writing CB_EPP_EPMT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPMT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_init: Failed setting start of table %s status %x\n", 
                "epmt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPMT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_init: Failed Initialize table %s status %x\n", 
                "epmt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_bmu_tx_reorder_req_lmt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_bmu_tx_reorder_req_lmt_init(int unit, int start, int end, int inc, epp_bmu_tx_reorder_req_lmt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->per_port_req_limit;
    soc_CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_WDATA_PART0r_field_set(unit, &regval,
             PER_PORT_REQ_LIMITf, &tmpval);
    rc = REG_WRITE_CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_init: Failed writing CB_EPP_EPP_BMU_TX_REORDER_REQ_LMT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_init: Failed setting start of table %s status %x\n", 
                "epp_bmu_tx_reorder_req_lmt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_init: Failed Initialize table %s status %x\n", 
                "epp_bmu_tx_reorder_req_lmt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pptr_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pptr_init(int unit, int start, int end, int inc, bmu_pptr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->pointer;
    soc_CB_BMU_PPTR_IA_WDATA_PART0r_field_set(unit, &regval,
             POINTERf, &tmpval);
    rc = REG_WRITE_CB_BMU_PPTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_init: Failed writing CB_BMU_PPTR_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PPTR_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_init: Failed setting start of table %s status %x\n", 
                "bmu_pptr", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PPTR_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_init: Failed Initialize table %s status %x\n", 
                "bmu_pptr", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ert_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ert_init(int unit, int start, int end, int inc, ert_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->encap10;
    soc_CB_ETM_ERT_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP10f, &tmpval);
    tmpval = entry->encap9;
    soc_CB_ETM_ERT_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP9f, &tmpval);
    tmpval = entry->encap11;
    soc_CB_ETM_ERT_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP11f, &tmpval);
    tmpval = entry->encap8;
    soc_CB_ETM_ERT_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP8f, &tmpval);
    rc = REG_WRITE_CB_ETM_ERT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_init: Failed writing CB_ETM_ERT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->encap4;
    soc_CB_ETM_ERT_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP4f, &tmpval);
    tmpval = entry->encap5;
    soc_CB_ETM_ERT_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP5f, &tmpval);
    tmpval = entry->encap7;
    soc_CB_ETM_ERT_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP7f, &tmpval);
    tmpval = entry->encap6;
    soc_CB_ETM_ERT_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP6f, &tmpval);
    rc = REG_WRITE_CB_ETM_ERT_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_init: Failed writing CB_ETM_ERT_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->encap2;
    soc_CB_ETM_ERT_IA_WDATA_PART2r_field_set(unit, &regval,
             ENCAP2f, &tmpval);
    tmpval = entry->encap3;
    soc_CB_ETM_ERT_IA_WDATA_PART2r_field_set(unit, &regval,
             ENCAP3f, &tmpval);
    tmpval = entry->encap0;
    soc_CB_ETM_ERT_IA_WDATA_PART2r_field_set(unit, &regval,
             ENCAP0f, &tmpval);
    tmpval = entry->encap1;
    soc_CB_ETM_ERT_IA_WDATA_PART2r_field_set(unit, &regval,
             ENCAP1f, &tmpval);
    rc = REG_WRITE_CB_ETM_ERT_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_init: Failed writing CB_ETM_ERT_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->full;
    soc_CB_ETM_ERT_IA_WDATA_PART3r_field_set(unit, &regval,
             FULLf, &tmpval);
    rc = REG_WRITE_CB_ETM_ERT_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_init: Failed writing CB_ETM_ERT_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ERT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_init: Failed setting start of table %s status %x\n", 
                "ert", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ERT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_init: Failed Initialize table %s status %x\n", 
                "ert", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_action_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_action_init(int unit, int start, int end, int inc, action_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->ipf_learn_disable;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
             IPF_LEARN_DISABLEf, &tmpval);
    tmpval = entry->ipf_trap_offset;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
             IPF_TRAP_OFFSETf, &tmpval);
    tmpval = entry->ipf_mirror;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
             IPF_MIRRORf, &tmpval);
    tmpval = entry->ipf_change_tc;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
             IPF_CHANGE_TCf, &tmpval);
    tmpval = entry->ipf_tc;
    soc_CB_CFP_ACTION_IA_WDATA_PART0r_field_set(unit, &regval,
             IPF_TCf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_init: Failed writing CB_CFP_ACTION_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->ipf_dliid_dgid_sliid;
    soc_CB_CFP_ACTION_IA_WDATA_PART1r_field_set(unit, &regval,
             IPF_DLIID_DGID_SLIIDf, &tmpval);
    tmpval = entry->ipf_change_fwd;
    soc_CB_CFP_ACTION_IA_WDATA_PART1r_field_set(unit, &regval,
             IPF_CHANGE_FWDf, &tmpval);
    tmpval = entry->ipf_cfp_decap;
    soc_CB_CFP_ACTION_IA_WDATA_PART1r_field_set(unit, &regval,
             IPF_CFP_DECAPf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_init: Failed writing CB_CFP_ACTION_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->opf_tc;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
             OPF_TCf, &tmpval);
    tmpval = entry->opf_trap_offset;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
             OPF_TRAP_OFFSETf, &tmpval);
    tmpval = entry->opf_learn_disable;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
             OPF_LEARN_DISABLEf, &tmpval);
    tmpval = entry->opf_change_tc;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
             OPF_CHANGE_TCf, &tmpval);
    tmpval = entry->opf_mirror;
    soc_CB_CFP_ACTION_IA_WDATA_PART2r_field_set(unit, &regval,
             OPF_MIRRORf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_init: Failed writing CB_CFP_ACTION_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->opf_change_fwd;
    soc_CB_CFP_ACTION_IA_WDATA_PART3r_field_set(unit, &regval,
             OPF_CHANGE_FWDf, &tmpval);
    tmpval = entry->opf_dliid_dgid_sliid;
    soc_CB_CFP_ACTION_IA_WDATA_PART3r_field_set(unit, &regval,
             OPF_DLIID_DGID_SLIIDf, &tmpval);
    tmpval = entry->opf_cfp_decap;
    soc_CB_CFP_ACTION_IA_WDATA_PART3r_field_set(unit, &regval,
             OPF_CFP_DECAPf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART3r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_init: Failed writing CB_CFP_ACTION_IA_WDATA_PART3 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->dp;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
             DPf, &tmpval);
    tmpval = entry->counter_mode;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
             COUNTER_MODEf, &tmpval);
    tmpval = entry->meter;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
             METERf, &tmpval);
    tmpval = entry->override;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
             OVERRIDEf, &tmpval);
    tmpval = entry->change_dp;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
             CHANGE_DPf, &tmpval);
    tmpval = entry->sli_lpbk_ena;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
             SLI_LPBK_ENAf, &tmpval);
    tmpval = entry->dlf_override;
    soc_CB_CFP_ACTION_IA_WDATA_PART4r_field_set(unit, &regval,
             DLF_OVERRIDEf, &tmpval);
    rc = REG_WRITE_CB_CFP_ACTION_IA_WDATA_PART4r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_init: Failed writing CB_CFP_ACTION_IA_WDATA_PART4 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ACTION_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_init: Failed setting start of table %s status %x\n", 
                "action", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ACTION_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_init: Failed Initialize table %s status %x\n", 
                "action", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpslict_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpslict_init(int unit, int start, int end, int inc, rpslict_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->early_ack;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             EARLY_ACKf, &tmpval);
    tmpval = entry->use_tc;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             USE_TCf, &tmpval);
    tmpval = entry->use_dp;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             USE_DPf, &tmpval);
    tmpval = entry->default_tc;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             DEFAULT_TCf, &tmpval);
    tmpval = entry->default_dp;
    soc_CB_IPP_RPSLICT_IA_WDATA_PART0r_field_set(unit, &regval,
             DEFAULT_DPf, &tmpval);
    rc = REG_WRITE_CB_IPP_RPSLICT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_init: Failed writing CB_IPP_RPSLICT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPSLICT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_init: Failed setting start of table %s status %x\n", 
                "rpslict", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPSLICT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_init: Failed Initialize table %s status %x\n", 
                "rpslict", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slictecc_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slictecc_init(int unit, int start, int end, int inc, slictecc_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->ecc;
    soc_CB_IPP_SLICTECC_IA_WDATA_PART0r_field_set(unit, &regval,
             ECCf, &tmpval);
    rc = REG_WRITE_CB_IPP_SLICTECC_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_init: Failed writing CB_IPP_SLICTECC_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICTECC_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_init: Failed setting start of table %s status %x\n", 
                "slictecc", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICTECC_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_init: Failed Initialize table %s status %x\n", 
                "slictecc", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_litet_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_litet_init(int unit, int start, int end, int inc, litet_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->tx_ena;
    soc_CB_PQM_LITET_IA_WDATA_PART0r_field_set(unit, &regval,
             TX_ENAf, &tmpval);
    rc = REG_WRITE_CB_PQM_LITET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_init: Failed writing CB_PQM_LITET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LITET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_init: Failed setting start of table %s status %x\n", 
                "litet", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LITET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_init: Failed Initialize table %s status %x\n", 
                "litet", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tecc_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tecc_init(int unit, int start, int end, int inc, tecc_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->ecc;
    soc_CB_CFP_TECC_IA_WDATA_PART0r_field_set(unit, &regval,
             ECCf, &tmpval);
    rc = REG_WRITE_CB_CFP_TECC_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_init: Failed writing CB_CFP_TECC_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TECC_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_init: Failed setting start of table %s status %x\n", 
                "tecc", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TECC_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_init: Failed Initialize table %s status %x\n", 
                "tecc", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pptr_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pptr_init(int unit, int start, int end, int inc, cfp_pptr_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->pointer;
    soc_CB_CFP_PPTR_IA_WDATA_PART0r_field_set(unit, &regval,
             POINTERf, &tmpval);
    rc = REG_WRITE_CB_CFP_PPTR_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_init: Failed writing CB_CFP_PPTR_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PPTR_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_init: Failed setting start of table %s status %x\n", 
                "cfp_pptr", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PPTR_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_init: Failed Initialize table %s status %x\n", 
                "cfp_pptr", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wrt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wrt_init(int unit, int start, int end, int inc, wrt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->wide_rule_entry;
    soc_CB_CFP_WRT_IA_WDATA_PART0r_field_set(unit, &regval,
             WIDE_RULE_ENTRYf, &tmpval);
    rc = REG_WRITE_CB_CFP_WRT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_init: Failed writing CB_CFP_WRT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WRT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_init: Failed setting start of table %s status %x\n", 
                "wrt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WRT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_init: Failed Initialize table %s status %x\n", 
                "wrt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wpt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wpt_init(int unit, int start, int end, int inc, wpt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->gain;
    soc_CB_PQM_WPT_IA_WDATA_PART0r_field_set(unit, &regval,
             GAINf, &tmpval);
    tmpval = entry->scale;
    soc_CB_PQM_WPT_IA_WDATA_PART0r_field_set(unit, &regval,
             SCALEf, &tmpval);
    rc = REG_WRITE_CB_PQM_WPT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_init: Failed writing CB_PQM_WPT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WPT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_init: Failed setting start of table %s status %x\n", 
                "wpt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WPT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_init: Failed Initialize table %s status %x\n", 
                "wpt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dliet_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dliet_init(int unit, int start, int end, int inc, dliet_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->encap4;
    soc_CB_ETM_DLIET_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP4f, &tmpval);
    tmpval = entry->encap5;
    soc_CB_ETM_DLIET_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP5f, &tmpval);
    tmpval = entry->encap7;
    soc_CB_ETM_DLIET_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP7f, &tmpval);
    tmpval = entry->encap6;
    soc_CB_ETM_DLIET_IA_WDATA_PART0r_field_set(unit, &regval,
             ENCAP6f, &tmpval);
    rc = REG_WRITE_CB_ETM_DLIET_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_init: Failed writing CB_ETM_DLIET_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->encap2;
    soc_CB_ETM_DLIET_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP2f, &tmpval);
    tmpval = entry->encap3;
    soc_CB_ETM_DLIET_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP3f, &tmpval);
    tmpval = entry->encap0;
    soc_CB_ETM_DLIET_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP0f, &tmpval);
    tmpval = entry->encap1;
    soc_CB_ETM_DLIET_IA_WDATA_PART1r_field_set(unit, &regval,
             ENCAP1f, &tmpval);
    rc = REG_WRITE_CB_ETM_DLIET_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_init: Failed writing CB_ETM_DLIET_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->uc_encap_ptr;
    soc_CB_ETM_DLIET_IA_WDATA_PART2r_field_set(unit, &regval,
             UC_ENCAP_PTRf, &tmpval);
    tmpval = entry->mc_encap_ptr;
    soc_CB_ETM_DLIET_IA_WDATA_PART2r_field_set(unit, &regval,
             MC_ENCAP_PTRf, &tmpval);
    tmpval = entry->full;
    soc_CB_ETM_DLIET_IA_WDATA_PART2r_field_set(unit, &regval,
             FULLf, &tmpval);
    rc = REG_WRITE_CB_ETM_DLIET_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_init: Failed writing CB_ETM_DLIET_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLIET_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_init: Failed setting start of table %s status %x\n", 
                "dliet", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLIET_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_init: Failed Initialize table %s status %x\n", 
                "dliet", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pglct_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pglct_init(int unit, int start, int end, int inc, pglct_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->disable_update_static;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             DISABLE_UPDATE_STATICf, &tmpval);
    tmpval = entry->copy_unknown_smac;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             COPY_UNKNOWN_SMACf, &tmpval);
    tmpval = entry->pend_learn;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             PEND_LEARNf, &tmpval);
    tmpval = entry->copy_update;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             COPY_UPDATEf, &tmpval);
    tmpval = entry->disable_update_pending;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             DISABLE_UPDATE_PENDINGf, &tmpval);
    tmpval = entry->copy_update_static;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             COPY_UPDATE_STATICf, &tmpval);
    tmpval = entry->copy_overlimit;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             COPY_OVERLIMITf, &tmpval);
    tmpval = entry->disable_update;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             DISABLE_UPDATEf, &tmpval);
    tmpval = entry->disable_learn;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             DISABLE_LEARNf, &tmpval);
    tmpval = entry->learn_limit;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             LEARN_LIMITf, &tmpval);
    tmpval = entry->valid_for_n_type;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             VALID_FOR_N_TYPEf, &tmpval);
    tmpval = entry->drop_overlimit;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             DROP_OVERLIMITf, &tmpval);
    tmpval = entry->copy_update_pending;
    soc_CB_ITM_PGLCT_IA_WDATA_PART0r_field_set(unit, &regval,
             COPY_UPDATE_PENDINGf, &tmpval);
    rc = REG_WRITE_CB_ITM_PGLCT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_init: Failed writing CB_ITM_PGLCT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGLCT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_init: Failed setting start of table %s status %x\n", 
                "pglct", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGLCT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_init: Failed Initialize table %s status %x\n", 
                "pglct", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ap_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ap_init(int unit, int start, int end, int inc, lpg2ap_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->adm_profile;
    soc_CB_PQM_LPG2AP_IA_WDATA_PART0r_field_set(unit, &regval,
             ADM_PROFILEf, &tmpval);
    rc = REG_WRITE_CB_PQM_LPG2AP_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_init: Failed writing CB_PQM_LPG2AP_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2AP_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_init: Failed setting start of table %s status %x\n", 
                "lpg2ap", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2AP_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_init: Failed Initialize table %s status %x\n", 
                "lpg2ap", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_profile_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_profile_init(int unit, int start, int end, int inc, pqm_profile_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->cbs_exp;
    soc_CB_PQM_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CBS_EXPf, &tmpval);
    tmpval = entry->cbs_mantissa;
    soc_CB_PQM_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CBS_MANTISSAf, &tmpval);
    tmpval = entry->cir_mantissa;
    soc_CB_PQM_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CIR_MANTISSAf, &tmpval);
    tmpval = entry->cir_exp;
    soc_CB_PQM_PROFILE_IA_WDATA_PART0r_field_set(unit, &regval,
             CIR_EXPf, &tmpval);
    rc = REG_WRITE_CB_PQM_PROFILE_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_init: Failed writing CB_PQM_PROFILE_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->eir_exp;
    soc_CB_PQM_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EIR_EXPf, &tmpval);
    tmpval = entry->ebs_exp;
    soc_CB_PQM_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EBS_EXPf, &tmpval);
    tmpval = entry->eir_mantissa;
    soc_CB_PQM_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EIR_MANTISSAf, &tmpval);
    tmpval = entry->ebs_mantissa;
    soc_CB_PQM_PROFILE_IA_WDATA_PART1r_field_set(unit, &regval,
             EBS_MANTISSAf, &tmpval);
    rc = REG_WRITE_CB_PQM_PROFILE_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_init: Failed writing CB_PQM_PROFILE_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->drop_on_red;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             DROP_ON_REDf, &tmpval);
    tmpval = entry->pkt_mode;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             PKT_MODEf, &tmpval);
    tmpval = entry->bktc_strict;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BKTC_STRICTf, &tmpval);
    tmpval = entry->bkte_strict;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BKTE_STRICTf, &tmpval);
    tmpval = entry->cf;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             CFf, &tmpval);
    tmpval = entry->rfc2698;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             RFC2698f, &tmpval);
    tmpval = entry->blind;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             BLINDf, &tmpval);
    tmpval = entry->avb_mode;
    soc_CB_PQM_PROFILE_IA_WDATA_PART2r_field_set(unit, &regval,
             AVB_MODEf, &tmpval);
    rc = REG_WRITE_CB_PQM_PROFILE_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_init: Failed writing CB_PQM_PROFILE_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PROFILE_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_init: Failed setting start of table %s status %x\n", 
                "pqm_profile", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PROFILE_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_init: Failed Initialize table %s status %x\n", 
                "pqm_profile", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cpmt_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cpmt_init(int unit, int start, int end, int inc, cpmt_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->tc;
    soc_CB_IPP_CPMT_IA_WDATA_PART0r_field_set(unit, &regval,
             TCf, &tmpval);
    tmpval = entry->dp;
    soc_CB_IPP_CPMT_IA_WDATA_PART0r_field_set(unit, &regval,
             DPf, &tmpval);
    rc = REG_WRITE_CB_IPP_CPMT_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_init: Failed writing CB_IPP_CPMT_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CPMT_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_init: Failed setting start of table %s status %x\n", 
                "cpmt", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CPMT_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_init: Failed Initialize table %s status %x\n", 
                "cpmt", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pp2lpg_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pp2lpg_init(int unit, int start, int end, int inc, pqm_pp2lpg_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    tmpval = entry->pgid;
    soc_CB_PQM_PP2LPG_IA_WDATA_PART0r_field_set(unit, &regval,
             PGIDf, &tmpval);
    rc = REG_WRITE_CB_PQM_PP2LPG_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_init: Failed writing CB_PQM_PP2LPG_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PP2LPG_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_init: Failed setting start of table %s status %x\n", 
                "pqm_pp2lpg", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PP2LPG_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_init: Failed Initialize table %s status %x\n", 
                "pqm_pp2lpg", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ofarlfm_init
 * @par Description:
 *      Initialize the table entry with values given
 * 
 *    @param [in]  unit  :  Identifies the chip
 *    @param [in]  start :  Start index of table to init
 *    @param [in]  end   :  Last index of table to init
 *    @param [in]  inc   :  Flag to indicate if data should be auto incremented
 *                           Only 20bit data (with wrap around) will be changed
 *    @param [in]  entry :  Pointer to entry data to init table
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ofarlfm_init(int unit, int start, int end, int inc, ofarlfm_t *entry)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;
    uint32 regval = 0;
    uint32 cmd = 0;
    uint32 tmpval = 0;
    if (entry == NULL) { 
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_init: Invalid param for entry\n"));
        return SOC_E_PARAM; 
    }

    /* Set the wdata register with the fields */
    soc_CB_ITM_OFARLFM_IA_WDATA_PART0r_field_set(unit, &regval, 
             MAC_LOf, &entry->mac_lo);
    rc = REG_WRITE_CB_ITM_OFARLFM_IA_WDATA_PART0r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_init: Failed writing CB_ITM_OFARLFM_IA_WDATA_PART0 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->fid;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
             FIDf, &tmpval);
    tmpval = entry->upd_ctrl;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
             UPD_CTRLf, &tmpval);
    tmpval = entry->mac_hi;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
             MAC_HIf, &tmpval);
    tmpval = entry->fwd_ctrl;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART1r_field_set(unit, &regval,
             FWD_CTRLf, &tmpval);
    rc = REG_WRITE_CB_ITM_OFARLFM_IA_WDATA_PART1r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_init: Failed writing CB_ITM_OFARLFM_IA_WDATA_PART1 register rc %d \n", rc));
        return rc;
    }
    tmpval = entry->valid;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
             VALIDf, &tmpval);
    tmpval = entry->dst;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
             DSTf, &tmpval);
    tmpval = entry->dst_type;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
             DST_TYPEf, &tmpval);
    tmpval = entry->hit;
    soc_CB_ITM_OFARLFM_IA_WDATA_PART2r_field_set(unit, &regval,
             HITf, &tmpval);
    rc = REG_WRITE_CB_ITM_OFARLFM_IA_WDATA_PART2r(unit, &regval);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_init: Failed writing CB_ITM_OFARLFM_IA_WDATA_PART2 register rc %d \n", rc));
        return rc;
    }

    /* Initialize table, set start offset, then required init method */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_OFARLFM_ID,
             ROBO2_IA_OP_TABLE_INIT_START, start, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_init: Failed setting start of table %s status %x\n", 
                "ofarlfm", status));
    }
    /* Trigger HW auto increment if requested */
    cmd =  (inc == 1) ?  (ROBO2_IA_OP_TABLE_INIT_INC) : (ROBO2_IA_OP_TABLE_INIT);
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_OFARLFM_ID,
             cmd, end, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_init: Failed Initialize table %s status %x\n", 
                "ofarlfm", status));
    }

    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tct_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tct_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TCT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_reset: Failed Reset table %s status(%x)\n", "tct", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_reset: Failed Reset table %s status(%x)\n", "rpt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pgt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pgt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_reset: Failed Reset table %s status(%x)\n", "pgt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pmipage_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pmipage_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PMIPAGE_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_reset: Failed Reset table %s status(%x)\n", "pmipage", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_config_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_config_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_reset: Failed Reset table %s status(%x)\n", "gfcd_config", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_apt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_apt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_APT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_reset: Failed Reset table %s status(%x)\n", "apt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_cntr_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_cntr_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CNTR_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_reset: Failed Reset table %s status(%x)\n", "gfcd_cntr", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spg_pp_bmp_config_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spg_pp_bmp_config_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_reset: Failed Reset table %s status(%x)\n", "spg_pp_bmp_config", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dgt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dgt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DGT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_reset: Failed Reset table %s status(%x)\n", "dgt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gspg2ig_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gspg2ig_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GSPG2IG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_reset: Failed Reset table %s status(%x)\n", "gspg2ig", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_calendar_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_calendar_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_CALENDAR_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_reset: Failed Reset table %s status(%x)\n", "epp_calendar", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ght_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ght_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_reset: Failed Reset table %s status(%x)\n", "ght", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lin2vsi_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lin2vsi_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LIN2VSI_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_reset: Failed Reset table %s status(%x)\n", "lin2vsi", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_profile_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_profile_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_reset: Failed Reset table %s status(%x)\n", "cfp_profile", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_bucket_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_bucket_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_reset: Failed Reset table %s status(%x)\n", "cfp_bucket", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_calendar_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_calendar_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CALENDAR_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_reset: Failed Reset table %s status(%x)\n", "calendar", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pg2lpg_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pg2lpg_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PG2LPG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_reset: Failed Reset table %s status(%x)\n", "pg2lpg", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_reset: Failed Reset table %s status(%x)\n", "arlfm", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm0_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm0_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM0_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_reset: Failed Reset table %s status(%x)\n", "arlfm0", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_bucket_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_bucket_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_reset: Failed Reset table %s status(%x)\n", "ipp_bucket", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_config_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_config_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_reset: Failed Reset table %s status(%x)\n", "fcd_config", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stat_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stat_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STAT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_reset: Failed Reset table %s status(%x)\n", "stat", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_eeecfg_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_eeecfg_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EEECFG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_reset: Failed Reset table %s status(%x)\n", "eeecfg", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_hdt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_hdt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_HDT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_reset: Failed Reset table %s status(%x)\n", "hdt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_estget_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_estget_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ESTGET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_reset: Failed Reset table %s status(%x)\n", "estget", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_reset: Failed Reset table %s status(%x)\n", "stt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pet_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pet_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_reset: Failed Reset table %s status(%x)\n", "pet", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_istget_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_istget_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ISTGET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_reset: Failed Reset table %s status(%x)\n", "istget", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qdschcfg_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qdschcfg_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QDSCHCFG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_reset: Failed Reset table %s status(%x)\n", "qdschcfg", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_rscale_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_rscale_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_reset: Failed Reset table %s status(%x)\n", "pqm_rscale", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtr2tcb_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtr2tcb_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTR2TCB_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_reset: Failed Reset table %s status(%x)\n", "mtr2tcb", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dli2ldpg_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dli2ldpg_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLI2LDPG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_reset: Failed Reset table %s status(%x)\n", "dli2ldpg", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tc2qd_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tc2qd_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TC2QD_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_reset: Failed Reset table %s status(%x)\n", "tc2qd", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spldt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spldt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPLDT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_reset: Failed Reset table %s status(%x)\n", "spldt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_rscale_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_rscale_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_reset: Failed Reset table %s status(%x)\n", "cfp_rscale", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghtdt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghtdt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHTDT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_reset: Failed Reset table %s status(%x)\n", "ghtdt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_bucket_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_bucket_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_reset: Failed Reset table %s status(%x)\n", "bmu_bucket", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lilt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lilt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LILT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_reset: Failed Reset table %s status(%x)\n", "lilt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_svt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_svt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SVT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_reset: Failed Reset table %s status(%x)\n", "svt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slicmap_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slicmap_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICMAP_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_reset: Failed Reset table %s status(%x)\n", "slicmap", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_m2tk_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_m2tk_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_M2TK_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_reset: Failed Reset table %s status(%x)\n", "m2tk", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_art_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_art_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ART_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_reset: Failed Reset table %s status(%x)\n", "art", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ig_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ig_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2IG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_reset: Failed Reset table %s status(%x)\n", "lpg2ig", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_profile_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_profile_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_reset: Failed Reset table %s status(%x)\n", "ipp_profile", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfcqdaddr_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfcqdaddr_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCQDADDR_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_reset: Failed Reset table %s status(%x)\n", "qfcqdaddr", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtgt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtgt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTGT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_reset: Failed Reset table %s status(%x)\n", "mtgt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pptr_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pptr_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PPTR_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_reset: Failed Reset table %s status(%x)\n", "ipp_pptr", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_set_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_set_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_reset: Failed Reset table %s status(%x)\n", "set", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_srt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_srt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SRT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_reset: Failed Reset table %s status(%x)\n", "srt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pmon_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pmon_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PMON_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_reset: Failed Reset table %s status(%x)\n", "ipp_pmon", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vtct_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vtct_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VTCT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_reset: Failed Reset table %s status(%x)\n", "vtct", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfpcam_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfpcam_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFPCAM_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_reset: Failed Reset table %s status(%x)\n", "cfpcam", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_cntr_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_cntr_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CNTR_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_reset: Failed Reset table %s status(%x)\n", "fcd_cntr", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fpslict_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fpslict_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FPSLICT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_reset: Failed Reset table %s status(%x)\n", "fpslict", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_kst_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_kst_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_KST_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_reset: Failed Reset table %s status(%x)\n", "kst", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_bucket_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_bucket_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_reset: Failed Reset table %s status(%x)\n", "pqm_bucket", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghst_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghst_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHST_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_reset: Failed Reset table %s status(%x)\n", "ghst", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2pg_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2pg_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_reset: Failed Reset table %s status(%x)\n", "lpg2pg", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epgt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epgt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPGT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_reset: Failed Reset table %s status(%x)\n", "epgt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_rscale_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_rscale_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_reset: Failed Reset table %s status(%x)\n", "bmu_rscale", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ppfov_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ppfov_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PPFOV_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_reset: Failed Reset table %s status(%x)\n", "lpg2ppfov", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vsit_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vsit_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VSIT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_reset: Failed Reset table %s status(%x)\n", "vsit", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfccredit_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfccredit_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCCREDIT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_reset: Failed Reset table %s status(%x)\n", "qfccredit", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tet_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tet_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_reset: Failed Reset table %s status(%x)\n", "tet", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pp2lpg_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pp2lpg_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PP2LPG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_reset: Failed Reset table %s status(%x)\n", "ipp_pp2lpg", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pptr_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pptr_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PPTR_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_reset: Failed Reset table %s status(%x)\n", "pqm_pptr", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pmon_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pmon_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PMON_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_reset: Failed Reset table %s status(%x)\n", "bmu_pmon", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_etct_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_etct_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ETCT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_reset: Failed Reset table %s status(%x)\n", "etct", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h0_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h0_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H0_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_reset: Failed Reset table %s status(%x)\n", "arlfm1_ght_h0", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pmon_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pmon_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PMON_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_reset: Failed Reset table %s status(%x)\n", "cfp_pmon", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_max_config_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_max_config_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MAX_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_reset: Failed Reset table %s status(%x)\n", "max_config", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_profile_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_profile_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_reset: Failed Reset table %s status(%x)\n", "bmu_profile", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pv2li_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pv2li_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PV2LI_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_reset: Failed Reset table %s status(%x)\n", "pv2li", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_rscale_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_rscale_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_reset: Failed Reset table %s status(%x)\n", "ipp_rscale", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pmon_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pmon_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PMON_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_reset: Failed Reset table %s status(%x)\n", "pqm_pmon", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ikft_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ikft_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IKFT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_reset: Failed Reset table %s status(%x)\n", "ikft", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h1_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h1_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H1_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_reset: Failed Reset table %s status(%x)\n", "arlfm1_ght_h1", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epmt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epmt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPMT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_reset: Failed Reset table %s status(%x)\n", "epmt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_bmu_tx_reorder_req_lmt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_bmu_tx_reorder_req_lmt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_reset: Failed Reset table %s status(%x)\n", "epp_bmu_tx_reorder_req_lmt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pptr_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pptr_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PPTR_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_reset: Failed Reset table %s status(%x)\n", "bmu_pptr", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ert_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ert_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ERT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_reset: Failed Reset table %s status(%x)\n", "ert", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_action_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_action_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ACTION_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_reset: Failed Reset table %s status(%x)\n", "action", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpslict_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpslict_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPSLICT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_reset: Failed Reset table %s status(%x)\n", "rpslict", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slictecc_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slictecc_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICTECC_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_reset: Failed Reset table %s status(%x)\n", "slictecc", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_litet_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_litet_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LITET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_reset: Failed Reset table %s status(%x)\n", "litet", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tecc_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tecc_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TECC_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_reset: Failed Reset table %s status(%x)\n", "tecc", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pptr_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pptr_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PPTR_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_reset: Failed Reset table %s status(%x)\n", "cfp_pptr", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wrt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wrt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WRT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_reset: Failed Reset table %s status(%x)\n", "wrt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wpt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wpt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WPT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_reset: Failed Reset table %s status(%x)\n", "wpt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dliet_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dliet_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLIET_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_reset: Failed Reset table %s status(%x)\n", "dliet", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pglct_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pglct_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGLCT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_reset: Failed Reset table %s status(%x)\n", "pglct", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ap_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ap_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2AP_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_reset: Failed Reset table %s status(%x)\n", "lpg2ap", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_profile_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_profile_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_reset: Failed Reset table %s status(%x)\n", "pqm_profile", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cpmt_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cpmt_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CPMT_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_reset: Failed Reset table %s status(%x)\n", "cpmt", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pp2lpg_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pp2lpg_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PP2LPG_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_reset: Failed Reset table %s status(%x)\n", "pqm_pp2lpg", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ofarlfm_reset
 * @par Description:
 *      Reset the table and init all entries to Hw defaults
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ofarlfm_reset(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Reset table */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_OFARLFM_ID, 
             ROBO2_IA_OP_TABLE_RESET, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_reset: Failed Reset table %s status(%x)\n", "ofarlfm", status));
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tct_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tct_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TCT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_enable: Failed enable table %s\n", "tct"));
    }
    if (tct_mutex == NULL) {
        tct_mutex = sal_mutex_create("tct");
        if (tct_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_tct_enable: Failed mutex create for table %s\n", "tct"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_enable: Failed enable table %s\n", "rpt"));
    }
    if (rpt_mutex == NULL) {
        rpt_mutex = sal_mutex_create("rpt");
        if (rpt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_rpt_enable: Failed mutex create for table %s\n", "rpt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pgt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pgt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_enable: Failed enable table %s\n", "pgt"));
    }
    if (pgt_mutex == NULL) {
        pgt_mutex = sal_mutex_create("pgt");
        if (pgt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pgt_enable: Failed mutex create for table %s\n", "pgt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pmipage_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pmipage_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PMIPAGE_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_enable: Failed enable table %s\n", "pmipage"));
    }
    if (pmipage_mutex == NULL) {
        pmipage_mutex = sal_mutex_create("pmipage");
        if (pmipage_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pmipage_enable: Failed mutex create for table %s\n", "pmipage"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_config_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_config_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_enable: Failed enable table %s\n", "gfcd_config"));
    }
    if (gfcd_config_mutex == NULL) {
        gfcd_config_mutex = sal_mutex_create("gfcd_config");
        if (gfcd_config_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_gfcd_config_enable: Failed mutex create for table %s\n", "gfcd_config"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_apt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_apt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_APT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_enable: Failed enable table %s\n", "apt"));
    }
    if (apt_mutex == NULL) {
        apt_mutex = sal_mutex_create("apt");
        if (apt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_apt_enable: Failed mutex create for table %s\n", "apt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_cntr_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_cntr_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CNTR_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_enable: Failed enable table %s\n", "gfcd_cntr"));
    }
    if (gfcd_cntr_mutex == NULL) {
        gfcd_cntr_mutex = sal_mutex_create("gfcd_cntr");
        if (gfcd_cntr_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_gfcd_cntr_enable: Failed mutex create for table %s\n", "gfcd_cntr"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spg_pp_bmp_config_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spg_pp_bmp_config_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_enable: Failed enable table %s\n", "spg_pp_bmp_config"));
    }
    if (spg_pp_bmp_config_mutex == NULL) {
        spg_pp_bmp_config_mutex = sal_mutex_create("spg_pp_bmp_con");
        if (spg_pp_bmp_config_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_spg_pp_bmp_config_enable: Failed mutex create for table %s\n", "spg_pp_bmp_config"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dgt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dgt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DGT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_enable: Failed enable table %s\n", "dgt"));
    }
    if (dgt_mutex == NULL) {
        dgt_mutex = sal_mutex_create("dgt");
        if (dgt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_dgt_enable: Failed mutex create for table %s\n", "dgt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gspg2ig_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gspg2ig_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GSPG2IG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_enable: Failed enable table %s\n", "gspg2ig"));
    }
    if (gspg2ig_mutex == NULL) {
        gspg2ig_mutex = sal_mutex_create("gspg2ig");
        if (gspg2ig_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_gspg2ig_enable: Failed mutex create for table %s\n", "gspg2ig"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_calendar_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_calendar_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_CALENDAR_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_enable: Failed enable table %s\n", "epp_calendar"));
    }
    if (epp_calendar_mutex == NULL) {
        epp_calendar_mutex = sal_mutex_create("epp_calendar");
        if (epp_calendar_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_epp_calendar_enable: Failed mutex create for table %s\n", "epp_calendar"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ght_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ght_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_enable: Failed enable table %s\n", "ght"));
    }
    if (ght_mutex == NULL) {
        ght_mutex = sal_mutex_create("ght");
        if (ght_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ght_enable: Failed mutex create for table %s\n", "ght"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lin2vsi_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lin2vsi_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LIN2VSI_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_enable: Failed enable table %s\n", "lin2vsi"));
    }
    if (lin2vsi_mutex == NULL) {
        lin2vsi_mutex = sal_mutex_create("lin2vsi");
        if (lin2vsi_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_lin2vsi_enable: Failed mutex create for table %s\n", "lin2vsi"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_profile_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_profile_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_enable: Failed enable table %s\n", "cfp_profile"));
    }
    if (cfp_profile_mutex == NULL) {
        cfp_profile_mutex = sal_mutex_create("cfp_profile");
        if (cfp_profile_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_cfp_profile_enable: Failed mutex create for table %s\n", "cfp_profile"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_bucket_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_bucket_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_enable: Failed enable table %s\n", "cfp_bucket"));
    }
    if (cfp_bucket_mutex == NULL) {
        cfp_bucket_mutex = sal_mutex_create("cfp_bucket");
        if (cfp_bucket_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_cfp_bucket_enable: Failed mutex create for table %s\n", "cfp_bucket"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_calendar_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_calendar_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CALENDAR_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_enable: Failed enable table %s\n", "calendar"));
    }
    if (calendar_mutex == NULL) {
        calendar_mutex = sal_mutex_create("calendar");
        if (calendar_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_calendar_enable: Failed mutex create for table %s\n", "calendar"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pg2lpg_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pg2lpg_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PG2LPG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_enable: Failed enable table %s\n", "pg2lpg"));
    }
    if (pg2lpg_mutex == NULL) {
        pg2lpg_mutex = sal_mutex_create("pg2lpg");
        if (pg2lpg_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pg2lpg_enable: Failed mutex create for table %s\n", "pg2lpg"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_enable: Failed enable table %s\n", "arlfm"));
    }
    if (arlfm_mutex == NULL) {
        arlfm_mutex = sal_mutex_create("arlfm");
        if (arlfm_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_arlfm_enable: Failed mutex create for table %s\n", "arlfm"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm0_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm0_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM0_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_enable: Failed enable table %s\n", "arlfm0"));
    }
    if (arlfm0_mutex == NULL) {
        arlfm0_mutex = sal_mutex_create("arlfm0");
        if (arlfm0_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_arlfm0_enable: Failed mutex create for table %s\n", "arlfm0"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_bucket_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_bucket_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_enable: Failed enable table %s\n", "ipp_bucket"));
    }
    if (ipp_bucket_mutex == NULL) {
        ipp_bucket_mutex = sal_mutex_create("ipp_bucket");
        if (ipp_bucket_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ipp_bucket_enable: Failed mutex create for table %s\n", "ipp_bucket"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_config_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_config_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_enable: Failed enable table %s\n", "fcd_config"));
    }
    if (fcd_config_mutex == NULL) {
        fcd_config_mutex = sal_mutex_create("fcd_config");
        if (fcd_config_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_fcd_config_enable: Failed mutex create for table %s\n", "fcd_config"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stat_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stat_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STAT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_enable: Failed enable table %s\n", "stat"));
    }
    if (stat_mutex == NULL) {
        stat_mutex = sal_mutex_create("stat");
        if (stat_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_stat_enable: Failed mutex create for table %s\n", "stat"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_eeecfg_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_eeecfg_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EEECFG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_enable: Failed enable table %s\n", "eeecfg"));
    }
    if (eeecfg_mutex == NULL) {
        eeecfg_mutex = sal_mutex_create("eeecfg");
        if (eeecfg_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_eeecfg_enable: Failed mutex create for table %s\n", "eeecfg"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_hdt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_hdt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_HDT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_enable: Failed enable table %s\n", "hdt"));
    }
    if (hdt_mutex == NULL) {
        hdt_mutex = sal_mutex_create("hdt");
        if (hdt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_hdt_enable: Failed mutex create for table %s\n", "hdt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_estget_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_estget_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ESTGET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_enable: Failed enable table %s\n", "estget"));
    }
    if (estget_mutex == NULL) {
        estget_mutex = sal_mutex_create("estget");
        if (estget_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_estget_enable: Failed mutex create for table %s\n", "estget"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_enable: Failed enable table %s\n", "stt"));
    }
    if (stt_mutex == NULL) {
        stt_mutex = sal_mutex_create("stt");
        if (stt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_stt_enable: Failed mutex create for table %s\n", "stt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pet_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pet_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_enable: Failed enable table %s\n", "pet"));
    }
    if (pet_mutex == NULL) {
        pet_mutex = sal_mutex_create("pet");
        if (pet_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pet_enable: Failed mutex create for table %s\n", "pet"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_istget_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_istget_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ISTGET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_enable: Failed enable table %s\n", "istget"));
    }
    if (istget_mutex == NULL) {
        istget_mutex = sal_mutex_create("istget");
        if (istget_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_istget_enable: Failed mutex create for table %s\n", "istget"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qdschcfg_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qdschcfg_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QDSCHCFG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_enable: Failed enable table %s\n", "qdschcfg"));
    }
    if (qdschcfg_mutex == NULL) {
        qdschcfg_mutex = sal_mutex_create("qdschcfg");
        if (qdschcfg_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_qdschcfg_enable: Failed mutex create for table %s\n", "qdschcfg"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_rscale_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_rscale_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_enable: Failed enable table %s\n", "pqm_rscale"));
    }
    if (pqm_rscale_mutex == NULL) {
        pqm_rscale_mutex = sal_mutex_create("pqm_rscale");
        if (pqm_rscale_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pqm_rscale_enable: Failed mutex create for table %s\n", "pqm_rscale"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtr2tcb_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtr2tcb_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTR2TCB_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_enable: Failed enable table %s\n", "mtr2tcb"));
    }
    if (mtr2tcb_mutex == NULL) {
        mtr2tcb_mutex = sal_mutex_create("mtr2tcb");
        if (mtr2tcb_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_mtr2tcb_enable: Failed mutex create for table %s\n", "mtr2tcb"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dli2ldpg_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dli2ldpg_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLI2LDPG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_enable: Failed enable table %s\n", "dli2ldpg"));
    }
    if (dli2ldpg_mutex == NULL) {
        dli2ldpg_mutex = sal_mutex_create("dli2ldpg");
        if (dli2ldpg_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_dli2ldpg_enable: Failed mutex create for table %s\n", "dli2ldpg"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tc2qd_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tc2qd_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TC2QD_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_enable: Failed enable table %s\n", "tc2qd"));
    }
    if (tc2qd_mutex == NULL) {
        tc2qd_mutex = sal_mutex_create("tc2qd");
        if (tc2qd_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_tc2qd_enable: Failed mutex create for table %s\n", "tc2qd"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spldt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spldt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPLDT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_enable: Failed enable table %s\n", "spldt"));
    }
    if (spldt_mutex == NULL) {
        spldt_mutex = sal_mutex_create("spldt");
        if (spldt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_spldt_enable: Failed mutex create for table %s\n", "spldt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_rscale_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_rscale_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_enable: Failed enable table %s\n", "cfp_rscale"));
    }
    if (cfp_rscale_mutex == NULL) {
        cfp_rscale_mutex = sal_mutex_create("cfp_rscale");
        if (cfp_rscale_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_cfp_rscale_enable: Failed mutex create for table %s\n", "cfp_rscale"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghtdt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghtdt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHTDT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_enable: Failed enable table %s\n", "ghtdt"));
    }
    if (ghtdt_mutex == NULL) {
        ghtdt_mutex = sal_mutex_create("ghtdt");
        if (ghtdt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ghtdt_enable: Failed mutex create for table %s\n", "ghtdt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_bucket_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_bucket_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_enable: Failed enable table %s\n", "bmu_bucket"));
    }
    if (bmu_bucket_mutex == NULL) {
        bmu_bucket_mutex = sal_mutex_create("bmu_bucket");
        if (bmu_bucket_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_bmu_bucket_enable: Failed mutex create for table %s\n", "bmu_bucket"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lilt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lilt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LILT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_enable: Failed enable table %s\n", "lilt"));
    }
    if (lilt_mutex == NULL) {
        lilt_mutex = sal_mutex_create("lilt");
        if (lilt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_lilt_enable: Failed mutex create for table %s\n", "lilt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_svt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_svt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SVT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_enable: Failed enable table %s\n", "svt"));
    }
    if (svt_mutex == NULL) {
        svt_mutex = sal_mutex_create("svt");
        if (svt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_svt_enable: Failed mutex create for table %s\n", "svt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slicmap_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slicmap_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICMAP_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_enable: Failed enable table %s\n", "slicmap"));
    }
    if (slicmap_mutex == NULL) {
        slicmap_mutex = sal_mutex_create("slicmap");
        if (slicmap_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_slicmap_enable: Failed mutex create for table %s\n", "slicmap"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_m2tk_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_m2tk_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_M2TK_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_enable: Failed enable table %s\n", "m2tk"));
    }
    if (m2tk_mutex == NULL) {
        m2tk_mutex = sal_mutex_create("m2tk");
        if (m2tk_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_m2tk_enable: Failed mutex create for table %s\n", "m2tk"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_art_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_art_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ART_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_enable: Failed enable table %s\n", "art"));
    }
    if (art_mutex == NULL) {
        art_mutex = sal_mutex_create("art");
        if (art_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_art_enable: Failed mutex create for table %s\n", "art"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ig_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ig_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2IG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_enable: Failed enable table %s\n", "lpg2ig"));
    }
    if (lpg2ig_mutex == NULL) {
        lpg2ig_mutex = sal_mutex_create("lpg2ig");
        if (lpg2ig_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_lpg2ig_enable: Failed mutex create for table %s\n", "lpg2ig"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_profile_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_profile_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_enable: Failed enable table %s\n", "ipp_profile"));
    }
    if (ipp_profile_mutex == NULL) {
        ipp_profile_mutex = sal_mutex_create("ipp_profile");
        if (ipp_profile_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ipp_profile_enable: Failed mutex create for table %s\n", "ipp_profile"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfcqdaddr_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfcqdaddr_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCQDADDR_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_enable: Failed enable table %s\n", "qfcqdaddr"));
    }
    if (qfcqdaddr_mutex == NULL) {
        qfcqdaddr_mutex = sal_mutex_create("qfcqdaddr");
        if (qfcqdaddr_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_qfcqdaddr_enable: Failed mutex create for table %s\n", "qfcqdaddr"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtgt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtgt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTGT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_enable: Failed enable table %s\n", "mtgt"));
    }
    if (mtgt_mutex == NULL) {
        mtgt_mutex = sal_mutex_create("mtgt");
        if (mtgt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_mtgt_enable: Failed mutex create for table %s\n", "mtgt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pptr_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pptr_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PPTR_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_enable: Failed enable table %s\n", "ipp_pptr"));
    }
    if (ipp_pptr_mutex == NULL) {
        ipp_pptr_mutex = sal_mutex_create("ipp_pptr");
        if (ipp_pptr_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ipp_pptr_enable: Failed mutex create for table %s\n", "ipp_pptr"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_set_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_set_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_enable: Failed enable table %s\n", "set"));
    }
    if (set_mutex == NULL) {
        set_mutex = sal_mutex_create("set");
        if (set_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_set_enable: Failed mutex create for table %s\n", "set"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_srt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_srt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SRT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_enable: Failed enable table %s\n", "srt"));
    }
    if (srt_mutex == NULL) {
        srt_mutex = sal_mutex_create("srt");
        if (srt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_srt_enable: Failed mutex create for table %s\n", "srt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pmon_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pmon_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PMON_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_enable: Failed enable table %s\n", "ipp_pmon"));
    }
    if (ipp_pmon_mutex == NULL) {
        ipp_pmon_mutex = sal_mutex_create("ipp_pmon");
        if (ipp_pmon_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ipp_pmon_enable: Failed mutex create for table %s\n", "ipp_pmon"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vtct_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vtct_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VTCT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_enable: Failed enable table %s\n", "vtct"));
    }
    if (vtct_mutex == NULL) {
        vtct_mutex = sal_mutex_create("vtct");
        if (vtct_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_vtct_enable: Failed mutex create for table %s\n", "vtct"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfpcam_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfpcam_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFPCAM_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_enable: Failed enable table %s\n", "cfpcam"));
    }
    if (cfpcam_mutex == NULL) {
        cfpcam_mutex = sal_mutex_create("cfpcam");
        if (cfpcam_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_cfpcam_enable: Failed mutex create for table %s\n", "cfpcam"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_cntr_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_cntr_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CNTR_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_enable: Failed enable table %s\n", "fcd_cntr"));
    }
    if (fcd_cntr_mutex == NULL) {
        fcd_cntr_mutex = sal_mutex_create("fcd_cntr");
        if (fcd_cntr_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_fcd_cntr_enable: Failed mutex create for table %s\n", "fcd_cntr"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fpslict_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fpslict_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FPSLICT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_enable: Failed enable table %s\n", "fpslict"));
    }
    if (fpslict_mutex == NULL) {
        fpslict_mutex = sal_mutex_create("fpslict");
        if (fpslict_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_fpslict_enable: Failed mutex create for table %s\n", "fpslict"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_kst_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_kst_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_KST_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_enable: Failed enable table %s\n", "kst"));
    }
    if (kst_mutex == NULL) {
        kst_mutex = sal_mutex_create("kst");
        if (kst_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_kst_enable: Failed mutex create for table %s\n", "kst"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_bucket_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_bucket_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_BUCKET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_enable: Failed enable table %s\n", "pqm_bucket"));
    }
    if (pqm_bucket_mutex == NULL) {
        pqm_bucket_mutex = sal_mutex_create("pqm_bucket");
        if (pqm_bucket_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pqm_bucket_enable: Failed mutex create for table %s\n", "pqm_bucket"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghst_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghst_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHST_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_enable: Failed enable table %s\n", "ghst"));
    }
    if (ghst_mutex == NULL) {
        ghst_mutex = sal_mutex_create("ghst");
        if (ghst_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ghst_enable: Failed mutex create for table %s\n", "ghst"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2pg_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2pg_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_enable: Failed enable table %s\n", "lpg2pg"));
    }
    if (lpg2pg_mutex == NULL) {
        lpg2pg_mutex = sal_mutex_create("lpg2pg");
        if (lpg2pg_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_lpg2pg_enable: Failed mutex create for table %s\n", "lpg2pg"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epgt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epgt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPGT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_enable: Failed enable table %s\n", "epgt"));
    }
    if (epgt_mutex == NULL) {
        epgt_mutex = sal_mutex_create("epgt");
        if (epgt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_epgt_enable: Failed mutex create for table %s\n", "epgt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_rscale_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_rscale_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_enable: Failed enable table %s\n", "bmu_rscale"));
    }
    if (bmu_rscale_mutex == NULL) {
        bmu_rscale_mutex = sal_mutex_create("bmu_rscale");
        if (bmu_rscale_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_bmu_rscale_enable: Failed mutex create for table %s\n", "bmu_rscale"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ppfov_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ppfov_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PPFOV_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_enable: Failed enable table %s\n", "lpg2ppfov"));
    }
    if (lpg2ppfov_mutex == NULL) {
        lpg2ppfov_mutex = sal_mutex_create("lpg2ppfov");
        if (lpg2ppfov_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_lpg2ppfov_enable: Failed mutex create for table %s\n", "lpg2ppfov"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vsit_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vsit_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VSIT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_enable: Failed enable table %s\n", "vsit"));
    }
    if (vsit_mutex == NULL) {
        vsit_mutex = sal_mutex_create("vsit");
        if (vsit_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_vsit_enable: Failed mutex create for table %s\n", "vsit"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfccredit_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfccredit_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCCREDIT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_enable: Failed enable table %s\n", "qfccredit"));
    }
    if (qfccredit_mutex == NULL) {
        qfccredit_mutex = sal_mutex_create("qfccredit");
        if (qfccredit_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_qfccredit_enable: Failed mutex create for table %s\n", "qfccredit"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tet_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tet_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_enable: Failed enable table %s\n", "tet"));
    }
    if (tet_mutex == NULL) {
        tet_mutex = sal_mutex_create("tet");
        if (tet_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_tet_enable: Failed mutex create for table %s\n", "tet"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pp2lpg_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pp2lpg_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PP2LPG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_enable: Failed enable table %s\n", "ipp_pp2lpg"));
    }
    if (ipp_pp2lpg_mutex == NULL) {
        ipp_pp2lpg_mutex = sal_mutex_create("ipp_pp2lpg");
        if (ipp_pp2lpg_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ipp_pp2lpg_enable: Failed mutex create for table %s\n", "ipp_pp2lpg"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pptr_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pptr_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PPTR_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_enable: Failed enable table %s\n", "pqm_pptr"));
    }
    if (pqm_pptr_mutex == NULL) {
        pqm_pptr_mutex = sal_mutex_create("pqm_pptr");
        if (pqm_pptr_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pqm_pptr_enable: Failed mutex create for table %s\n", "pqm_pptr"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pmon_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pmon_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PMON_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_enable: Failed enable table %s\n", "bmu_pmon"));
    }
    if (bmu_pmon_mutex == NULL) {
        bmu_pmon_mutex = sal_mutex_create("bmu_pmon");
        if (bmu_pmon_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_bmu_pmon_enable: Failed mutex create for table %s\n", "bmu_pmon"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_etct_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_etct_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ETCT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_enable: Failed enable table %s\n", "etct"));
    }
    if (etct_mutex == NULL) {
        etct_mutex = sal_mutex_create("etct");
        if (etct_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_etct_enable: Failed mutex create for table %s\n", "etct"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h0_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h0_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H0_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_enable: Failed enable table %s\n", "arlfm1_ght_h0"));
    }
    if (arlfm1_ght_h0_mutex == NULL) {
        arlfm1_ght_h0_mutex = sal_mutex_create("arlfm1_ght_h0");
        if (arlfm1_ght_h0_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_arlfm1_ght_h0_enable: Failed mutex create for table %s\n", "arlfm1_ght_h0"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pmon_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pmon_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PMON_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_enable: Failed enable table %s\n", "cfp_pmon"));
    }
    if (cfp_pmon_mutex == NULL) {
        cfp_pmon_mutex = sal_mutex_create("cfp_pmon");
        if (cfp_pmon_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_cfp_pmon_enable: Failed mutex create for table %s\n", "cfp_pmon"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_max_config_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_max_config_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MAX_CONFIG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_enable: Failed enable table %s\n", "max_config"));
    }
    if (max_config_mutex == NULL) {
        max_config_mutex = sal_mutex_create("max_config");
        if (max_config_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_max_config_enable: Failed mutex create for table %s\n", "max_config"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_profile_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_profile_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_enable: Failed enable table %s\n", "bmu_profile"));
    }
    if (bmu_profile_mutex == NULL) {
        bmu_profile_mutex = sal_mutex_create("bmu_profile");
        if (bmu_profile_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_bmu_profile_enable: Failed mutex create for table %s\n", "bmu_profile"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pv2li_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pv2li_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PV2LI_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_enable: Failed enable table %s\n", "pv2li"));
    }
    if (pv2li_mutex == NULL) {
        pv2li_mutex = sal_mutex_create("pv2li");
        if (pv2li_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pv2li_enable: Failed mutex create for table %s\n", "pv2li"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_rscale_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_rscale_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_RSCALE_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_enable: Failed enable table %s\n", "ipp_rscale"));
    }
    if (ipp_rscale_mutex == NULL) {
        ipp_rscale_mutex = sal_mutex_create("ipp_rscale");
        if (ipp_rscale_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ipp_rscale_enable: Failed mutex create for table %s\n", "ipp_rscale"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pmon_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pmon_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PMON_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_enable: Failed enable table %s\n", "pqm_pmon"));
    }
    if (pqm_pmon_mutex == NULL) {
        pqm_pmon_mutex = sal_mutex_create("pqm_pmon");
        if (pqm_pmon_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pqm_pmon_enable: Failed mutex create for table %s\n", "pqm_pmon"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ikft_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ikft_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IKFT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_enable: Failed enable table %s\n", "ikft"));
    }
    if (ikft_mutex == NULL) {
        ikft_mutex = sal_mutex_create("ikft");
        if (ikft_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ikft_enable: Failed mutex create for table %s\n", "ikft"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h1_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h1_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H1_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_enable: Failed enable table %s\n", "arlfm1_ght_h1"));
    }
    if (arlfm1_ght_h1_mutex == NULL) {
        arlfm1_ght_h1_mutex = sal_mutex_create("arlfm1_ght_h1");
        if (arlfm1_ght_h1_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_arlfm1_ght_h1_enable: Failed mutex create for table %s\n", "arlfm1_ght_h1"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epmt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epmt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPMT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_enable: Failed enable table %s\n", "epmt"));
    }
    if (epmt_mutex == NULL) {
        epmt_mutex = sal_mutex_create("epmt");
        if (epmt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_epmt_enable: Failed mutex create for table %s\n", "epmt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_bmu_tx_reorder_req_lmt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_bmu_tx_reorder_req_lmt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_enable: Failed enable table %s\n", "epp_bmu_tx_reorder_req_lmt"));
    }
    if (epp_bmu_tx_reorder_req_lmt_mutex == NULL) {
        epp_bmu_tx_reorder_req_lmt_mutex = sal_mutex_create("epp_bmu_tx_reo");
        if (epp_bmu_tx_reorder_req_lmt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_epp_bmu_tx_reorder_req_lmt_enable: Failed mutex create for table %s\n", "epp_bmu_tx_reorder_req_lmt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pptr_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pptr_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PPTR_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_enable: Failed enable table %s\n", "bmu_pptr"));
    }
    if (bmu_pptr_mutex == NULL) {
        bmu_pptr_mutex = sal_mutex_create("bmu_pptr");
        if (bmu_pptr_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_bmu_pptr_enable: Failed mutex create for table %s\n", "bmu_pptr"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ert_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ert_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ERT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_enable: Failed enable table %s\n", "ert"));
    }
    if (ert_mutex == NULL) {
        ert_mutex = sal_mutex_create("ert");
        if (ert_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ert_enable: Failed mutex create for table %s\n", "ert"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_action_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_action_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ACTION_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_enable: Failed enable table %s\n", "action"));
    }
    if (action_mutex == NULL) {
        action_mutex = sal_mutex_create("action");
        if (action_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_action_enable: Failed mutex create for table %s\n", "action"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpslict_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpslict_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPSLICT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_enable: Failed enable table %s\n", "rpslict"));
    }
    if (rpslict_mutex == NULL) {
        rpslict_mutex = sal_mutex_create("rpslict");
        if (rpslict_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_rpslict_enable: Failed mutex create for table %s\n", "rpslict"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slictecc_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slictecc_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICTECC_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_enable: Failed enable table %s\n", "slictecc"));
    }
    if (slictecc_mutex == NULL) {
        slictecc_mutex = sal_mutex_create("slictecc");
        if (slictecc_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_slictecc_enable: Failed mutex create for table %s\n", "slictecc"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_litet_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_litet_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LITET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_enable: Failed enable table %s\n", "litet"));
    }
    if (litet_mutex == NULL) {
        litet_mutex = sal_mutex_create("litet");
        if (litet_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_litet_enable: Failed mutex create for table %s\n", "litet"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tecc_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tecc_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TECC_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_enable: Failed enable table %s\n", "tecc"));
    }
    if (tecc_mutex == NULL) {
        tecc_mutex = sal_mutex_create("tecc");
        if (tecc_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_tecc_enable: Failed mutex create for table %s\n", "tecc"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pptr_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pptr_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PPTR_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_enable: Failed enable table %s\n", "cfp_pptr"));
    }
    if (cfp_pptr_mutex == NULL) {
        cfp_pptr_mutex = sal_mutex_create("cfp_pptr");
        if (cfp_pptr_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_cfp_pptr_enable: Failed mutex create for table %s\n", "cfp_pptr"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wrt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wrt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WRT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_enable: Failed enable table %s\n", "wrt"));
    }
    if (wrt_mutex == NULL) {
        wrt_mutex = sal_mutex_create("wrt");
        if (wrt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_wrt_enable: Failed mutex create for table %s\n", "wrt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wpt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wpt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WPT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_enable: Failed enable table %s\n", "wpt"));
    }
    if (wpt_mutex == NULL) {
        wpt_mutex = sal_mutex_create("wpt");
        if (wpt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_wpt_enable: Failed mutex create for table %s\n", "wpt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dliet_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dliet_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLIET_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_enable: Failed enable table %s\n", "dliet"));
    }
    if (dliet_mutex == NULL) {
        dliet_mutex = sal_mutex_create("dliet");
        if (dliet_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_dliet_enable: Failed mutex create for table %s\n", "dliet"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pglct_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pglct_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGLCT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_enable: Failed enable table %s\n", "pglct"));
    }
    if (pglct_mutex == NULL) {
        pglct_mutex = sal_mutex_create("pglct");
        if (pglct_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pglct_enable: Failed mutex create for table %s\n", "pglct"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ap_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ap_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2AP_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_enable: Failed enable table %s\n", "lpg2ap"));
    }
    if (lpg2ap_mutex == NULL) {
        lpg2ap_mutex = sal_mutex_create("lpg2ap");
        if (lpg2ap_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_lpg2ap_enable: Failed mutex create for table %s\n", "lpg2ap"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_profile_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_profile_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PROFILE_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_enable: Failed enable table %s\n", "pqm_profile"));
    }
    if (pqm_profile_mutex == NULL) {
        pqm_profile_mutex = sal_mutex_create("pqm_profile");
        if (pqm_profile_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pqm_profile_enable: Failed mutex create for table %s\n", "pqm_profile"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cpmt_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cpmt_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CPMT_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_enable: Failed enable table %s\n", "cpmt"));
    }
    if (cpmt_mutex == NULL) {
        cpmt_mutex = sal_mutex_create("cpmt");
        if (cpmt_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_cpmt_enable: Failed mutex create for table %s\n", "cpmt"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pp2lpg_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pp2lpg_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PP2LPG_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_enable: Failed enable table %s\n", "pqm_pp2lpg"));
    }
    if (pqm_pp2lpg_mutex == NULL) {
        pqm_pp2lpg_mutex = sal_mutex_create("pqm_pp2lpg");
        if (pqm_pp2lpg_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_pqm_pp2lpg_enable: Failed mutex create for table %s\n", "pqm_pp2lpg"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ofarlfm_enable
 * @par Description:
 *      Enable the table, take it out of low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ofarlfm_enable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Issue table enable cmd */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_OFARLFM_ID, 
             ROBO2_IA_OP_TABLE_ENABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_enable: Failed enable table %s\n", "ofarlfm"));
    }
    if (ofarlfm_mutex == NULL) {
        ofarlfm_mutex = sal_mutex_create("ofarlfm");
        if (ofarlfm_mutex == NULL) {
            LOG_ERROR(BSL_LS_SOC_CRAL,
                   ("soc_robo2_ofarlfm_enable: Failed mutex create for table %s\n", "ofarlfm"));
            rc = SOC_E_INIT;
        }
    }
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tct_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tct_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TCT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tct_disable: Failed disable table %s\n", "tct"));
    }
    if (tct_mutex != NULL) {
        sal_mutex_destroy(tct_mutex);
        tct_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpt_disable: Failed disable table %s\n", "rpt"));
    }
    if (rpt_mutex != NULL) {
        sal_mutex_destroy(rpt_mutex);
        rpt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pgt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pgt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pgt_disable: Failed disable table %s\n", "pgt"));
    }
    if (pgt_mutex != NULL) {
        sal_mutex_destroy(pgt_mutex);
        pgt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pmipage_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pmipage_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PMIPAGE_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pmipage_disable: Failed disable table %s\n", "pmipage"));
    }
    if (pmipage_mutex != NULL) {
        sal_mutex_destroy(pmipage_mutex);
        pmipage_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_config_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_config_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CONFIG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_config_disable: Failed disable table %s\n", "gfcd_config"));
    }
    if (gfcd_config_mutex != NULL) {
        sal_mutex_destroy(gfcd_config_mutex);
        gfcd_config_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_apt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_apt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_APT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_apt_disable: Failed disable table %s\n", "apt"));
    }
    if (apt_mutex != NULL) {
        sal_mutex_destroy(apt_mutex);
        apt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gfcd_cntr_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gfcd_cntr_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GFCD_CNTR_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gfcd_cntr_disable: Failed disable table %s\n", "gfcd_cntr"));
    }
    if (gfcd_cntr_mutex != NULL) {
        sal_mutex_destroy(gfcd_cntr_mutex);
        gfcd_cntr_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spg_pp_bmp_config_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spg_pp_bmp_config_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPG_PP_BMP_CONFIG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spg_pp_bmp_config_disable: Failed disable table %s\n", "spg_pp_bmp_config"));
    }
    if (spg_pp_bmp_config_mutex != NULL) {
        sal_mutex_destroy(spg_pp_bmp_config_mutex);
        spg_pp_bmp_config_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dgt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dgt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DGT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dgt_disable: Failed disable table %s\n", "dgt"));
    }
    if (dgt_mutex != NULL) {
        sal_mutex_destroy(dgt_mutex);
        dgt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_gspg2ig_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_gspg2ig_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GSPG2IG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_gspg2ig_disable: Failed disable table %s\n", "gspg2ig"));
    }
    if (gspg2ig_mutex != NULL) {
        sal_mutex_destroy(gspg2ig_mutex);
        gspg2ig_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_calendar_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_calendar_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_CALENDAR_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_calendar_disable: Failed disable table %s\n", "epp_calendar"));
    }
    if (epp_calendar_mutex != NULL) {
        sal_mutex_destroy(epp_calendar_mutex);
        epp_calendar_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ght_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ght_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ght_disable: Failed disable table %s\n", "ght"));
    }
    if (ght_mutex != NULL) {
        sal_mutex_destroy(ght_mutex);
        ght_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lin2vsi_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lin2vsi_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LIN2VSI_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lin2vsi_disable: Failed disable table %s\n", "lin2vsi"));
    }
    if (lin2vsi_mutex != NULL) {
        sal_mutex_destroy(lin2vsi_mutex);
        lin2vsi_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_profile_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_profile_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PROFILE_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_profile_disable: Failed disable table %s\n", "cfp_profile"));
    }
    if (cfp_profile_mutex != NULL) {
        sal_mutex_destroy(cfp_profile_mutex);
        cfp_profile_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_bucket_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_bucket_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_BUCKET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_bucket_disable: Failed disable table %s\n", "cfp_bucket"));
    }
    if (cfp_bucket_mutex != NULL) {
        sal_mutex_destroy(cfp_bucket_mutex);
        cfp_bucket_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_calendar_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_calendar_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CALENDAR_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_calendar_disable: Failed disable table %s\n", "calendar"));
    }
    if (calendar_mutex != NULL) {
        sal_mutex_destroy(calendar_mutex);
        calendar_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pg2lpg_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pg2lpg_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PG2LPG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pg2lpg_disable: Failed disable table %s\n", "pg2lpg"));
    }
    if (pg2lpg_mutex != NULL) {
        sal_mutex_destroy(pg2lpg_mutex);
        pg2lpg_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm_disable: Failed disable table %s\n", "arlfm"));
    }
    if (arlfm_mutex != NULL) {
        sal_mutex_destroy(arlfm_mutex);
        arlfm_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm0_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm0_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM0_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm0_disable: Failed disable table %s\n", "arlfm0"));
    }
    if (arlfm0_mutex != NULL) {
        sal_mutex_destroy(arlfm0_mutex);
        arlfm0_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_bucket_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_bucket_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_BUCKET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_bucket_disable: Failed disable table %s\n", "ipp_bucket"));
    }
    if (ipp_bucket_mutex != NULL) {
        sal_mutex_destroy(ipp_bucket_mutex);
        ipp_bucket_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_config_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_config_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CONFIG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_config_disable: Failed disable table %s\n", "fcd_config"));
    }
    if (fcd_config_mutex != NULL) {
        sal_mutex_destroy(fcd_config_mutex);
        fcd_config_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stat_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stat_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STAT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stat_disable: Failed disable table %s\n", "stat"));
    }
    if (stat_mutex != NULL) {
        sal_mutex_destroy(stat_mutex);
        stat_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_eeecfg_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_eeecfg_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EEECFG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_eeecfg_disable: Failed disable table %s\n", "eeecfg"));
    }
    if (eeecfg_mutex != NULL) {
        sal_mutex_destroy(eeecfg_mutex);
        eeecfg_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_hdt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_hdt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_HDT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_hdt_disable: Failed disable table %s\n", "hdt"));
    }
    if (hdt_mutex != NULL) {
        sal_mutex_destroy(hdt_mutex);
        hdt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_estget_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_estget_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ESTGET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_estget_disable: Failed disable table %s\n", "estget"));
    }
    if (estget_mutex != NULL) {
        sal_mutex_destroy(estget_mutex);
        estget_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_stt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_stt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_STT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_stt_disable: Failed disable table %s\n", "stt"));
    }
    if (stt_mutex != NULL) {
        sal_mutex_destroy(stt_mutex);
        stt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pet_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pet_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pet_disable: Failed disable table %s\n", "pet"));
    }
    if (pet_mutex != NULL) {
        sal_mutex_destroy(pet_mutex);
        pet_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_istget_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_istget_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ISTGET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_istget_disable: Failed disable table %s\n", "istget"));
    }
    if (istget_mutex != NULL) {
        sal_mutex_destroy(istget_mutex);
        istget_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qdschcfg_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qdschcfg_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QDSCHCFG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qdschcfg_disable: Failed disable table %s\n", "qdschcfg"));
    }
    if (qdschcfg_mutex != NULL) {
        sal_mutex_destroy(qdschcfg_mutex);
        qdschcfg_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_rscale_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_rscale_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_RSCALE_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_rscale_disable: Failed disable table %s\n", "pqm_rscale"));
    }
    if (pqm_rscale_mutex != NULL) {
        sal_mutex_destroy(pqm_rscale_mutex);
        pqm_rscale_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtr2tcb_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtr2tcb_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTR2TCB_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtr2tcb_disable: Failed disable table %s\n", "mtr2tcb"));
    }
    if (mtr2tcb_mutex != NULL) {
        sal_mutex_destroy(mtr2tcb_mutex);
        mtr2tcb_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dli2ldpg_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dli2ldpg_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLI2LDPG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dli2ldpg_disable: Failed disable table %s\n", "dli2ldpg"));
    }
    if (dli2ldpg_mutex != NULL) {
        sal_mutex_destroy(dli2ldpg_mutex);
        dli2ldpg_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tc2qd_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tc2qd_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TC2QD_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tc2qd_disable: Failed disable table %s\n", "tc2qd"));
    }
    if (tc2qd_mutex != NULL) {
        sal_mutex_destroy(tc2qd_mutex);
        tc2qd_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_spldt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_spldt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SPLDT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_spldt_disable: Failed disable table %s\n", "spldt"));
    }
    if (spldt_mutex != NULL) {
        sal_mutex_destroy(spldt_mutex);
        spldt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_rscale_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_rscale_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_RSCALE_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_rscale_disable: Failed disable table %s\n", "cfp_rscale"));
    }
    if (cfp_rscale_mutex != NULL) {
        sal_mutex_destroy(cfp_rscale_mutex);
        cfp_rscale_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghtdt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghtdt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHTDT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghtdt_disable: Failed disable table %s\n", "ghtdt"));
    }
    if (ghtdt_mutex != NULL) {
        sal_mutex_destroy(ghtdt_mutex);
        ghtdt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_bucket_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_bucket_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_BUCKET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_bucket_disable: Failed disable table %s\n", "bmu_bucket"));
    }
    if (bmu_bucket_mutex != NULL) {
        sal_mutex_destroy(bmu_bucket_mutex);
        bmu_bucket_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lilt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lilt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LILT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lilt_disable: Failed disable table %s\n", "lilt"));
    }
    if (lilt_mutex != NULL) {
        sal_mutex_destroy(lilt_mutex);
        lilt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_svt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_svt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SVT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_svt_disable: Failed disable table %s\n", "svt"));
    }
    if (svt_mutex != NULL) {
        sal_mutex_destroy(svt_mutex);
        svt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slicmap_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slicmap_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICMAP_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slicmap_disable: Failed disable table %s\n", "slicmap"));
    }
    if (slicmap_mutex != NULL) {
        sal_mutex_destroy(slicmap_mutex);
        slicmap_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_m2tk_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_m2tk_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_M2TK_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_m2tk_disable: Failed disable table %s\n", "m2tk"));
    }
    if (m2tk_mutex != NULL) {
        sal_mutex_destroy(m2tk_mutex);
        m2tk_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_art_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_art_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ART_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_art_disable: Failed disable table %s\n", "art"));
    }
    if (art_mutex != NULL) {
        sal_mutex_destroy(art_mutex);
        art_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ig_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ig_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2IG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ig_disable: Failed disable table %s\n", "lpg2ig"));
    }
    if (lpg2ig_mutex != NULL) {
        sal_mutex_destroy(lpg2ig_mutex);
        lpg2ig_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_profile_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_profile_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PROFILE_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_profile_disable: Failed disable table %s\n", "ipp_profile"));
    }
    if (ipp_profile_mutex != NULL) {
        sal_mutex_destroy(ipp_profile_mutex);
        ipp_profile_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfcqdaddr_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfcqdaddr_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCQDADDR_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfcqdaddr_disable: Failed disable table %s\n", "qfcqdaddr"));
    }
    if (qfcqdaddr_mutex != NULL) {
        sal_mutex_destroy(qfcqdaddr_mutex);
        qfcqdaddr_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_mtgt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_mtgt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MTGT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_mtgt_disable: Failed disable table %s\n", "mtgt"));
    }
    if (mtgt_mutex != NULL) {
        sal_mutex_destroy(mtgt_mutex);
        mtgt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pptr_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pptr_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PPTR_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pptr_disable: Failed disable table %s\n", "ipp_pptr"));
    }
    if (ipp_pptr_mutex != NULL) {
        sal_mutex_destroy(ipp_pptr_mutex);
        ipp_pptr_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_set_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_set_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_set_disable: Failed disable table %s\n", "set"));
    }
    if (set_mutex != NULL) {
        sal_mutex_destroy(set_mutex);
        set_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_srt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_srt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SRT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_srt_disable: Failed disable table %s\n", "srt"));
    }
    if (srt_mutex != NULL) {
        sal_mutex_destroy(srt_mutex);
        srt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pmon_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pmon_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PMON_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pmon_disable: Failed disable table %s\n", "ipp_pmon"));
    }
    if (ipp_pmon_mutex != NULL) {
        sal_mutex_destroy(ipp_pmon_mutex);
        ipp_pmon_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vtct_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vtct_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VTCT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vtct_disable: Failed disable table %s\n", "vtct"));
    }
    if (vtct_mutex != NULL) {
        sal_mutex_destroy(vtct_mutex);
        vtct_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfpcam_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfpcam_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFPCAM_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfpcam_disable: Failed disable table %s\n", "cfpcam"));
    }
    if (cfpcam_mutex != NULL) {
        sal_mutex_destroy(cfpcam_mutex);
        cfpcam_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fcd_cntr_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fcd_cntr_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FCD_CNTR_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fcd_cntr_disable: Failed disable table %s\n", "fcd_cntr"));
    }
    if (fcd_cntr_mutex != NULL) {
        sal_mutex_destroy(fcd_cntr_mutex);
        fcd_cntr_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_fpslict_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_fpslict_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_FPSLICT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_fpslict_disable: Failed disable table %s\n", "fpslict"));
    }
    if (fpslict_mutex != NULL) {
        sal_mutex_destroy(fpslict_mutex);
        fpslict_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_kst_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_kst_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_KST_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_kst_disable: Failed disable table %s\n", "kst"));
    }
    if (kst_mutex != NULL) {
        sal_mutex_destroy(kst_mutex);
        kst_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_bucket_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_bucket_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_BUCKET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_bucket_disable: Failed disable table %s\n", "pqm_bucket"));
    }
    if (pqm_bucket_mutex != NULL) {
        sal_mutex_destroy(pqm_bucket_mutex);
        pqm_bucket_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ghst_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ghst_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_GHST_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ghst_disable: Failed disable table %s\n", "ghst"));
    }
    if (ghst_mutex != NULL) {
        sal_mutex_destroy(ghst_mutex);
        ghst_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2pg_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2pg_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2pg_disable: Failed disable table %s\n", "lpg2pg"));
    }
    if (lpg2pg_mutex != NULL) {
        sal_mutex_destroy(lpg2pg_mutex);
        lpg2pg_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epgt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epgt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPGT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epgt_disable: Failed disable table %s\n", "epgt"));
    }
    if (epgt_mutex != NULL) {
        sal_mutex_destroy(epgt_mutex);
        epgt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_rscale_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_rscale_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_RSCALE_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_rscale_disable: Failed disable table %s\n", "bmu_rscale"));
    }
    if (bmu_rscale_mutex != NULL) {
        sal_mutex_destroy(bmu_rscale_mutex);
        bmu_rscale_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ppfov_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ppfov_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2PPFOV_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ppfov_disable: Failed disable table %s\n", "lpg2ppfov"));
    }
    if (lpg2ppfov_mutex != NULL) {
        sal_mutex_destroy(lpg2ppfov_mutex);
        lpg2ppfov_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_vsit_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_vsit_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_VSIT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_vsit_disable: Failed disable table %s\n", "vsit"));
    }
    if (vsit_mutex != NULL) {
        sal_mutex_destroy(vsit_mutex);
        vsit_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_qfccredit_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_qfccredit_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_QFCCREDIT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_qfccredit_disable: Failed disable table %s\n", "qfccredit"));
    }
    if (qfccredit_mutex != NULL) {
        sal_mutex_destroy(qfccredit_mutex);
        qfccredit_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tet_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tet_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tet_disable: Failed disable table %s\n", "tet"));
    }
    if (tet_mutex != NULL) {
        sal_mutex_destroy(tet_mutex);
        tet_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_pp2lpg_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_pp2lpg_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_PP2LPG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_pp2lpg_disable: Failed disable table %s\n", "ipp_pp2lpg"));
    }
    if (ipp_pp2lpg_mutex != NULL) {
        sal_mutex_destroy(ipp_pp2lpg_mutex);
        ipp_pp2lpg_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pptr_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pptr_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PPTR_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pptr_disable: Failed disable table %s\n", "pqm_pptr"));
    }
    if (pqm_pptr_mutex != NULL) {
        sal_mutex_destroy(pqm_pptr_mutex);
        pqm_pptr_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pmon_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pmon_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PMON_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pmon_disable: Failed disable table %s\n", "bmu_pmon"));
    }
    if (bmu_pmon_mutex != NULL) {
        sal_mutex_destroy(bmu_pmon_mutex);
        bmu_pmon_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_etct_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_etct_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ETCT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_etct_disable: Failed disable table %s\n", "etct"));
    }
    if (etct_mutex != NULL) {
        sal_mutex_destroy(etct_mutex);
        etct_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h0_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h0_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H0_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h0_disable: Failed disable table %s\n", "arlfm1_ght_h0"));
    }
    if (arlfm1_ght_h0_mutex != NULL) {
        sal_mutex_destroy(arlfm1_ght_h0_mutex);
        arlfm1_ght_h0_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pmon_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pmon_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PMON_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pmon_disable: Failed disable table %s\n", "cfp_pmon"));
    }
    if (cfp_pmon_mutex != NULL) {
        sal_mutex_destroy(cfp_pmon_mutex);
        cfp_pmon_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_max_config_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_max_config_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_MAX_CONFIG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_max_config_disable: Failed disable table %s\n", "max_config"));
    }
    if (max_config_mutex != NULL) {
        sal_mutex_destroy(max_config_mutex);
        max_config_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_profile_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_profile_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PROFILE_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_profile_disable: Failed disable table %s\n", "bmu_profile"));
    }
    if (bmu_profile_mutex != NULL) {
        sal_mutex_destroy(bmu_profile_mutex);
        bmu_profile_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pv2li_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pv2li_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PV2LI_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pv2li_disable: Failed disable table %s\n", "pv2li"));
    }
    if (pv2li_mutex != NULL) {
        sal_mutex_destroy(pv2li_mutex);
        pv2li_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ipp_rscale_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ipp_rscale_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IPP_RSCALE_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ipp_rscale_disable: Failed disable table %s\n", "ipp_rscale"));
    }
    if (ipp_rscale_mutex != NULL) {
        sal_mutex_destroy(ipp_rscale_mutex);
        ipp_rscale_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pmon_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pmon_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PMON_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pmon_disable: Failed disable table %s\n", "pqm_pmon"));
    }
    if (pqm_pmon_mutex != NULL) {
        sal_mutex_destroy(pqm_pmon_mutex);
        pqm_pmon_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ikft_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ikft_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_IKFT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ikft_disable: Failed disable table %s\n", "ikft"));
    }
    if (ikft_mutex != NULL) {
        sal_mutex_destroy(ikft_mutex);
        ikft_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_arlfm1_ght_h1_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_arlfm1_ght_h1_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ARLFM1_GHT_H1_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_arlfm1_ght_h1_disable: Failed disable table %s\n", "arlfm1_ght_h1"));
    }
    if (arlfm1_ght_h1_mutex != NULL) {
        sal_mutex_destroy(arlfm1_ght_h1_mutex);
        arlfm1_ght_h1_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epmt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epmt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPMT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epmt_disable: Failed disable table %s\n", "epmt"));
    }
    if (epmt_mutex != NULL) {
        sal_mutex_destroy(epmt_mutex);
        epmt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_epp_bmu_tx_reorder_req_lmt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_epp_bmu_tx_reorder_req_lmt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_EPP_BMU_TX_REORDER_REQ_LMT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_epp_bmu_tx_reorder_req_lmt_disable: Failed disable table %s\n", "epp_bmu_tx_reorder_req_lmt"));
    }
    if (epp_bmu_tx_reorder_req_lmt_mutex != NULL) {
        sal_mutex_destroy(epp_bmu_tx_reorder_req_lmt_mutex);
        epp_bmu_tx_reorder_req_lmt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_bmu_pptr_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_bmu_pptr_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_BMU_PPTR_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_bmu_pptr_disable: Failed disable table %s\n", "bmu_pptr"));
    }
    if (bmu_pptr_mutex != NULL) {
        sal_mutex_destroy(bmu_pptr_mutex);
        bmu_pptr_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ert_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ert_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ERT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ert_disable: Failed disable table %s\n", "ert"));
    }
    if (ert_mutex != NULL) {
        sal_mutex_destroy(ert_mutex);
        ert_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_action_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_action_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_ACTION_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_action_disable: Failed disable table %s\n", "action"));
    }
    if (action_mutex != NULL) {
        sal_mutex_destroy(action_mutex);
        action_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_rpslict_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_rpslict_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_RPSLICT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_rpslict_disable: Failed disable table %s\n", "rpslict"));
    }
    if (rpslict_mutex != NULL) {
        sal_mutex_destroy(rpslict_mutex);
        rpslict_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_slictecc_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_slictecc_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_SLICTECC_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_slictecc_disable: Failed disable table %s\n", "slictecc"));
    }
    if (slictecc_mutex != NULL) {
        sal_mutex_destroy(slictecc_mutex);
        slictecc_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_litet_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_litet_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LITET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_litet_disable: Failed disable table %s\n", "litet"));
    }
    if (litet_mutex != NULL) {
        sal_mutex_destroy(litet_mutex);
        litet_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_tecc_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_tecc_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_TECC_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_tecc_disable: Failed disable table %s\n", "tecc"));
    }
    if (tecc_mutex != NULL) {
        sal_mutex_destroy(tecc_mutex);
        tecc_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cfp_pptr_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cfp_pptr_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CFP_PPTR_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cfp_pptr_disable: Failed disable table %s\n", "cfp_pptr"));
    }
    if (cfp_pptr_mutex != NULL) {
        sal_mutex_destroy(cfp_pptr_mutex);
        cfp_pptr_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wrt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wrt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WRT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wrt_disable: Failed disable table %s\n", "wrt"));
    }
    if (wrt_mutex != NULL) {
        sal_mutex_destroy(wrt_mutex);
        wrt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_wpt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_wpt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_WPT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_wpt_disable: Failed disable table %s\n", "wpt"));
    }
    if (wpt_mutex != NULL) {
        sal_mutex_destroy(wpt_mutex);
        wpt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_dliet_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_dliet_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_DLIET_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_dliet_disable: Failed disable table %s\n", "dliet"));
    }
    if (dliet_mutex != NULL) {
        sal_mutex_destroy(dliet_mutex);
        dliet_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pglct_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pglct_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PGLCT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pglct_disable: Failed disable table %s\n", "pglct"));
    }
    if (pglct_mutex != NULL) {
        sal_mutex_destroy(pglct_mutex);
        pglct_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_lpg2ap_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_lpg2ap_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_LPG2AP_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_lpg2ap_disable: Failed disable table %s\n", "lpg2ap"));
    }
    if (lpg2ap_mutex != NULL) {
        sal_mutex_destroy(lpg2ap_mutex);
        lpg2ap_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_profile_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_profile_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PROFILE_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_profile_disable: Failed disable table %s\n", "pqm_profile"));
    }
    if (pqm_profile_mutex != NULL) {
        sal_mutex_destroy(pqm_profile_mutex);
        pqm_profile_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_cpmt_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_cpmt_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_CPMT_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_cpmt_disable: Failed disable table %s\n", "cpmt"));
    }
    if (cpmt_mutex != NULL) {
        sal_mutex_destroy(cpmt_mutex);
        cpmt_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_pqm_pp2lpg_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_pqm_pp2lpg_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_PQM_PP2LPG_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_pqm_pp2lpg_disable: Failed disable table %s\n", "pqm_pp2lpg"));
    }
    if (pqm_pp2lpg_mutex != NULL) {
        sal_mutex_destroy(pqm_pp2lpg_mutex);
        pqm_pp2lpg_mutex = NULL;
    }
    
    return rc;
}

/**
 * @par Function: 
 *      soc_robo2_ofarlfm_disable
 * @par Description:
 *      Disable the table, put it in low power mode
 * 
 *    @param [in]  unit  :  Identifies the chip
 * 
 *    @return SOC_E_NONE on success
 *    @return SOC_E_xxxx on failure
 */
int
soc_robo2_ofarlfm_disable(int unit)
{
    int rc = SOC_E_NONE;
    uint32 status  = 0;

    /* Initiate table Disable */
    rc = soc_robo2_table_operation(unit, ROBO2_TABLE_OFARLFM_ID,
             ROBO2_IA_OP_TABLE_DISABLE, 0, &status);
    if (rc != SOC_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_CRAL,
               ("soc_robo2_ofarlfm_disable: Failed disable table %s\n", "ofarlfm"));
    }
    if (ofarlfm_mutex != NULL) {
        sal_mutex_destroy(ofarlfm_mutex);
        ofarlfm_mutex = NULL;
    }
    
    return rc;
}
